[
    {
        "method_name": "writeBitmapToFile",
        "method_code": "rivate boolean writeBitmapToFile(Bitmap bitmap, DiskLruCache.Editor editor) throws IOException {\n        OutputStream out = null;\n        try {\n            out = new BufferedOutputStream(editor.newOutputStream(0), IO_BUFFER_SIZE);\n            return bitmap.compress(mCompressFormat, mCompressQuality, out);\n        } finally {\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled writeBitmapToFile from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: writeBitmapToFile\n\n        Method Code: rivate boolean writeBitmapToFile(Bitmap bitmap, DiskLruCache.Editor editor) throws IOException {\n        OutputStream out = null;\n        try {\n            out = new BufferedOutputStream(editor.newOutputStream(0), IO_BUFFER_SIZE);\n            return bitmap.compress(mCompressFormat, mCompressQuality, out);\n        } finally {\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func writeBitmapToFile(bitmap: UIImage, editor: DiskLruCache.Editor) throws -> Bool {\n    var out: OutputStream? = nil\n    do {\n        out = OutputStream(toBuffer: UnsafeMutablePointer<UInt8>.allocate(capacity: IO_BUFFER_SIZE), capacity: IO_BUFFER_SIZE)\n        out?.open()\n        return bitmap.jpegData(compressionQuality: mCompressQuality)!.write(to: out!)\n    } finally {\n        if let out = out {\n            out.close()\n        }\n    }\n}\n```"
    },
    {
        "method_name": "put",
        "method_code": "ublic void put(String key, Bitmap data) {\n\n        DiskLruCache.Editor editor = null;\n        String validKey = convertToValidKey(key);\n        try {\n            editor = mDiskCache.edit(validKey);\n            if (editor == null) {\n                return;\n            }\n\n            if (writeBitmapToFile(data, editor)) {\n                mDiskCache.flush();\n                editor.commit();\n                if (BuildConfig.DEBUG) {\n                    Log_OC.d(CACHE_TEST_DISK, \"image put on disk cache \" + validKey);\n                }\n            } else {\n                editor.abort();\n                if (BuildConfig.DEBUG) {\n                    Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \" + validKey);\n                }\n            }\n        } catch (IOException e) {\n            if (BuildConfig.DEBUG) {\n                Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \" + validKey);\n            }\n            try {\n                if (editor != null) {\n                    editor.abort();\n                }\n            } catch (IOException ex) {\n                Log_OC.d(TAG, \"Error aborting editor\", ex);\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled put from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: put\n\n        Method Code: ublic void put(String key, Bitmap data) {\n\n        DiskLruCache.Editor editor = null;\n        String validKey = convertToValidKey(key);\n        try {\n            editor = mDiskCache.edit(validKey);\n            if (editor == null) {\n                return;\n            }\n\n            if (writeBitmapToFile(data, editor)) {\n                mDiskCache.flush();\n                editor.commit();\n                if (BuildConfig.DEBUG) {\n                    Log_OC.d(CACHE_TEST_DISK, \"image put on disk cache \" + validKey);\n                }\n            } else {\n                editor.abort();\n                if (BuildConfig.DEBUG) {\n                    Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \" + validKey);\n                }\n            }\n        } catch (IOException e) {\n            if (BuildConfig.DEBUG) {\n                Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \" + validKey);\n            }\n            try {\n                if (editor != null) {\n                    editor.abort();\n                }\n            } catch (IOException ex) {\n                Log_OC.d(TAG, \"Error aborting editor\", ex);\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc put(key: String, data: UIImage) {\n    var editor: DiskLruCache.Editor? = nil\n    let validKey = convertToValidKey(key)\n    do {\n        editor = try mDiskCache.edit(validKey)\n        if editor == nil {\n            return\n        }\n\n        if writeBitmapToFile(data, editor: editor!) {\n            try mDiskCache.flush()\n            try editor?.commit()\n            #if DEBUG\n            Log_OC.d(CACHE_TEST_DISK, \"image put on disk cache \\(validKey)\")\n            #endif\n        } else {\n            try editor?.abort()\n            #if DEBUG\n            Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \\(validKey)\")\n            #endif\n        }\n    } catch {\n        #if DEBUG\n        Log_OC.d(CACHE_TEST_DISK, \"ERROR on: image put on disk cache \\(validKey)\")\n        #endif\n        do {\n            try editor?.abort()\n        } catch {\n            Log_OC.d(TAG, \"Error aborting editor\", error)\n        }\n    }\n}\n```"
    },
    {
        "method_name": "getScaledBitmap",
        "method_code": "ublic Bitmap getScaledBitmap(String key, int width, int height) {\n        Bitmap bitmap = null;\n        String validKey = convertToValidKey(key);\n\n        try (DiskLruCache.Snapshot snapshot = mDiskCache.get(validKey)) {\n            if (snapshot == null) {\n                return null;\n            }\n\n            InputStream inputStream = snapshot.getInputStream(0);\n            if (inputStream != null) {\n                // First decode with inJustDecodeBounds=true to check dimensions\n                final BitmapFactory.Options options = new BitmapFactory.Options();\n                try (BufferedInputStream buffIn = new BufferedInputStream(inputStream, IO_BUFFER_SIZE)) {\n                    options.inScaled = true;\n                    options.inPurgeable = true;\n                    options.inPreferQualityOverSpeed = false;\n                    options.inMutable = false;\n                    options.inJustDecodeBounds = true;\n\n                    BitmapFactory.decodeStream(buffIn, null, options);\n                }\n\n                try (DiskLruCache.Snapshot snapshot2 = mDiskCache.get(validKey)) {\n                    inputStream = snapshot2.getInputStream(0);\n\n                    try (BufferedInputStream buffIn = new BufferedInputStream(inputStream, IO_BUFFER_SIZE)) {\n                        // Calculate inSampleSize\n                        options.inSampleSize = BitmapUtils.calculateSampleFactor(options, width, height);\n\n                        // Decode bitmap with inSampleSize set\n                        options.inJustDecodeBounds = false;\n                        bitmap = BitmapFactory.decodeStream(buffIn, null, options);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage(), e);\n        }\n\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, bitmap == null ? \"not found\" : \"image read from disk \" + validKey);\n        }\n\n        return bitmap;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getScaledBitmap from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: getScaledBitmap\n\n        Method Code: ublic Bitmap getScaledBitmap(String key, int width, int height) {\n        Bitmap bitmap = null;\n        String validKey = convertToValidKey(key);\n\n        try (DiskLruCache.Snapshot snapshot = mDiskCache.get(validKey)) {\n            if (snapshot == null) {\n                return null;\n            }\n\n            InputStream inputStream = snapshot.getInputStream(0);\n            if (inputStream != null) {\n                // First decode with inJustDecodeBounds=true to check dimensions\n                final BitmapFactory.Options options = new BitmapFactory.Options();\n                try (BufferedInputStream buffIn = new BufferedInputStream(inputStream, IO_BUFFER_SIZE)) {\n                    options.inScaled = true;\n                    options.inPurgeable = true;\n                    options.inPreferQualityOverSpeed = false;\n                    options.inMutable = false;\n                    options.inJustDecodeBounds = true;\n\n                    BitmapFactory.decodeStream(buffIn, null, options);\n                }\n\n                try (DiskLruCache.Snapshot snapshot2 = mDiskCache.get(validKey)) {\n                    inputStream = snapshot2.getInputStream(0);\n\n                    try (BufferedInputStream buffIn = new BufferedInputStream(inputStream, IO_BUFFER_SIZE)) {\n                        // Calculate inSampleSize\n                        options.inSampleSize = BitmapUtils.calculateSampleFactor(options, width, height);\n\n                        // Decode bitmap with inSampleSize set\n                        options.inJustDecodeBounds = false;\n                        bitmap = BitmapFactory.decodeStream(buffIn, null, options);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            Log_OC.e(TAG, e.getMessage(), e);\n        }\n\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, bitmap == null ? \"not found\" : \"image read from disk \" + validKey);\n        }\n\n        return bitmap;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getScaledBitmap(key: String, width: Int, height: Int) -> UIImage? {\n    var bitmap: UIImage? = nil\n    let validKey = convertToValidKey(key: key)\n\n    do {\n        if let snapshot = try mDiskCache.get(validKey) {\n            defer { snapshot.close() }\n            if let inputStream = snapshot.inputStream(0) {\n                let options = [kCGImageSourceShouldCache: false] as CFDictionary\n                let bufferedInputStream = InputStream(data: inputStream.readDataToEndOfFile())\n                bufferedInputStream.open()\n                defer { bufferedInputStream.close() }\n                \n                if let imageSource = CGImageSourceCreateWithData(bufferedInputStream.readDataToEndOfFile() as CFData, options) {\n                    let propertiesOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n                    if let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, propertiesOptions) as? [CFString: Any] {\n                        let sampleSize = BitmapUtils.calculateSampleFactor(properties: properties, width: width, height: height)\n                        let options = [kCGImageSourceCreateThumbnailFromImageAlways: true,\n                                       kCGImageSourceThumbnailMaxPixelSize: sampleSize] as CFDictionary\n                        if let cgImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options) {\n                            bitmap = UIImage(cgImage: cgImage)\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        print(\"Error: \\(error.localizedDescription)\")\n    }\n\n    if BuildConfig.DEBUG {\n        print(bitmap == nil ? \"not found\" : \"image read from disk \\(validKey)\")\n    }\n\n    return bitmap\n}\n```"
    },
    {
        "method_name": "getBitmap",
        "method_code": "ublic Bitmap getBitmap(String key) {\n        Bitmap bitmap = null;\n        DiskLruCache.Snapshot snapshot = null;\n        InputStream in = null;\n        BufferedInputStream buffIn = null;\n        String validKey = convertToValidKey(key);\n\n        try {\n            snapshot = mDiskCache.get(validKey);\n            if (snapshot == null) {\n                return null;\n            }\n            in = snapshot.getInputStream(0);\n            if (in != null) {\n                buffIn = new BufferedInputStream(in, IO_BUFFER_SIZE);\n                bitmap = BitmapFactory.decodeStream(buffIn);\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, e.getMessage(), e);\n        } finally {\n            if (snapshot != null) {\n                snapshot.close();\n            }\n            if (buffIn != null) {\n                try {\n                    buffIn.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, e.getMessage(), e);\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, e.getMessage(), e);\n                }\n            }\n        }\n\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, bitmap == null ? \"not found\" : \"image read from disk \" + validKey);\n        }\n\n        return bitmap;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getBitmap from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: getBitmap\n\n        Method Code: ublic Bitmap getBitmap(String key) {\n        Bitmap bitmap = null;\n        DiskLruCache.Snapshot snapshot = null;\n        InputStream in = null;\n        BufferedInputStream buffIn = null;\n        String validKey = convertToValidKey(key);\n\n        try {\n            snapshot = mDiskCache.get(validKey);\n            if (snapshot == null) {\n                return null;\n            }\n            in = snapshot.getInputStream(0);\n            if (in != null) {\n                buffIn = new BufferedInputStream(in, IO_BUFFER_SIZE);\n                bitmap = BitmapFactory.decodeStream(buffIn);\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, e.getMessage(), e);\n        } finally {\n            if (snapshot != null) {\n                snapshot.close();\n            }\n            if (buffIn != null) {\n                try {\n                    buffIn.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, e.getMessage(), e);\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, e.getMessage(), e);\n                }\n            }\n        }\n\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, bitmap == null ? \"not found\" : \"image read from disk \" + validKey);\n        }\n\n        return bitmap;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getBitmap(forKey key: String) -> UIImage? {\n    var bitmap: UIImage? = nil\n    var snapshot: DiskLruCache.Snapshot? = nil\n    var inputStream: InputStream? = nil\n    var bufferedInputStream: InputStream? = nil\n    let validKey = convertToValidKey(key)\n\n    do {\n        snapshot = try mDiskCache.get(validKey)\n        guard let snapshot = snapshot else {\n            return nil\n        }\n        inputStream = snapshot.inputStream(at: 0)\n        if let inputStream = inputStream {\n            bufferedInputStream = InputStream(data: inputStream.readDataToEndOfFile())\n            if let bufferedInputStream = bufferedInputStream {\n                bitmap = UIImage(data: bufferedInputStream.readDataToEndOfFile())\n            }\n        }\n    } catch {\n        Log_OC.e(TAG, error.localizedDescription)\n    } finally {\n        snapshot?.close()\n        bufferedInputStream?.close()\n        inputStream?.close()\n    }\n\n    if BuildConfig.DEBUG {\n        Log_OC.d(CACHE_TEST_DISK, bitmap == nil ? \"not found\" : \"image read from disk \\(validKey)\")\n    }\n\n    return bitmap\n}\n```"
    },
    {
        "method_name": "containsKey",
        "method_code": "ublic boolean containsKey(String key) {\n\n        boolean contained = false;\n        DiskLruCache.Snapshot snapshot = null;\n        String validKey = convertToValidKey(key);\n        try {\n            snapshot = mDiskCache.get(validKey);\n            contained = snapshot != null;\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        } finally {\n            if (snapshot != null) {\n                snapshot.close();\n            }\n        }\n\n        return contained;\n\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled containsKey from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: containsKey\n\n        Method Code: ublic boolean containsKey(String key) {\n\n        boolean contained = false;\n        DiskLruCache.Snapshot snapshot = null;\n        String validKey = convertToValidKey(key);\n        try {\n            snapshot = mDiskCache.get(validKey);\n            contained = snapshot != null;\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        } finally {\n            if (snapshot != null) {\n                snapshot.close();\n            }\n        }\n\n        return contained;\n\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc containsKey(_ key: String) -> Bool {\n    var contained = false\n    var snapshot: DiskLruCache.Snapshot? = nil\n    let validKey = convertToValidKey(key)\n    do {\n        snapshot = try mDiskCache.get(validKey)\n        contained = snapshot != nil\n    } catch {\n        print(\"\\(TAG): \\(error.localizedDescription)\")\n    } finally {\n        snapshot?.close()\n    }\n    return contained\n}\n```"
    },
    {
        "method_name": "clearCache",
        "method_code": "ublic void clearCache() {\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, \"disk cache CLEARED\");\n        }\n        try {\n            mDiskCache.delete();\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled clearCache from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: clearCache\n\n        Method Code: ublic void clearCache() {\n        if (BuildConfig.DEBUG) {\n            Log_OC.d(CACHE_TEST_DISK, \"disk cache CLEARED\");\n        }\n        try {\n            mDiskCache.delete();\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc clearCache() {\n    #if DEBUG\n    print(\"disk cache CLEARED\")\n    #endif\n    do {\n        try mDiskCache.delete()\n    } catch {\n        print(error.localizedDescription)\n    }\n}\n```"
    },
    {
        "method_name": "getCacheFolder",
        "method_code": "ublic File getCacheFolder() {\n        return mDiskCache.getDirectory();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getCacheFolder from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: getCacheFolder\n\n        Method Code: ublic File getCacheFolder() {\n        return mDiskCache.getDirectory();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getCacheFolder() -> URL {\n    return mDiskCache.directory\n}\n```"
    },
    {
        "method_name": "convertToValidKey",
        "method_code": "rivate String convertToValidKey(String key) {\n        return Integer.toString(key.hashCode());\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertToValidKey from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: convertToValidKey\n\n        Method Code: rivate String convertToValidKey(String key) {\n        return Integer.toString(key.hashCode());\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func convertToValidKey(_ key: String) -> String {\n    return String(key.hashValue)\n}\n```"
    },
    {
        "method_name": "removeKey",
        "method_code": "ublic void removeKey(String key) {\n        String validKey = convertToValidKey(key);\n        try {\n            mDiskCache.remove(validKey);\n            Log_OC.d(TAG, \"removeKey from cache: \" + validKey);\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled removeKey from DiskLruImageCache.java into Swift.\n\n        Input:\n\n        Method Name: removeKey\n\n        Method Code: ublic void removeKey(String key) {\n        String validKey = convertToValidKey(key);\n        try {\n            mDiskCache.remove(validKey);\n            Log_OC.d(TAG, \"removeKey from cache: \" + validKey);\n        } catch (IOException e) {\n            Log_OC.d(TAG, e.getMessage(), e);\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc removeKey(_ key: String) {\n    let validKey = convertToValidKey(key)\n    do {\n        try mDiskCache.remove(validKey)\n        Log_OC.d(TAG, \"removeKey from cache: \\(validKey)\")\n    } catch let error as NSError {\n        Log_OC.d(TAG, error.localizedDescription, error)\n    }\n}\n```"
    }
]