[
    {
        "method_name": "isDigit",
        "method_code": "private static boolean isDigit(char ch) {\n        return ch >= 48 && ch <= 57;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isDigit from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: isDigit\n\n        Method Code: private static boolean isDigit(char ch) {\n        return ch >= 48 && ch <= 57;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isDigit(_ ch: Character) -> Bool {\n    return ch.asciiValue! >= 48 && ch.asciiValue! <= 57\n}\n```"
    },
    {
        "method_name": "isSpecialChar",
        "method_code": "private static boolean isSpecialChar(char ch) {\n        return ch <= 47 || ch >= 58 && ch <= 64 || ch >= 91 && ch <= 96 || ch >= 123 && ch <= 126;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isSpecialChar from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: isSpecialChar\n\n        Method Code: private static boolean isSpecialChar(char ch) {\n        return ch <= 47 || ch >= 58 && ch <= 64 || ch >= 91 && ch <= 96 || ch >= 123 && ch <= 126;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isSpecialChar(_ ch: Character) -> Bool {\n    let asciiValue = ch.asciiValue ?? 0\n    return asciiValue <= 47 || (asciiValue >= 58 && asciiValue <= 64) || (asciiValue >= 91 && asciiValue <= 96) || (asciiValue >= 123 && asciiValue <= 126)\n}\n```"
    },
    {
        "method_name": "getChunk",
        "method_code": "private static String getChunk(String string, int stringLength, int marker) {\n        StringBuilder chunk = new StringBuilder();\n        char c = string.charAt(marker);\n        chunk.append(c);\n        marker++;\n        if (isDigit(c)) {\n            while (marker < stringLength) {\n                c = string.charAt(marker);\n                if (!isDigit(c)) {\n                    break;\n                }\n                chunk.append(c);\n                marker++;\n            }\n        } else if (!isSpecialChar(c)) {\n            while (marker < stringLength) {\n                c = string.charAt(marker);\n                if (isDigit(c) || isSpecialChar(c)) {\n                    break;\n                }\n                chunk.append(c);\n                marker++;\n            }\n        }\n        return chunk.toString();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getChunk from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: getChunk\n\n        Method Code: private static String getChunk(String string, int stringLength, int marker) {\n        StringBuilder chunk = new StringBuilder();\n        char c = string.charAt(marker);\n        chunk.append(c);\n        marker++;\n        if (isDigit(c)) {\n            while (marker < stringLength) {\n                c = string.charAt(marker);\n                if (!isDigit(c)) {\n                    break;\n                }\n                chunk.append(c);\n                marker++;\n            }\n        } else if (!isSpecialChar(c)) {\n            while (marker < stringLength) {\n                c = string.charAt(marker);\n                if (isDigit(c) || isSpecialChar(c)) {\n                    break;\n                }\n                chunk.append(c);\n                marker++;\n            }\n        }\n        return chunk.toString();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func getChunk(_ string: String, _ stringLength: Int, _ marker: inout Int) -> String {\n    var chunk = \"\"\n    var c = string[string.index(string.startIndex, offsetBy: marker)]\n    chunk.append(c)\n    marker += 1\n    if isDigit(c) {\n        while marker < stringLength {\n            c = string[string.index(string.startIndex, offsetBy: marker)]\n            if !isDigit(c) {\n                break\n            }\n            chunk.append(c)\n            marker += 1\n        }\n    } else if !isSpecialChar(c) {\n        while marker < stringLength {\n            c = string[string.index(string.startIndex, offsetBy: marker)]\n            if isDigit(c) || isSpecialChar(c) {\n                break\n            }\n            chunk.append(c)\n            marker += 1\n        }\n    }\n    return chunk\n}\n```"
    },
    {
        "method_name": "compare",
        "method_code": "public static int compare(ServerFileInterface o1, ServerFileInterface o2) {\n        String s1 = o1.getFileName();\n        String s2 = o2.getFileName();\n\n        return compare(s1, s2);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled compare from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: compare\n\n        Method Code: public static int compare(ServerFileInterface o1, ServerFileInterface o2) {\n        String s1 = o1.getFileName();\n        String s2 = o2.getFileName();\n\n        return compare(s1, s2);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func compare(_ o1: ServerFileInterface, _ o2: ServerFileInterface) -> Int {\n    let s1 = o1.getFileName()\n    let s2 = o2.getFileName()\n    \n    return compare(s1, s2)\n}\n```"
    },
    {
        "method_name": "compare",
        "method_code": "public static int compare(File f1, File f2) {\n        String s1 = f1.getPath();\n        String s2 = f2.getPath();\n\n        return compare(s1, s2);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled compare from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: compare\n\n        Method Code: public static int compare(File f1, File f2) {\n        String s1 = f1.getPath();\n        String s2 = f2.getPath();\n\n        return compare(s1, s2);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func compare(_ f1: URL, _ f2: URL) -> Int {\n    let s1 = f1.path\n    let s2 = f2.path\n\n    return compare(s1, s2)\n}\n```"
    },
    {
        "method_name": "compare",
        "method_code": "public int compare(T t1, T t2) {\n        return compare(t1.toString(), t2.toString());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled compare from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: compare\n\n        Method Code: public int compare(T t1, T t2) {\n        return compare(t1.toString(), t2.toString());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc compare<T: CustomStringConvertible>(_ t1: T, _ t2: T) -> Int {\n    return compare(t1.description, t2.description)\n}\n```"
    },
    {
        "method_name": "compare",
        "method_code": "public static int compare(String s1, String s2) {\n        int thisMarker = 0;\n        int thatMarker = 0;\n        int s1Length = s1.length();\n        int s2Length = s2.length();\n\n        while (thisMarker < s1Length && thatMarker < s2Length) {\n            String thisChunk = getChunk(s1, s1Length, thisMarker);\n            thisMarker += thisChunk.length();\n\n            String thatChunk = getChunk(s2, s2Length, thatMarker);\n            thatMarker += thatChunk.length();\n\n            // If both chunks contain numeric characters, sort them numerically\n            int result = 0;\n            if (isDigit(thisChunk.charAt(0)) && isDigit(thatChunk.charAt(0))) {\n                // extract digits\n                int thisChunkZeroCount = 0;\n                boolean zero = true;\n                int countThis = 0;\n                while (countThis < (thisChunk.length()) && isDigit(thisChunk.charAt(countThis))) {\n                    if (zero) {\n                        if (Character.getNumericValue(thisChunk.charAt(countThis)) == 0) {\n                            thisChunkZeroCount++;\n                        } else {\n                            zero = false;\n                        }\n                    }\n                    countThis++;\n                }\n\n\n                int thatChunkZeroCount = 0;\n                int countThat = 0;\n                zero = true;\n                while (countThat < (thatChunk.length()) && isDigit(thatChunk.charAt(countThat))) {\n                    if (zero) {\n                        if (Character.getNumericValue(thatChunk.charAt(countThat)) == 0) {\n                            thatChunkZeroCount++;\n                        } else {\n                            zero = false;\n                        }\n                    }\n                    countThat++;\n                }\n\n                BigInteger thisChunkValue = new BigInteger(thisChunk.substring(0, countThis));\n                BigInteger thatChunkValue = new BigInteger(thatChunk.substring(0, countThat));\n\n                result = thisChunkValue.compareTo(thatChunkValue);\n\n                if (result == 0) {\n                    // value is equal, compare leading zeros\n                    result = Integer.compare(thisChunkZeroCount, thatChunkZeroCount);\n\n                    if (result != 0) {\n                        return result;\n                    }\n                } else {\n                    return result;\n                }\n            } else if (isSpecialChar(thisChunk.charAt(0)) && isSpecialChar(thatChunk.charAt(0))) {\n                for (int i = 0; i < thisChunk.length(); i++) {\n                    if (thisChunk.charAt(i) == '.' && thatChunk.charAt(i) != '.') {\n                        return -1;\n                    } else if (thatChunk.charAt(i) == '.' && thisChunk.charAt(i) != '.') {\n                        return 1;\n                    } else {\n                        result = thisChunk.charAt(i) - thatChunk.charAt(i);\n                        if (result != 0) {\n                            return result;\n                        }\n                    }\n                }\n            } else if (isSpecialChar(thisChunk.charAt(0)) && !isSpecialChar(thatChunk.charAt(0))) {\n                return -1;\n            } else if (!isSpecialChar(thisChunk.charAt(0)) && isSpecialChar(thatChunk.charAt(0))) {\n                return 1;\n            } else {\n                result = Collator.getInstance().compare(thisChunk, thatChunk);\n            }\n\n            if (result != 0) {\n                return result;\n            }\n        }\n\n        return s1Length - s2Length;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled compare from AlphanumComparator.java into Swift.\n\n        Input:\n\n        Method Name: compare\n\n        Method Code: public static int compare(String s1, String s2) {\n        int thisMarker = 0;\n        int thatMarker = 0;\n        int s1Length = s1.length();\n        int s2Length = s2.length();\n\n        while (thisMarker < s1Length && thatMarker < s2Length) {\n            String thisChunk = getChunk(s1, s1Length, thisMarker);\n            thisMarker += thisChunk.length();\n\n            String thatChunk = getChunk(s2, s2Length, thatMarker);\n            thatMarker += thatChunk.length();\n\n            // If both chunks contain numeric characters, sort them numerically\n            int result = 0;\n            if (isDigit(thisChunk.charAt(0)) && isDigit(thatChunk.charAt(0))) {\n                // extract digits\n                int thisChunkZeroCount = 0;\n                boolean zero = true;\n                int countThis = 0;\n                while (countThis < (thisChunk.length()) && isDigit(thisChunk.charAt(countThis))) {\n                    if (zero) {\n                        if (Character.getNumericValue(thisChunk.charAt(countThis)) == 0) {\n                            thisChunkZeroCount++;\n                        } else {\n                            zero = false;\n                        }\n                    }\n                    countThis++;\n                }\n\n\n                int thatChunkZeroCount = 0;\n                int countThat = 0;\n                zero = true;\n                while (countThat < (thatChunk.length()) && isDigit(thatChunk.charAt(countThat))) {\n                    if (zero) {\n                        if (Character.getNumericValue(thatChunk.charAt(countThat)) == 0) {\n                            thatChunkZeroCount++;\n                        } else {\n                            zero = false;\n                        }\n                    }\n                    countThat++;\n                }\n\n                BigInteger thisChunkValue = new BigInteger(thisChunk.substring(0, countThis));\n                BigInteger thatChunkValue = new BigInteger(thatChunk.substring(0, countThat));\n\n                result = thisChunkValue.compareTo(thatChunkValue);\n\n                if (result == 0) {\n                    // value is equal, compare leading zeros\n                    result = Integer.compare(thisChunkZeroCount, thatChunkZeroCount);\n\n                    if (result != 0) {\n                        return result;\n                    }\n                } else {\n                    return result;\n                }\n            } else if (isSpecialChar(thisChunk.charAt(0)) && isSpecialChar(thatChunk.charAt(0))) {\n                for (int i = 0; i < thisChunk.length(); i++) {\n                    if (thisChunk.charAt(i) == '.' && thatChunk.charAt(i) != '.') {\n                        return -1;\n                    } else if (thatChunk.charAt(i) == '.' && thisChunk.charAt(i) != '.') {\n                        return 1;\n                    } else {\n                        result = thisChunk.charAt(i) - thatChunk.charAt(i);\n                        if (result != 0) {\n                            return result;\n                        }\n                    }\n                }\n            } else if (isSpecialChar(thisChunk.charAt(0)) && !isSpecialChar(thatChunk.charAt(0))) {\n                return -1;\n            } else if (!isSpecialChar(thisChunk.charAt(0)) && isSpecialChar(thatChunk.charAt(0))) {\n                return 1;\n            } else {\n                result = Collator.getInstance().compare(thisChunk, thatChunk);\n            }\n\n            if (result != 0) {\n                return result;\n            }\n        }\n\n        return s1Length - s2Length;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc compare(_ s1: String, _ s2: String) -> Int {\n    var thisMarker = 0\n    var thatMarker = 0\n    let s1Length = s1.count\n    let s2Length = s2.count\n\n    while thisMarker < s1Length && thatMarker < s2Length {\n        let thisChunk = getChunk(s1, s1Length, thisMarker)\n        thisMarker += thisChunk.count\n\n        let thatChunk = getChunk(s2, s2Length, thatMarker)\n        thatMarker += thatChunk.count\n\n        var result = 0\n        if isDigit(thisChunk.first!) && isDigit(thatChunk.first!) {\n            var thisChunkZeroCount = 0\n            var zero = true\n            var countThis = 0\n            while countThis < thisChunk.count && isDigit(thisChunk[thisChunk.index(thisChunk.startIndex, offsetBy: countThis)]) {\n                if zero {\n                    if thisChunk[thisChunk.index(thisChunk.startIndex, offsetBy: countThis)] == \"0\" {\n                        thisChunkZeroCount += 1\n                    } else {\n                        zero = false\n                    }\n                }\n                countThis += 1\n            }\n\n            var thatChunkZeroCount = 0\n            var countThat = 0\n            zero = true\n            while countThat < thatChunk.count && isDigit(thatChunk[thatChunk.index(thatChunk.startIndex, offsetBy: countThat)]) {\n                if zero {\n                    if thatChunk[thatChunk.index(thatChunk.startIndex, offsetBy: countThat)] == \"0\" {\n                        thatChunkZeroCount += 1\n                    } else {\n                        zero = false\n                    }\n                }\n                countThat += 1\n            }\n\n            let thisChunkValue = BigInt(thisChunk.prefix(countThis))!\n            let thatChunkValue = BigInt(thatChunk.prefix(countThat))!\n\n            result = thisChunkValue.compare(thatChunkValue)\n\n            if result == 0 {\n                result = thisChunkZeroCount - thatChunkZeroCount\n\n                if result != 0 {\n                    return result\n                }\n            } else {\n                return result\n            }\n        } else if isSpecialChar(thisChunk.first!) && isSpecialChar(thatChunk.first!) {\n            for i in 0..<thisChunk.count {\n                let thisChar = thisChunk[thisChunk.index(thisChunk.startIndex, offsetBy: i)]\n                let thatChar = thatChunk[thatChunk.index(thatChunk.startIndex, offsetBy: i)]\n                if thisChar == \".\" && thatChar != \".\" {\n                    return -1\n                } else if thatChar == \".\" && thisChar != \".\" {\n                    return 1\n                } else {\n                    result = thisChar.asciiValue! - thatChar.asciiValue!\n                    if result != 0 {\n                        return result\n                    }\n                }\n            }\n        } else if isSpecialChar(thisChunk.first!) && !isSpecialChar(thatChunk.first!) {\n            return -1\n        } else if !isSpecialChar(thisChunk.first!) && isSpecialChar(thatChunk.first!) {\n            return 1\n        } else {\n            result = thisChunk.compare(thatChunk, options: .caseInsensitive)\n        }\n\n        if result != 0 {\n            return result\n        }\n    }\n\n    return s1Length - s2Length\n}\n```"
    }
]