[
    {
        "method_name": "updateCertificateView",
        "method_code": "@Override\n    public void updateCertificateView(@NonNull SslUntrustedCertLayoutBinding binding) {\n        if (mCertificate != null) {\n            binding.nullCert.setVisibility(View.GONE);\n            showSubject(mCertificate.getSubjectX500Principal(), binding);\n            showIssuer(mCertificate.getIssuerX500Principal(), binding);\n            showValidity(mCertificate.getNotBefore(), mCertificate.getNotAfter(), binding);\n            showSignature(binding);\n\n        } else {\n            binding.nullCert.setVisibility(View.VISIBLE);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled updateCertificateView from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: updateCertificateView\n\n        Method Code: @Override\n    public void updateCertificateView(@NonNull SslUntrustedCertLayoutBinding binding) {\n        if (mCertificate != null) {\n            binding.nullCert.setVisibility(View.GONE);\n            showSubject(mCertificate.getSubjectX500Principal(), binding);\n            showIssuer(mCertificate.getIssuerX500Principal(), binding);\n            showValidity(mCertificate.getNotBefore(), mCertificate.getNotAfter(), binding);\n            showSignature(binding);\n\n        } else {\n            binding.nullCert.setVisibility(View.VISIBLE);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func updateCertificateView(binding: SslUntrustedCertLayoutBinding) {\n    if let certificate = mCertificate {\n        binding.nullCert.isHidden = true\n        showSubject(certificate.subjectX500Principal, binding: binding)\n        showIssuer(certificate.issuerX500Principal, binding: binding)\n        showValidity(certificate.notBefore, certificate.notAfter, binding: binding)\n        showSignature(binding: binding)\n    } else {\n        binding.nullCert.isHidden = false\n    }\n}\n```"
    },
    {
        "method_name": "getDigest",
        "method_code": "private byte[] getDigest(String algorithm, byte[] message) {\n        MessageDigest md;\n\n        try {\n            md = MessageDigest.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        md.reset();\n        return md.digest(message);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getDigest from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: getDigest\n\n        Method Code: private byte[] getDigest(String algorithm, byte[] message) {\n        MessageDigest md;\n\n        try {\n            md = MessageDigest.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n        md.reset();\n        return md.digest(message);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getDigest(algorithm: String, message: [UInt8]) -> [UInt8]? {\n    guard let md = try? MessageDigest(algorithm: algorithm) else {\n        return nil\n    }\n    md.reset()\n    return md.digest(message)\n}\n```"
    },
    {
        "method_name": "showSignature",
        "method_code": "private void showSignature(@NonNull SslUntrustedCertLayoutBinding binding) {\n        byte[] cert;\n\n        try {\n            cert = mCertificate.getEncoded();\n            if (cert == null) {\n                binding.valueCertificateFingerprint.setText(R.string.certificate_load_problem);\n                binding.valueSignatureAlgorithm.setText(R.string.certificate_load_problem);\n            } else {\n                binding.valueCertificateFingerprint.setText(getDigestString(binding.valueCertificateFingerprint.getContext(), cert));\n                binding.valueSignatureAlgorithm.setText(mCertificate.getSigAlgName());\n            }\n        } catch (CertificateEncodingException e) {\n            Log_OC.e(TAG, \"Problem while trying to decode the certificate.\");\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled showSignature from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: showSignature\n\n        Method Code: private void showSignature(@NonNull SslUntrustedCertLayoutBinding binding) {\n        byte[] cert;\n\n        try {\n            cert = mCertificate.getEncoded();\n            if (cert == null) {\n                binding.valueCertificateFingerprint.setText(R.string.certificate_load_problem);\n                binding.valueSignatureAlgorithm.setText(R.string.certificate_load_problem);\n            } else {\n                binding.valueCertificateFingerprint.setText(getDigestString(binding.valueCertificateFingerprint.getContext(), cert));\n                binding.valueSignatureAlgorithm.setText(mCertificate.getSigAlgName());\n            }\n        } catch (CertificateEncodingException e) {\n            Log_OC.e(TAG, \"Problem while trying to decode the certificate.\");\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func showSignature(binding: SslUntrustedCertLayoutBinding) {\n    var cert: [UInt8]?\n\n    do {\n        cert = try mCertificate.encoded()\n        if cert == nil {\n            binding.valueCertificateFingerprint.text = NSLocalizedString(\"certificate_load_problem\", comment: \"\")\n            binding.valueSignatureAlgorithm.text = NSLocalizedString(\"certificate_load_problem\", comment: \"\")\n        } else {\n            binding.valueCertificateFingerprint.text = getDigestString(context: binding.valueCertificateFingerprint.context, cert: cert!)\n            binding.valueSignatureAlgorithm.text = mCertificate.sigAlgName\n        }\n    } catch {\n        Log_OC.e(TAG, \"Problem while trying to decode the certificate.\")\n    }\n}\n```"
    },
    {
        "method_name": "getDigestString",
        "method_code": "@NonNull\n    private String getDigestString(Context context, byte[] cert) {\n        return getDigestHexBytesWithColonsAndNewLines(context, \"SHA-256\", cert)\n                + getDigestHexBytesWithColonsAndNewLines(context, \"SHA-1\", cert)\n                + getDigestHexBytesWithColonsAndNewLines(context, \"MD5\", cert);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getDigestString from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: getDigestString\n\n        Method Code: @NonNull\n    private String getDigestString(Context context, byte[] cert) {\n        return getDigestHexBytesWithColonsAndNewLines(context, \"SHA-256\", cert)\n                + getDigestHexBytesWithColonsAndNewLines(context, \"SHA-1\", cert)\n                + getDigestHexBytesWithColonsAndNewLines(context, \"MD5\", cert);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getDigestString(context: Context, cert: [UInt8]) -> String {\n    return getDigestHexBytesWithColonsAndNewLines(context: context, algorithm: \"SHA-256\", cert: cert) +\n           getDigestHexBytesWithColonsAndNewLines(context: context, algorithm: \"SHA-1\", cert: cert) +\n           getDigestHexBytesWithColonsAndNewLines(context: context, algorithm: \"MD5\", cert: cert)\n}\n```"
    },
    {
        "method_name": "getDigestHexBytesWithColonsAndNewLines",
        "method_code": "private String getDigestHexBytesWithColonsAndNewLines(Context context, final String digestType, final byte [] cert) {\n        final byte[] rawDigest;\n        final String newLine = System.lineSeparator();\n\n        rawDigest = getDigest(digestType, cert);\n\n        if ( rawDigest == null) {\n            return digestType + \":\" + newLine + context.getString(R.string.digest_algorithm_not_available) + newLine + newLine;\n        }\n\n        final StringBuilder hex = new StringBuilder(3 * rawDigest.length);\n\n        for (final byte b : rawDigest) {\n           final int hiVal = (b & 0xF0) >> 4;\n           final int loVal = b & 0x0F;\n           hex.append((char) ('0' + (hiVal + (hiVal / 10 * 7))));\n           hex.append((char) ('0' + (loVal + (loVal / 10 * 7))));\n           hex.append(':');\n        }\n        return digestType + \":\" + newLine + hex.toString().replaceFirst(\"\\\\:$\",\"\") + newLine + newLine;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getDigestHexBytesWithColonsAndNewLines from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: getDigestHexBytesWithColonsAndNewLines\n\n        Method Code: private String getDigestHexBytesWithColonsAndNewLines(Context context, final String digestType, final byte [] cert) {\n        final byte[] rawDigest;\n        final String newLine = System.lineSeparator();\n\n        rawDigest = getDigest(digestType, cert);\n\n        if ( rawDigest == null) {\n            return digestType + \":\" + newLine + context.getString(R.string.digest_algorithm_not_available) + newLine + newLine;\n        }\n\n        final StringBuilder hex = new StringBuilder(3 * rawDigest.length);\n\n        for (final byte b : rawDigest) {\n           final int hiVal = (b & 0xF0) >> 4;\n           final int loVal = b & 0x0F;\n           hex.append((char) ('0' + (hiVal + (hiVal / 10 * 7))));\n           hex.append((char) ('0' + (loVal + (loVal / 10 * 7))));\n           hex.append(':');\n        }\n        return digestType + \":\" + newLine + hex.toString().replaceFirst(\"\\\\:$\",\"\") + newLine + newLine;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getDigestHexBytesWithColonsAndNewLines(context: Context, digestType: String, cert: [UInt8]) -> String {\n    let newLine = \"\\n\"\n    guard let rawDigest = getDigest(digestType: digestType, cert: cert) else {\n        return \"\\(digestType):\\(newLine)\\(context.getString(R.string.digest_algorithm_not_available))\\(newLine)\\(newLine)\"\n    }\n    \n    var hex = \"\"\n    for b in rawDigest {\n        let hiVal = (b & 0xF0) >> 4\n        let loVal = b & 0x0F\n        hex.append(Character(UnicodeScalar(hiVal + (hiVal / 10 * 7) + 48)!))\n        hex.append(Character(UnicodeScalar(loVal + (loVal / 10 * 7) + 48)!))\n        hex.append(\":\")\n    }\n    return \"\\(digestType):\\(newLine)\\(hex.dropLast())\\(newLine)\\(newLine)\"\n}\n```"
    },
    {
        "method_name": "showValidity",
        "method_code": "private void showValidity(Date notBefore, Date notAfter, @NonNull SslUntrustedCertLayoutBinding binding) {\n        DateFormat dateFormat = DateFormat.getDateInstance();\n        binding.valueValidityFrom.setText(dateFormat.format(notBefore));\n        binding.valueValidityTo.setText(dateFormat.format(notAfter));\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled showValidity from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: showValidity\n\n        Method Code: private void showValidity(Date notBefore, Date notAfter, @NonNull SslUntrustedCertLayoutBinding binding) {\n        DateFormat dateFormat = DateFormat.getDateInstance();\n        binding.valueValidityFrom.setText(dateFormat.format(notBefore));\n        binding.valueValidityTo.setText(dateFormat.format(notAfter));\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func showValidity(notBefore: Date, notAfter: Date, binding: SslUntrustedCertLayoutBinding) {\n    let dateFormatter = DateFormatter()\n    dateFormatter.dateStyle = .medium\n    binding.valueValidityFrom.text = dateFormatter.string(from: notBefore)\n    binding.valueValidityTo.text = dateFormatter.string(from: notAfter)\n}\n```"
    },
    {
        "method_name": "showSubject",
        "method_code": "private void showSubject(X500Principal subject, @NonNull SslUntrustedCertLayoutBinding binding) {\n        Map<String, String> s = parsePrincipal(subject);\n\n        if (s.get(\"CN\") != null) {\n            binding.valueSubjectCN.setText(s.get(\"CN\"));\n            binding.valueSubjectCN.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectCN.setVisibility(View.GONE);\n        }\n        if (s.get(\"O\") != null) {\n            binding.valueSubjectO.setText(s.get(\"O\"));\n            binding.valueSubjectO.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectO.setVisibility(View.GONE);\n        }\n        if (s.get(\"OU\") != null) {\n            binding.valueSubjectOU.setText(s.get(\"OU\"));\n            binding.valueSubjectOU.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectOU.setVisibility(View.GONE);\n        }\n        if (s.get(\"C\") != null) {\n            binding.valueSubjectC.setText(s.get(\"C\"));\n            binding.valueSubjectC.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectC.setVisibility(View.GONE);\n        }\n        if (s.get(\"ST\") != null) {\n            binding.valueSubjectST.setText(s.get(\"ST\"));\n            binding.valueSubjectST.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectST.setVisibility(View.GONE);\n        }\n        if (s.get(\"L\") != null) {\n            binding.valueSubjectL.setText(s.get(\"L\"));\n            binding.valueSubjectL.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectL.setVisibility(View.GONE);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled showSubject from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: showSubject\n\n        Method Code: private void showSubject(X500Principal subject, @NonNull SslUntrustedCertLayoutBinding binding) {\n        Map<String, String> s = parsePrincipal(subject);\n\n        if (s.get(\"CN\") != null) {\n            binding.valueSubjectCN.setText(s.get(\"CN\"));\n            binding.valueSubjectCN.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectCN.setVisibility(View.GONE);\n        }\n        if (s.get(\"O\") != null) {\n            binding.valueSubjectO.setText(s.get(\"O\"));\n            binding.valueSubjectO.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectO.setVisibility(View.GONE);\n        }\n        if (s.get(\"OU\") != null) {\n            binding.valueSubjectOU.setText(s.get(\"OU\"));\n            binding.valueSubjectOU.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectOU.setVisibility(View.GONE);\n        }\n        if (s.get(\"C\") != null) {\n            binding.valueSubjectC.setText(s.get(\"C\"));\n            binding.valueSubjectC.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectC.setVisibility(View.GONE);\n        }\n        if (s.get(\"ST\") != null) {\n            binding.valueSubjectST.setText(s.get(\"ST\"));\n            binding.valueSubjectST.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectST.setVisibility(View.GONE);\n        }\n        if (s.get(\"L\") != null) {\n            binding.valueSubjectL.setText(s.get(\"L\"));\n            binding.valueSubjectL.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueSubjectL.setVisibility(View.GONE);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func showSubject(subject: X500Principal, binding: SslUntrustedCertLayoutBinding) {\n    let s = parsePrincipal(subject: subject)\n\n    if let cn = s[\"CN\"] {\n        binding.valueSubjectCN.text = cn\n        binding.valueSubjectCN.isHidden = false\n    } else {\n        binding.valueSubjectCN.isHidden = true\n    }\n    if let o = s[\"O\"] {\n        binding.valueSubjectO.text = o\n        binding.valueSubjectO.isHidden = false\n    } else {\n        binding.valueSubjectO.isHidden = true\n    }\n    if let ou = s[\"OU\"] {\n        binding.valueSubjectOU.text = ou\n        binding.valueSubjectOU.isHidden = false\n    } else {\n        binding.valueSubjectOU.isHidden = true\n    }\n    if let c = s[\"C\"] {\n        binding.valueSubjectC.text = c\n        binding.valueSubjectC.isHidden = false\n    } else {\n        binding.valueSubjectC.isHidden = true\n    }\n    if let st = s[\"ST\"] {\n        binding.valueSubjectST.text = st\n        binding.valueSubjectST.isHidden = false\n    } else {\n        binding.valueSubjectST.isHidden = true\n    }\n    if let l = s[\"L\"] {\n        binding.valueSubjectL.text = l\n        binding.valueSubjectL.isHidden = false\n    } else {\n        binding.valueSubjectL.isHidden = true\n    }\n}\n```"
    },
    {
        "method_name": "showIssuer",
        "method_code": "private void showIssuer(X500Principal issuer, @NonNull SslUntrustedCertLayoutBinding binding) {\n        Map<String, String> s = parsePrincipal(issuer);\n\n        if (s.get(\"CN\") != null) {\n            binding.valueIssuerCN.setText(s.get(\"CN\"));\n            binding.valueIssuerCN.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerCN.setVisibility(View.GONE);\n        }\n        if (s.get(\"O\") != null) {\n            binding.valueIssuerO.setText(s.get(\"O\"));\n            binding.valueIssuerO.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerO.setVisibility(View.GONE);\n        }\n        if (s.get(\"OU\") != null) {\n            binding.valueIssuerOU.setText(s.get(\"OU\"));\n            binding.valueIssuerOU.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerOU.setVisibility(View.GONE);\n        }\n        if (s.get(\"C\") != null) {\n            binding.valueIssuerC.setText(s.get(\"C\"));\n            binding.valueIssuerC.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerC.setVisibility(View.GONE);\n        }\n        if (s.get(\"ST\") != null) {\n            binding.valueIssuerST.setText(s.get(\"ST\"));\n            binding.valueIssuerST.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerST.setVisibility(View.GONE);\n        }\n        if (s.get(\"L\") != null) {\n            binding.valueIssuerL.setText(s.get(\"L\"));\n            binding.valueIssuerL.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerL.setVisibility(View.GONE);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled showIssuer from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: showIssuer\n\n        Method Code: private void showIssuer(X500Principal issuer, @NonNull SslUntrustedCertLayoutBinding binding) {\n        Map<String, String> s = parsePrincipal(issuer);\n\n        if (s.get(\"CN\") != null) {\n            binding.valueIssuerCN.setText(s.get(\"CN\"));\n            binding.valueIssuerCN.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerCN.setVisibility(View.GONE);\n        }\n        if (s.get(\"O\") != null) {\n            binding.valueIssuerO.setText(s.get(\"O\"));\n            binding.valueIssuerO.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerO.setVisibility(View.GONE);\n        }\n        if (s.get(\"OU\") != null) {\n            binding.valueIssuerOU.setText(s.get(\"OU\"));\n            binding.valueIssuerOU.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerOU.setVisibility(View.GONE);\n        }\n        if (s.get(\"C\") != null) {\n            binding.valueIssuerC.setText(s.get(\"C\"));\n            binding.valueIssuerC.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerC.setVisibility(View.GONE);\n        }\n        if (s.get(\"ST\") != null) {\n            binding.valueIssuerST.setText(s.get(\"ST\"));\n            binding.valueIssuerST.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerST.setVisibility(View.GONE);\n        }\n        if (s.get(\"L\") != null) {\n            binding.valueIssuerL.setText(s.get(\"L\"));\n            binding.valueIssuerL.setVisibility(View.VISIBLE);\n        } else {\n            binding.valueIssuerL.setVisibility(View.GONE);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func showIssuer(issuer: X500Principal, binding: SslUntrustedCertLayoutBinding) {\n    let s = parsePrincipal(issuer: issuer)\n\n    if let cn = s[\"CN\"] {\n        binding.valueIssuerCN.text = cn\n        binding.valueIssuerCN.isHidden = false\n    } else {\n        binding.valueIssuerCN.isHidden = true\n    }\n    if let o = s[\"O\"] {\n        binding.valueIssuerO.text = o\n        binding.valueIssuerO.isHidden = false\n    } else {\n        binding.valueIssuerO.isHidden = true\n    }\n    if let ou = s[\"OU\"] {\n        binding.valueIssuerOU.text = ou\n        binding.valueIssuerOU.isHidden = false\n    } else {\n        binding.valueIssuerOU.isHidden = true\n    }\n    if let c = s[\"C\"] {\n        binding.valueIssuerC.text = c\n        binding.valueIssuerC.isHidden = false\n    } else {\n        binding.valueIssuerC.isHidden = true\n    }\n    if let st = s[\"ST\"] {\n        binding.valueIssuerST.text = st\n        binding.valueIssuerST.isHidden = false\n    } else {\n        binding.valueIssuerST.isHidden = true\n    }\n    if let l = s[\"L\"] {\n        binding.valueIssuerL.text = l\n        binding.valueIssuerL.isHidden = false\n    } else {\n        binding.valueIssuerL.isHidden = true\n    }\n}\n```"
    },
    {
        "method_name": "parsePrincipal",
        "method_code": "private Map<String, String> parsePrincipal(Principal principal) {\n        Map<String, String> result = new HashMap<>();\n        String toParse = principal.getName();\n        String[] pieces = toParse.split(\",\");\n        String[] tokens = {\"CN\", \"O\", \"OU\", \"C\", \"ST\", \"L\"};\n        for (String piece : pieces) {\n            for (String token : tokens) {\n                if (piece.startsWith(token + \"=\")) {\n                    result.put(token, piece.substring(token.length() + 1));\n                }\n            }\n        }\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled parsePrincipal from X509CertificateViewAdapter.java into Swift.\n\n        Input:\n\n        Method Name: parsePrincipal\n\n        Method Code: private Map<String, String> parsePrincipal(Principal principal) {\n        Map<String, String> result = new HashMap<>();\n        String toParse = principal.getName();\n        String[] pieces = toParse.split(\",\");\n        String[] tokens = {\"CN\", \"O\", \"OU\", \"C\", \"ST\", \"L\"};\n        for (String piece : pieces) {\n            for (String token : tokens) {\n                if (piece.startsWith(token + \"=\")) {\n                    result.put(token, piece.substring(token.length() + 1));\n                }\n            }\n        }\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func parsePrincipal(principal: Principal) -> [String: String] {\n    var result = [String: String]()\n    let toParse = principal.getName()\n    let pieces = toParse.split(separator: \",\")\n    let tokens = [\"CN\", \"O\", \"OU\", \"C\", \"ST\", \"L\"]\n    for piece in pieces {\n        for token in tokens {\n            if piece.hasPrefix(\"\\(token)=\") {\n                let value = piece.dropFirst(token.count + 1)\n                result[token] = String(value)\n            }\n        }\n    }\n    return result\n}\n```"
    }
]