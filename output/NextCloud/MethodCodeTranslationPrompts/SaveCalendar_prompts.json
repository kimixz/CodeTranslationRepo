[
    {
        "method_name": "start",
        "method_code": "ublic void start() throws Exception {\n        mInsertedTimeZones.clear();\n        mFailedOrganisers.clear();\n        mAllCols = false;\n\n        String file = selectedCal.mDisplayName + \"_\" +\n            DateFormat.format(\"yyyy-MM-dd_HH-mm-ss\", java.util.Calendar.getInstance()).toString() +\n            \".ics\";\n\n        File fileName = new File(activity.getCacheDir(), file);\n\n        Log_OC.i(TAG, \"Save id \" + selectedCal.mIdStr + \" to file \" + fileName.getAbsolutePath());\n\n        String name = activity.getPackageName();\n        String ver;\n        try {\n            ver = activity.getPackageManager().getPackageInfo(name, 0).versionName;\n        } catch (NameNotFoundException e) {\n            ver = \"Unknown Build\";\n        }\n\n        String prodId = \"-//\" + selectedCal.mOwner + \"//iCal Import/Export \" + ver + \"//EN\";\n        Calendar cal = new Calendar();\n        cal.getProperties().add(new ProdId(prodId));\n        cal.getProperties().add(Version.VERSION_2_0);\n        cal.getProperties().add(Method.PUBLISH);\n        cal.getProperties().add(CalScale.GREGORIAN);\n\n        if (selectedCal.mTimezone != null) {\n            // We don't write any events with floating times, but export this\n            // anyway so the default timezone for new events is correct when\n            // the file is imported into a system that supports it.\n            cal.getProperties().add(new XProperty(\"X-WR-TIMEZONE\", selectedCal.mTimezone));\n        }\n\n        // query events\n        ContentResolver resolver = activity.getContentResolver();\n        int numberOfCreatedUids = 0;\n        if (Events.UID_2445 != null) {\n            numberOfCreatedUids = ensureUids(activity, resolver, selectedCal);\n        }\n        boolean relaxed = true; // settings.getIcal4jValidationRelaxed(); // TODO is this option needed? default true\n        CompatibilityHints.setHintEnabled(CompatibilityHints.KEY_RELAXED_VALIDATION, relaxed);\n        List<VEvent> events = getEvents(resolver, selectedCal, cal);\n\n        for (VEvent v : events) {\n            cal.getComponents().add(v);\n        }\n\n        if (!cal.getComponents().isEmpty()) {\n            new CalendarOutputter().output(cal, new FileOutputStream(fileName));\n\n            Resources res = activity.getResources();\n            String msg = res.getQuantityString(R.plurals.wrote_n_events_to, events.size(), events.size(), file);\n            if (numberOfCreatedUids > 0) {\n                msg += \"\\n\" + res.getQuantityString(R.plurals.created_n_uids_to, numberOfCreatedUids, numberOfCreatedUids);\n            }\n\n            // TODO replace DisplayUtils.showSnackMessage(activity, msg);\n\n            upload(fileName);\n        } else {\n            Log_OC.w(TAG, \"Calendar '\" + selectedCal.mIdStr + \"' has no components\");\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled start from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: start\n\n        Method Code: ublic void start() throws Exception {\n        mInsertedTimeZones.clear();\n        mFailedOrganisers.clear();\n        mAllCols = false;\n\n        String file = selectedCal.mDisplayName + \"_\" +\n            DateFormat.format(\"yyyy-MM-dd_HH-mm-ss\", java.util.Calendar.getInstance()).toString() +\n            \".ics\";\n\n        File fileName = new File(activity.getCacheDir(), file);\n\n        Log_OC.i(TAG, \"Save id \" + selectedCal.mIdStr + \" to file \" + fileName.getAbsolutePath());\n\n        String name = activity.getPackageName();\n        String ver;\n        try {\n            ver = activity.getPackageManager().getPackageInfo(name, 0).versionName;\n        } catch (NameNotFoundException e) {\n            ver = \"Unknown Build\";\n        }\n\n        String prodId = \"-//\" + selectedCal.mOwner + \"//iCal Import/Export \" + ver + \"//EN\";\n        Calendar cal = new Calendar();\n        cal.getProperties().add(new ProdId(prodId));\n        cal.getProperties().add(Version.VERSION_2_0);\n        cal.getProperties().add(Method.PUBLISH);\n        cal.getProperties().add(CalScale.GREGORIAN);\n\n        if (selectedCal.mTimezone != null) {\n            // We don't write any events with floating times, but export this\n            // anyway so the default timezone for new events is correct when\n            // the file is imported into a system that supports it.\n            cal.getProperties().add(new XProperty(\"X-WR-TIMEZONE\", selectedCal.mTimezone));\n        }\n\n        // query events\n        ContentResolver resolver = activity.getContentResolver();\n        int numberOfCreatedUids = 0;\n        if (Events.UID_2445 != null) {\n            numberOfCreatedUids = ensureUids(activity, resolver, selectedCal);\n        }\n        boolean relaxed = true; // settings.getIcal4jValidationRelaxed(); // TODO is this option needed? default true\n        CompatibilityHints.setHintEnabled(CompatibilityHints.KEY_RELAXED_VALIDATION, relaxed);\n        List<VEvent> events = getEvents(resolver, selectedCal, cal);\n\n        for (VEvent v : events) {\n            cal.getComponents().add(v);\n        }\n\n        if (!cal.getComponents().isEmpty()) {\n            new CalendarOutputter().output(cal, new FileOutputStream(fileName));\n\n            Resources res = activity.getResources();\n            String msg = res.getQuantityString(R.plurals.wrote_n_events_to, events.size(), events.size(), file);\n            if (numberOfCreatedUids > 0) {\n                msg += \"\\n\" + res.getQuantityString(R.plurals.created_n_uids_to, numberOfCreatedUids, numberOfCreatedUids);\n            }\n\n            // TODO replace DisplayUtils.showSnackMessage(activity, msg);\n\n            upload(fileName);\n        } else {\n            Log_OC.w(TAG, \"Calendar '\" + selectedCal.mIdStr + \"' has no components\");\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc start() throws {\n    mInsertedTimeZones.removeAll()\n    mFailedOrganisers.removeAll()\n    mAllCols = false\n\n    let file = \"\\(selectedCal.mDisplayName)_\\(DateFormatter.localizedString(from: Date(), dateStyle: .short, timeStyle: .short)).ics\"\n    let fileName = FileManager.default.temporaryDirectory.appendingPathComponent(file)\n\n    print(\"Save id \\(selectedCal.mIdStr) to file \\(fileName.path)\")\n\n    let name = Bundle.main.bundleIdentifier ?? \"Unknown\"\n    var ver: String\n    do {\n        let info = try Bundle.main.infoDictionary\n        ver = info?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown Build\"\n    } catch {\n        ver = \"Unknown Build\"\n    }\n\n    let prodId = \"-//\\(selectedCal.mOwner)//iCal Import/Export \\(ver)//EN\"\n    let cal = Calendar()\n    cal.properties.append(ProdId(prodId))\n    cal.properties.append(Version.VERSION_2_0)\n    cal.properties.append(Method.PUBLISH)\n    cal.properties.append(CalScale.GREGORIAN)\n\n    if let timezone = selectedCal.mTimezone {\n        cal.properties.append(XProperty(\"X-WR-TIMEZONE\", timezone))\n    }\n\n    let resolver = activity.contentResolver\n    var numberOfCreatedUids = 0\n    if Events.UID_2445 != nil {\n        numberOfCreatedUids = ensureUids(activity: activity, resolver: resolver, selectedCal: selectedCal)\n    }\n    let relaxed = true\n    CompatibilityHints.setHintEnabled(CompatibilityHints.KEY_RELAXED_VALIDATION, relaxed)\n    let events = getEvents(resolver: resolver, selectedCal: selectedCal, cal: cal)\n\n    for v in events {\n        cal.components.append(v)\n    }\n\n    if !cal.components.isEmpty {\n        try CalendarOutputter().output(cal, to: FileOutputStream(fileName))\n\n        let res = activity.resources\n        var msg = res.getQuantityString(R.plurals.wrote_n_events_to, events.count, events.count, file)\n        if numberOfCreatedUids > 0 {\n            msg += \"\\n\" + res.getQuantityString(R.plurals.created_n_uids_to, numberOfCreatedUids, numberOfCreatedUids)\n        }\n\n        // TODO replace DisplayUtils.showSnackMessage(activity, msg)\n\n        upload(fileName: fileName)\n    } else {\n        print(\"Calendar '\\(selectedCal.mIdStr)' has no components\")\n    }\n}\n```"
    },
    {
        "method_name": "ensureUids",
        "method_code": "rivate int ensureUids(Context activity, ContentResolver resolver, AndroidCalendar cal) {\n        String[] cols = new String[]{Events._ID};\n        String[] args = new String[]{cal.mIdStr};\n        Map<Long, String> newUids = new HashMap<>();\n        Cursor cur = resolver.query(Events.CONTENT_URI, cols,\n                                    Events.CALENDAR_ID + \" = ? AND \" + Events.UID_2445 + \" IS NULL\", args, null);\n        while (cur.moveToNext()) {\n            Long id = getLong(cur, Events._ID);\n            String uid = generateUid();\n            newUids.put(id, uid);\n        }\n        for (Long id : newUids.keySet()) {\n            String uid = newUids.get(id);\n            Uri updateUri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, id);\n            ContentValues c = new ContentValues();\n            c.put(Events.UID_2445, uid);\n            resolver.update(updateUri, c, null, null);\n            Log_OC.i(TAG, \"Generated UID \" + uid + \" for event \" + id);\n        }\n        return newUids.size();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled ensureUids from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: ensureUids\n\n        Method Code: rivate int ensureUids(Context activity, ContentResolver resolver, AndroidCalendar cal) {\n        String[] cols = new String[]{Events._ID};\n        String[] args = new String[]{cal.mIdStr};\n        Map<Long, String> newUids = new HashMap<>();\n        Cursor cur = resolver.query(Events.CONTENT_URI, cols,\n                                    Events.CALENDAR_ID + \" = ? AND \" + Events.UID_2445 + \" IS NULL\", args, null);\n        while (cur.moveToNext()) {\n            Long id = getLong(cur, Events._ID);\n            String uid = generateUid();\n            newUids.put(id, uid);\n        }\n        for (Long id : newUids.keySet()) {\n            String uid = newUids.get(id);\n            Uri updateUri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, id);\n            ContentValues c = new ContentValues();\n            c.put(Events.UID_2445, uid);\n            resolver.update(updateUri, c, null, null);\n            Log_OC.i(TAG, \"Generated UID \" + uid + \" for event \" + id);\n        }\n        return newUids.size();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func ensureUids(activity: Context, resolver: ContentResolver, cal: AndroidCalendar) -> Int {\n    let cols = [Events._ID]\n    let args = [cal.mIdStr]\n    var newUids = [Int64: String]()\n    let cur = resolver.query(Events.CONTENT_URI, cols, \"\\(Events.CALENDAR_ID) = ? AND \\(Events.UID_2445) IS NULL\", args, nil)\n    \n    while cur?.moveToNext() == true {\n        if let id = getLong(cur, columnName: Events._ID) {\n            let uid = generateUid()\n            newUids[id] = uid\n        }\n    }\n    \n    for (id, uid) in newUids {\n        let updateUri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, id)\n        var c = ContentValues()\n        c.put(Events.UID_2445, uid)\n        resolver.update(updateUri, c, nil, nil)\n        Log_OC.i(TAG, \"Generated UID \\(uid) for event \\(id)\")\n    }\n    \n    return newUids.count\n}\n```"
    },
    {
        "method_name": "getEvents",
        "method_code": "rivate List<VEvent> getEvents(ContentResolver resolver, AndroidCalendar cal_src, Calendar cal_dst) {\n        String where = Events.CALENDAR_ID + \"=?\";\n        String[] args = new String[]{cal_src.mIdStr};\n        String sortBy = Events.CALENDAR_ID + \" ASC\";\n        Cursor cur;\n        try {\n            cur = resolver.query(Events.CONTENT_URI, mAllCols ? null : EVENT_COLS,\n                                 where, args, sortBy);\n        } catch (Exception except) {\n            Log_OC.w(TAG, \"Calendar provider is missing columns, continuing anyway\");\n            int n = 0;\n            for (n = 0; n < EVENT_COLS.length; ++n) {\n                if (EVENT_COLS[n] == null) {\n                    Log_OC.e(TAG, \"Invalid EVENT_COLS index \" + Integer.toString(n));\n                }\n            }\n            cur = resolver.query(Events.CONTENT_URI, null, where, args, sortBy);\n        }\n\n        DtStamp timestamp = new DtStamp(); // Same timestamp for all events\n\n        // Collect up events and add them after any timezones\n        List<VEvent> events = new ArrayList<>();\n        while (cur.moveToNext()) {\n            VEvent e = convertFromDb(cur, cal_dst, timestamp);\n            if (e != null) {\n                events.add(e);\n                Log_OC.d(TAG, \"Adding event: \" + e.toString());\n            }\n        }\n        cur.close();\n        return events;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getEvents from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getEvents\n\n        Method Code: rivate List<VEvent> getEvents(ContentResolver resolver, AndroidCalendar cal_src, Calendar cal_dst) {\n        String where = Events.CALENDAR_ID + \"=?\";\n        String[] args = new String[]{cal_src.mIdStr};\n        String sortBy = Events.CALENDAR_ID + \" ASC\";\n        Cursor cur;\n        try {\n            cur = resolver.query(Events.CONTENT_URI, mAllCols ? null : EVENT_COLS,\n                                 where, args, sortBy);\n        } catch (Exception except) {\n            Log_OC.w(TAG, \"Calendar provider is missing columns, continuing anyway\");\n            int n = 0;\n            for (n = 0; n < EVENT_COLS.length; ++n) {\n                if (EVENT_COLS[n] == null) {\n                    Log_OC.e(TAG, \"Invalid EVENT_COLS index \" + Integer.toString(n));\n                }\n            }\n            cur = resolver.query(Events.CONTENT_URI, null, where, args, sortBy);\n        }\n\n        DtStamp timestamp = new DtStamp(); // Same timestamp for all events\n\n        // Collect up events and add them after any timezones\n        List<VEvent> events = new ArrayList<>();\n        while (cur.moveToNext()) {\n            VEvent e = convertFromDb(cur, cal_dst, timestamp);\n            if (e != null) {\n                events.add(e);\n                Log_OC.d(TAG, \"Adding event: \" + e.toString());\n            }\n        }\n        cur.close();\n        return events;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getEvents(resolver: ContentResolver, cal_src: AndroidCalendar, cal_dst: Calendar) -> [VEvent] {\n    let whereClause = \"\\(Events.CALENDAR_ID)=?\"\n    let args = [cal_src.mIdStr]\n    let sortBy = \"\\(Events.CALENDAR_ID) ASC\"\n    var cur: Cursor?\n    do {\n        cur = try resolver.query(Events.CONTENT_URI, mAllCols ? nil : EVENT_COLS, whereClause, args, sortBy)\n    } catch {\n        Log_OC.w(TAG, \"Calendar provider is missing columns, continuing anyway\")\n        for n in 0..<EVENT_COLS.count {\n            if EVENT_COLS[n] == nil {\n                Log_OC.e(TAG, \"Invalid EVENT_COLS index \\(n)\")\n            }\n        }\n        cur = try? resolver.query(Events.CONTENT_URI, nil, whereClause, args, sortBy)\n    }\n\n    let timestamp = DtStamp() // Same timestamp for all events\n\n    // Collect up events and add them after any timezones\n    var events = [VEvent]()\n    while cur?.moveToNext() == true {\n        if let e = convertFromDb(cur!, cal_dst: cal_dst, timestamp: timestamp) {\n            events.append(e)\n            Log_OC.d(TAG, \"Adding event: \\(e)\")\n        }\n    }\n    cur?.close()\n    return events\n}\n```"
    },
    {
        "method_name": "calculateFileName",
        "method_code": "rivate String calculateFileName(final String displayName) {\n        // Replace all non-alnum chars with '_'\n        String stripped = displayName.replaceAll(\"[^a-zA-Z0-9_-]\", \"_\");\n        // Replace repeated '_' with a single '_'\n        return stripped.replaceAll(\"(_)\\\\1{1,}\", \"$1\");\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled calculateFileName from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: calculateFileName\n\n        Method Code: rivate String calculateFileName(final String displayName) {\n        // Replace all non-alnum chars with '_'\n        String stripped = displayName.replaceAll(\"[^a-zA-Z0-9_-]\", \"_\");\n        // Replace repeated '_' with a single '_'\n        return stripped.replaceAll(\"(_)\\\\1{1,}\", \"$1\");\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func calculateFileName(_ displayName: String) -> String {\n    let stripped = displayName.replacingOccurrences(of: \"[^a-zA-Z0-9_-]\", with: \"_\", options: .regularExpression)\n    return stripped.replacingOccurrences(of: \"(_){2,}\", with: \"_\", options: .regularExpression)\n}\n```"
    },
    {
        "method_name": "getFileImpl",
        "method_code": "rivate void getFileImpl(final String previousFile, final String suggestedFile,\n                             final String[] result) {\n\n        final EditText input = new EditText(activity);\n        input.setHint(R.string.destination_filename);\n        input.setText(previousFile);\n        input.selectAll();\n\n        final int ok = android.R.string.ok;\n        final int cancel = android.R.string.cancel;\n        final int suggest = R.string.suggest;\n        AlertDialog dlg = new MaterialAlertDialogBuilder(activity).setIcon(R.mipmap.ic_launcher)\n            .setTitle(R.string.enter_destination_filename)\n            .setView(input)\n            .setPositiveButton(ok, (iface, id) -> result[0] = input.getText().toString())\n            .setNeutralButton(suggest, (iface, id) -> {\n            })\n            .setNegativeButton(cancel, (iface, id) -> result[0] = \"\")\n            .setOnCancelListener(iface -> result[0] = \"\")\n            .create();\n        int state = WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE;\n        dlg.getWindow().setSoftInputMode(state);\n        dlg.show();\n        // Overriding 'Suggest' here prevents it from closing the dialog\n        dlg.getButton(DialogInterface.BUTTON_NEUTRAL)\n            .setOnClickListener(onClick -> {\n                input.setText(suggestedFile);\n                input.setSelection(input.getText().length());\n            });\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getFileImpl from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getFileImpl\n\n        Method Code: rivate void getFileImpl(final String previousFile, final String suggestedFile,\n                             final String[] result) {\n\n        final EditText input = new EditText(activity);\n        input.setHint(R.string.destination_filename);\n        input.setText(previousFile);\n        input.selectAll();\n\n        final int ok = android.R.string.ok;\n        final int cancel = android.R.string.cancel;\n        final int suggest = R.string.suggest;\n        AlertDialog dlg = new MaterialAlertDialogBuilder(activity).setIcon(R.mipmap.ic_launcher)\n            .setTitle(R.string.enter_destination_filename)\n            .setView(input)\n            .setPositiveButton(ok, (iface, id) -> result[0] = input.getText().toString())\n            .setNeutralButton(suggest, (iface, id) -> {\n            })\n            .setNegativeButton(cancel, (iface, id) -> result[0] = \"\")\n            .setOnCancelListener(iface -> result[0] = \"\")\n            .create();\n        int state = WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE;\n        dlg.getWindow().setSoftInputMode(state);\n        dlg.show();\n        // Overriding 'Suggest' here prevents it from closing the dialog\n        dlg.getButton(DialogInterface.BUTTON_NEUTRAL)\n            .setOnClickListener(onClick -> {\n                input.setText(suggestedFile);\n                input.setSelection(input.getText().length());\n            });\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getFileImpl(previousFile: String, suggestedFile: String, result: inout [String]) {\n    let input = UITextField()\n    input.placeholder = NSLocalizedString(\"destination_filename\", comment: \"\")\n    input.text = previousFile\n    input.selectAll(nil)\n\n    let alert = UIAlertController(title: NSLocalizedString(\"enter_destination_filename\", comment: \"\"), message: nil, preferredStyle: .alert)\n    alert.addTextField { textField in\n        textField.text = previousFile\n    }\n\n    let okAction = UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"\"), style: .default) { _ in\n        if let text = alert.textFields?.first?.text {\n            result[0] = text\n        }\n    }\n\n    let suggestAction = UIAlertAction(title: NSLocalizedString(\"suggest\", comment: \"\"), style: .default) { _ in\n        if let textField = alert.textFields?.first {\n            textField.text = suggestedFile\n            textField.selectAll(nil)\n        }\n    }\n\n    let cancelAction = UIAlertAction(title: NSLocalizedString(\"Cancel\", comment: \"\"), style: .cancel) { _ in\n        result[0] = \"\"\n    }\n\n    alert.addAction(okAction)\n    alert.addAction(suggestAction)\n    alert.addAction(cancelAction)\n\n    if let viewController = UIApplication.shared.keyWindow?.rootViewController {\n        viewController.present(alert, animated: true) {\n            alert.textFields?.first?.becomeFirstResponder()\n        }\n    }\n}\n```"
    },
    {
        "method_name": "convertFromDb",
        "method_code": "rivate VEvent convertFromDb(Cursor cur, Calendar cal, DtStamp timestamp) {\n        Log_OC.d(TAG, \"cursor: \" + DatabaseUtils.dumpCurrentRowToString(cur));\n\n        if (hasStringValue(cur, Events.ORIGINAL_ID)) {\n            // FIXME: Support these edited instances\n            Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\");\n            return null;\n        }\n\n        PropertyList l = new PropertyList();\n        l.add(timestamp);\n        copyProperty(l, Property.UID, cur, Events.UID_2445);\n\n        String summary = copyProperty(l, Property.SUMMARY, cur, Events.TITLE);\n        String description = copyProperty(l, Property.DESCRIPTION, cur, Events.DESCRIPTION);\n\n        String organizer = getString(cur, Events.ORGANIZER);\n        if (!TextUtils.isEmpty(organizer)) {\n            // The check for mailto: here handles early versions of this code which\n            // incorrectly left it in the organizer column.\n            if (!organizer.startsWith(\"mailto:\")) {\n                organizer = \"mailto:\" + organizer;\n            }\n            try {\n                l.add(new Organizer(organizer));\n            } catch (URISyntaxException ignored) {\n                if (!mFailedOrganisers.contains(organizer)) {\n                    Log_OC.e(TAG, \"Failed to create mailTo for organizer \" + organizer);\n                    mFailedOrganisers.add(organizer);\n                }\n            }\n        }\n\n        copyProperty(l, Property.LOCATION, cur, Events.EVENT_LOCATION);\n        copyEnumProperty(l, Property.STATUS, cur, Events.STATUS, STATUS_ENUM);\n\n        boolean allDay = TextUtils.equals(getString(cur, Events.ALL_DAY), \"1\");\n        boolean isTransparent;\n        DtEnd dtEnd = null;\n\n        if (allDay) {\n            // All day event\n            isTransparent = true;\n            Date start = getDateTime(cur, Events.DTSTART, null, null);\n            Date end = getDateTime(cur, Events.DTEND, null, null);\n            l.add(new DtStart(new Date(start)));\n\n            if (end != null) {\n                dtEnd = new DtEnd(new Date(end));\n            } else {\n                dtEnd = new DtEnd(utcDateFromMs(start.getTime() + DateUtils.DAY_IN_MILLIS));\n            }\n\n            l.add(dtEnd);\n        } else {\n            // Regular or zero-time event. Start date must be a date-time\n            Date startDate = getDateTime(cur, Events.DTSTART, Events.EVENT_TIMEZONE, cal);\n            l.add(new DtStart(startDate));\n\n            // Use duration if we have one, otherwise end date\n            if (hasStringValue(cur, Events.DURATION)) {\n                isTransparent = getString(cur, Events.DURATION).equals(\"PT0S\");\n                if (!isTransparent) {\n                    copyProperty(l, Property.DURATION, cur, Events.DURATION);\n                }\n            } else {\n                String endTz = Events.EVENT_END_TIMEZONE;\n                if (endTz == null) {\n                    endTz = Events.EVENT_TIMEZONE;\n                }\n                Date end = getDateTime(cur, Events.DTEND, endTz, cal);\n                dtEnd = new DtEnd(end);\n                isTransparent = startDate.getTime() == end.getTime();\n                if (!isTransparent) {\n                    l.add(dtEnd);\n                }\n            }\n        }\n\n        copyEnumProperty(l, Property.CLASS, cur, Events.ACCESS_LEVEL, CLASS_ENUM);\n\n        int availability = getInt(cur, Events.AVAILABILITY);\n        if (availability > Events.AVAILABILITY_TENTATIVE) {\n            availability = -1;     // Unknown/Invalid\n        }\n\n        if (isTransparent) {\n            // This event is ordinarily transparent. If availability shows that its\n            // not free, then mark it opaque.\n            if (availability >= 0 && availability != Events.AVAILABILITY_FREE) {\n                l.add(Transp.OPAQUE);\n            }\n\n        } else if (availability > Events.AVAILABILITY_BUSY) {\n            // This event is ordinarily busy but differs, so output a FREEBUSY\n            // period covering the time of the event\n            FreeBusy fb = new FreeBusy();\n            fb.getParameters().add(new FbType(AVAIL_ENUM.get(availability)));\n            DateTime start = new DateTime(((DtStart) l.getProperty(Property.DTSTART)).getDate());\n\n            if (dtEnd != null) {\n                fb.getPeriods().add(new Period(start, new DateTime(dtEnd.getDate())));\n            } else {\n                Duration d = (Duration) l.getProperty(Property.DURATION);\n                fb.getPeriods().add(new Period(start, d.getDuration()));\n            }\n            l.add(fb);\n        }\n\n        copyProperty(l, Property.RRULE, cur, Events.RRULE);\n        copyProperty(l, Property.RDATE, cur, Events.RDATE);\n        copyProperty(l, Property.EXRULE, cur, Events.EXRULE);\n        copyProperty(l, Property.EXDATE, cur, Events.EXDATE);\n        if (TextUtils.isEmpty(getString(cur, Events.CUSTOM_APP_PACKAGE))) {\n            // Only copy URL if there is no app i.e. we probably imported it.\n            copyProperty(l, Property.URL, cur, Events.CUSTOM_APP_URI);\n        }\n\n        VEvent e = new VEvent(l);\n\n        if (getInt(cur, Events.HAS_ALARM) == 1) {\n            // Add alarms\n\n            String s = summary == null ? (description == null ? \"\" : description) : summary;\n            Description desc = new Description(s);\n\n            ContentResolver resolver = activity.getContentResolver();\n            long eventId = getLong(cur, Events._ID);\n            Cursor alarmCur;\n            alarmCur = Reminders.query(resolver, eventId, mAllCols ? null : REMINDER_COLS);\n            while (alarmCur.moveToNext()) {\n                int mins = getInt(alarmCur, Reminders.MINUTES);\n                if (mins == -1) {\n                    mins = 60;     // FIXME: Get the real default\n                }\n\n                // FIXME: We should support other types if possible\n                int method = getInt(alarmCur, Reminders.METHOD);\n                if (method == Reminders.METHOD_DEFAULT || method == Reminders.METHOD_ALERT) {\n                    VAlarm alarm = new VAlarm(new Dur(0, 0, -mins, 0));\n                    alarm.getProperties().add(Action.DISPLAY);\n                    alarm.getProperties().add(desc);\n                    e.getAlarms().add(alarm);\n                }\n            }\n            alarmCur.close();\n        }\n\n        return e;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertFromDb from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: convertFromDb\n\n        Method Code: rivate VEvent convertFromDb(Cursor cur, Calendar cal, DtStamp timestamp) {\n        Log_OC.d(TAG, \"cursor: \" + DatabaseUtils.dumpCurrentRowToString(cur));\n\n        if (hasStringValue(cur, Events.ORIGINAL_ID)) {\n            // FIXME: Support these edited instances\n            Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\");\n            return null;\n        }\n\n        PropertyList l = new PropertyList();\n        l.add(timestamp);\n        copyProperty(l, Property.UID, cur, Events.UID_2445);\n\n        String summary = copyProperty(l, Property.SUMMARY, cur, Events.TITLE);\n        String description = copyProperty(l, Property.DESCRIPTION, cur, Events.DESCRIPTION);\n\n        String organizer = getString(cur, Events.ORGANIZER);\n        if (!TextUtils.isEmpty(organizer)) {\n            // The check for mailto: here handles early versions of this code which\n            // incorrectly left it in the organizer column.\n            if (!organizer.startsWith(\"mailto:\")) {\n                organizer = \"mailto:\" + organizer;\n            }\n            try {\n                l.add(new Organizer(organizer));\n            } catch (URISyntaxException ignored) {\n                if (!mFailedOrganisers.contains(organizer)) {\n                    Log_OC.e(TAG, \"Failed to create mailTo for organizer \" + organizer);\n                    mFailedOrganisers.add(organizer);\n                }\n            }\n        }\n\n        copyProperty(l, Property.LOCATION, cur, Events.EVENT_LOCATION);\n        copyEnumProperty(l, Property.STATUS, cur, Events.STATUS, STATUS_ENUM);\n\n        boolean allDay = TextUtils.equals(getString(cur, Events.ALL_DAY), \"1\");\n        boolean isTransparent;\n        DtEnd dtEnd = null;\n\n        if (allDay) {\n            // All day event\n            isTransparent = true;\n            Date start = getDateTime(cur, Events.DTSTART, null, null);\n            Date end = getDateTime(cur, Events.DTEND, null, null);\n            l.add(new DtStart(new Date(start)));\n\n            if (end != null) {\n                dtEnd = new DtEnd(new Date(end));\n            } else {\n                dtEnd = new DtEnd(utcDateFromMs(start.getTime() + DateUtils.DAY_IN_MILLIS));\n            }\n\n            l.add(dtEnd);\n        } else {\n            // Regular or zero-time event. Start date must be a date-time\n            Date startDate = getDateTime(cur, Events.DTSTART, Events.EVENT_TIMEZONE, cal);\n            l.add(new DtStart(startDate));\n\n            // Use duration if we have one, otherwise end date\n            if (hasStringValue(cur, Events.DURATION)) {\n                isTransparent = getString(cur, Events.DURATION).equals(\"PT0S\");\n                if (!isTransparent) {\n                    copyProperty(l, Property.DURATION, cur, Events.DURATION);\n                }\n            } else {\n                String endTz = Events.EVENT_END_TIMEZONE;\n                if (endTz == null) {\n                    endTz = Events.EVENT_TIMEZONE;\n                }\n                Date end = getDateTime(cur, Events.DTEND, endTz, cal);\n                dtEnd = new DtEnd(end);\n                isTransparent = startDate.getTime() == end.getTime();\n                if (!isTransparent) {\n                    l.add(dtEnd);\n                }\n            }\n        }\n\n        copyEnumProperty(l, Property.CLASS, cur, Events.ACCESS_LEVEL, CLASS_ENUM);\n\n        int availability = getInt(cur, Events.AVAILABILITY);\n        if (availability > Events.AVAILABILITY_TENTATIVE) {\n            availability = -1;     // Unknown/Invalid\n        }\n\n        if (isTransparent) {\n            // This event is ordinarily transparent. If availability shows that its\n            // not free, then mark it opaque.\n            if (availability >= 0 && availability != Events.AVAILABILITY_FREE) {\n                l.add(Transp.OPAQUE);\n            }\n\n        } else if (availability > Events.AVAILABILITY_BUSY) {\n            // This event is ordinarily busy but differs, so output a FREEBUSY\n            // period covering the time of the event\n            FreeBusy fb = new FreeBusy();\n            fb.getParameters().add(new FbType(AVAIL_ENUM.get(availability)));\n            DateTime start = new DateTime(((DtStart) l.getProperty(Property.DTSTART)).getDate());\n\n            if (dtEnd != null) {\n                fb.getPeriods().add(new Period(start, new DateTime(dtEnd.getDate())));\n            } else {\n                Duration d = (Duration) l.getProperty(Property.DURATION);\n                fb.getPeriods().add(new Period(start, d.getDuration()));\n            }\n            l.add(fb);\n        }\n\n        copyProperty(l, Property.RRULE, cur, Events.RRULE);\n        copyProperty(l, Property.RDATE, cur, Events.RDATE);\n        copyProperty(l, Property.EXRULE, cur, Events.EXRULE);\n        copyProperty(l, Property.EXDATE, cur, Events.EXDATE);\n        if (TextUtils.isEmpty(getString(cur, Events.CUSTOM_APP_PACKAGE))) {\n            // Only copy URL if there is no app i.e. we probably imported it.\n            copyProperty(l, Property.URL, cur, Events.CUSTOM_APP_URI);\n        }\n\n        VEvent e = new VEvent(l);\n\n        if (getInt(cur, Events.HAS_ALARM) == 1) {\n            // Add alarms\n\n            String s = summary == null ? (description == null ? \"\" : description) : summary;\n            Description desc = new Description(s);\n\n            ContentResolver resolver = activity.getContentResolver();\n            long eventId = getLong(cur, Events._ID);\n            Cursor alarmCur;\n            alarmCur = Reminders.query(resolver, eventId, mAllCols ? null : REMINDER_COLS);\n            while (alarmCur.moveToNext()) {\n                int mins = getInt(alarmCur, Reminders.MINUTES);\n                if (mins == -1) {\n                    mins = 60;     // FIXME: Get the real default\n                }\n\n                // FIXME: We should support other types if possible\n                int method = getInt(alarmCur, Reminders.METHOD);\n                if (method == Reminders.METHOD_DEFAULT || method == Reminders.METHOD_ALERT) {\n                    VAlarm alarm = new VAlarm(new Dur(0, 0, -mins, 0));\n                    alarm.getProperties().add(Action.DISPLAY);\n                    alarm.getProperties().add(desc);\n                    e.getAlarms().add(alarm);\n                }\n            }\n            alarmCur.close();\n        }\n\n        return e;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func convertFromDb(cur: Cursor, cal: Calendar, timestamp: DtStamp) -> VEvent? {\n    Log_OC.d(TAG, \"cursor: \\(DatabaseUtils.dumpCurrentRowToString(cur))\")\n\n    if hasStringValue(cur, Events.ORIGINAL_ID) {\n        Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\")\n        return nil\n    }\n\n    var l = PropertyList()\n    l.add(timestamp)\n    copyProperty(l: &l, property: Property.UID, cur: cur, eventField: Events.UID_2445)\n\n    let summary = copyProperty(l: &l, property: Property.SUMMARY, cur: cur, eventField: Events.TITLE)\n    let description = copyProperty(l: &l, property: Property.DESCRIPTION, cur: cur, eventField: Events.DESCRIPTION)\n\n    var organizer = getString(cur: cur, eventField: Events.ORGANIZER)\n    if !TextUtils.isEmpty(organizer) {\n        if !organizer.starts(with: \"mailto:\") {\n            organizer = \"mailto:\" + organizer\n        }\n        do {\n            try l.add(Organizer(organizer))\n        } catch {\n            if !mFailedOrganisers.contains(organizer) {\n                Log_OC.e(TAG, \"Failed to create mailTo for organizer \\(organizer)\")\n                mFailedOrganisers.append(organizer)\n            }\n        }\n    }\n\n    copyProperty(l: &l, property: Property.LOCATION, cur: cur, eventField: Events.EVENT_LOCATION)\n    copyEnumProperty(l: &l, property: Property.STATUS, cur: cur, eventField: Events.STATUS, enumMap: STATUS_ENUM)\n\n    let allDay = TextUtils.equals(getString(cur: cur, eventField: Events.ALL_DAY), \"1\")\n    var isTransparent: Bool\n    var dtEnd: DtEnd? = nil\n\n    if allDay {\n        isTransparent = true\n        let start = getDateTime(cur: cur, eventField: Events.DTSTART, timeZone: nil, cal: nil)\n        let end = getDateTime(cur: cur, eventField: Events.DTEND, timeZone: nil, cal: nil)\n        l.add(DtStart(Date(start)))\n\n        if let end = end {\n            dtEnd = DtEnd(Date(end))\n        } else {\n            dtEnd = DtEnd(utcDateFromMs(ms: start.timeIntervalSince1970 + DateUtils.DAY_IN_MILLIS))\n        }\n\n        l.add(dtEnd!)\n    } else {\n        let startDate = getDateTime(cur: cur, eventField: Events.DTSTART, timeZone: Events.EVENT_TIMEZONE, cal: cal)\n        l.add(DtStart(startDate))\n\n        if hasStringValue(cur, Events.DURATION) {\n            isTransparent = getString(cur: cur, eventField: Events.DURATION) == \"PT0S\"\n            if !isTransparent {\n                copyProperty(l: &l, property: Property.DURATION, cur: cur, eventField: Events.DURATION)\n            }\n        } else {\n            var endTz = Events.EVENT_END_TIMEZONE\n            if endTz == nil {\n                endTz = Events.EVENT_TIMEZONE\n            }\n            let end = getDateTime(cur: cur, eventField: Events.DTEND, timeZone: endTz, cal: cal)\n            dtEnd = DtEnd(end)\n            isTransparent = startDate.timeIntervalSince1970 == end.timeIntervalSince1970\n            if !isTransparent {\n                l.add(dtEnd!)\n            }\n        }\n    }\n\n    copyEnumProperty(l: &l, property: Property.CLASS, cur: cur, eventField: Events.ACCESS_LEVEL, enumMap: CLASS_ENUM)\n\n    var availability = getInt(cur: cur, eventField: Events.AVAILABILITY)\n    if availability > Events.AVAILABILITY_TENTATIVE {\n        availability = -1\n    }\n\n    if isTransparent {\n        if availability >= 0 && availability != Events.AVAILABILITY_FREE {\n            l.add(Transp.OPAQUE)\n        }\n    } else if availability > Events.AVAILABILITY_BUSY {\n        let fb = FreeBusy()\n        fb.getParameters().add(FbType(AVAIL_ENUM[availability]))\n        let start = DateTime(((l.getProperty(Property.DTSTART) as! DtStart).date))\n\n        if let dtEnd = dtEnd {\n            fb.getPeriods().add(Period(start, DateTime(dtEnd.date)))\n        } else {\n            let d = l.getProperty(Property.DURATION) as! Duration\n            fb.getPeriods().add(Period(start, d.duration))\n        }\n        l.add(fb)\n    }\n\n    copyProperty(l: &l, property: Property.RRULE, cur: cur, eventField: Events.RRULE)\n    copyProperty(l: &l, property: Property.RDATE, cur: cur, eventField: Events.RDATE)\n    copyProperty(l: &l, property: Property.EXRULE, cur: cur, eventField: Events.EXRULE)\n    copyProperty(l: &l, property: Property.EXDATE, cur: cur, eventField: Events.EXDATE)\n    if TextUtils.isEmpty(getString(cur: cur, eventField: Events.CUSTOM_APP_PACKAGE)) {\n        copyProperty(l: &l, property: Property.URL, cur: cur, eventField: Events.CUSTOM_APP_URI)\n    }\n\n    let e = VEvent(l)\n\n    if getInt(cur: cur, eventField: Events.HAS_ALARM) == 1 {\n        let s = summary ?? (description ?? \"\")\n        let desc = Description(s)\n\n        let resolver = activity.contentResolver\n        let eventId = getLong(cur: cur, eventField: Events._ID)\n        let alarmCur = Reminders.query(resolver, eventId: eventId, projection: mAllCols ? nil : REMINDER_COLS)\n        while alarmCur.moveToNext() {\n            var mins = getInt(alarmCur, eventField: Reminders.MINUTES)\n            if mins == -1 {\n                mins = 60\n            }\n\n            let method = getInt(alarmCur, eventField: Reminders.METHOD)\n            if method == Reminders.METHOD_DEFAULT || method == Reminders.METHOD_ALERT {\n                let alarm = VAlarm(Dur(0, 0, -mins, 0))\n                alarm.getProperties().add(Action.DISPLAY)\n                alarm.getProperties().add(desc)\n                e.getAlarms().add(alarm)\n            }\n        }\n        alarmCur.close()\n    }\n\n    return e\n}\n```"
    },
    {
        "method_name": "getColumnIndex",
        "method_code": "rivate int getColumnIndex(Cursor cur, String dbName) {\n        return dbName == null ? -1 : cur.getColumnIndexOrThrow(dbName);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getColumnIndex from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getColumnIndex\n\n        Method Code: rivate int getColumnIndex(Cursor cur, String dbName) {\n        return dbName == null ? -1 : cur.getColumnIndexOrThrow(dbName);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getColumnIndex(cur: Cursor, dbName: String?) -> Int {\n    return dbName == nil ? -1 : cur.getColumnIndexOrThrow(dbName!)\n}\n```"
    },
    {
        "method_name": "getString",
        "method_code": "rivate String getString(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? null : cur.getString(i);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getString from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getString\n\n        Method Code: rivate String getString(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? null : cur.getString(i);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getString(cur: Cursor, dbName: String) -> String? {\n    let i = getColumnIndex(cur: cur, dbName: dbName)\n    return i == -1 ? nil : cur.getString(i)\n}\n```"
    },
    {
        "method_name": "getLong",
        "method_code": "rivate long getLong(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? -1 : cur.getLong(i);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getLong from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getLong\n\n        Method Code: rivate long getLong(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? -1 : cur.getLong(i);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getLong(cur: Cursor, dbName: String) -> Int64 {\n    let i = getColumnIndex(cur: cur, dbName: dbName)\n    return i == -1 ? -1 : cur.getLong(i)\n}\n```"
    },
    {
        "method_name": "getInt",
        "method_code": "rivate int getInt(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? -1 : cur.getInt(i);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getInt from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getInt\n\n        Method Code: rivate int getInt(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i == -1 ? -1 : cur.getInt(i);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getInt(cur: Cursor, dbName: String) -> Int {\n    let i = getColumnIndex(cur: cur, dbName: dbName)\n    return i == -1 ? -1 : cur.getInt(i)\n}\n```"
    },
    {
        "method_name": "hasStringValue",
        "method_code": "rivate boolean hasStringValue(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i != -1 && !TextUtils.isEmpty(cur.getString(i));\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled hasStringValue from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: hasStringValue\n\n        Method Code: rivate boolean hasStringValue(Cursor cur, String dbName) {\n        int i = getColumnIndex(cur, dbName);\n        return i != -1 && !TextUtils.isEmpty(cur.getString(i));\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func hasStringValue(cur: Cursor, dbName: String) -> Bool {\n    let i = getColumnIndex(cur: cur, dbName: dbName)\n    return i != -1 && !(cur.getString(i) ?? \"\").isEmpty\n}\n```"
    },
    {
        "method_name": "utcDateFromMs",
        "method_code": "rivate Date utcDateFromMs(long ms) {\n        // This date will be UTC provided the default false value of the iCal4j property\n        // \"net.fortuna.ical4j.timezone.date.floating\" has not been changed.\n        return new Date(ms);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled utcDateFromMs from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: utcDateFromMs\n\n        Method Code: rivate Date utcDateFromMs(long ms) {\n        // This date will be UTC provided the default false value of the iCal4j property\n        // \"net.fortuna.ical4j.timezone.date.floating\" has not been changed.\n        return new Date(ms);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func utcDateFromMs(_ ms: Int64) -> Date {\n    return Date(timeIntervalSince1970: TimeInterval(ms) / 1000)\n}\n```"
    },
    {
        "method_name": "isUtcTimeZone",
        "method_code": "rivate boolean isUtcTimeZone(final String tz) {\n        if (TextUtils.isEmpty(tz)) {\n            return true;\n        }\n        final String utz = tz.toUpperCase(Locale.US);\n        return \"UTC\".equals(utz) || \"UTC-0\".equals(utz) || \"UTC+0\".equals(utz) || utz.endsWith(\"/UTC\");\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled isUtcTimeZone from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: isUtcTimeZone\n\n        Method Code: rivate boolean isUtcTimeZone(final String tz) {\n        if (TextUtils.isEmpty(tz)) {\n            return true;\n        }\n        final String utz = tz.toUpperCase(Locale.US);\n        return \"UTC\".equals(utz) || \"UTC-0\".equals(utz) || \"UTC+0\".equals(utz) || utz.endsWith(\"/UTC\");\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func isUtcTimeZone(_ tz: String?) -> Bool {\n    guard let tz = tz, !tz.isEmpty else {\n        return true\n    }\n    let utz = tz.uppercased()\n    return utz == \"UTC\" || utz == \"UTC-0\" || utz == \"UTC+0\" || utz.hasSuffix(\"/UTC\")\n}\n```"
    },
    {
        "method_name": "getDateTime",
        "method_code": "rivate Date getDateTime(Cursor cur, String dbName, String dbTzName, Calendar cal) {\n        int i = getColumnIndex(cur, dbName);\n        if (i == -1 || cur.isNull(i)) {\n            Log_OC.e(TAG, \"No valid \" + dbName + \" column found, index: \" + Integer.toString(i));\n            return null;\n        }\n\n        if (cal == null) {\n            return utcDateFromMs(cur.getLong(i));     // Ignore timezone for date-only dates\n        } else if (dbTzName == null) {\n            Log_OC.e(TAG, \"No valid tz \" + dbName + \" column given\");\n        }\n\n        String tz = getString(cur, dbTzName);\n        final boolean isUtc = isUtcTimeZone(tz);\n\n        DateTime dt = new DateTime(isUtc);\n        if (dt.isUtc() != isUtc) {\n            throw new RuntimeException(\"UTC mismatch after construction\");\n        }\n        dt.setTime(cur.getLong(i));\n        if (dt.isUtc() != isUtc) {\n            throw new RuntimeException(\"UTC mismatch after setTime\");\n        }\n\n        if (!isUtc) {\n            if (mTzRegistry == null) {\n                mTzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();\n                if (mTzRegistry == null) {\n                    throw new RuntimeException(\"Failed to create TZ registry\");\n                }\n            }\n            TimeZone t = mTzRegistry.getTimeZone(tz);\n            if (t == null) {\n                Log_OC.e(TAG, \"Unknown TZ \" + tz + \", assuming UTC\");\n            } else {\n                dt.setTimeZone(t);\n                if (!mInsertedTimeZones.contains(t)) {\n                    cal.getComponents().add(t.getVTimeZone());\n                    mInsertedTimeZones.add(t);\n                }\n            }\n        }\n        return dt;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDateTime from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: getDateTime\n\n        Method Code: rivate Date getDateTime(Cursor cur, String dbName, String dbTzName, Calendar cal) {\n        int i = getColumnIndex(cur, dbName);\n        if (i == -1 || cur.isNull(i)) {\n            Log_OC.e(TAG, \"No valid \" + dbName + \" column found, index: \" + Integer.toString(i));\n            return null;\n        }\n\n        if (cal == null) {\n            return utcDateFromMs(cur.getLong(i));     // Ignore timezone for date-only dates\n        } else if (dbTzName == null) {\n            Log_OC.e(TAG, \"No valid tz \" + dbName + \" column given\");\n        }\n\n        String tz = getString(cur, dbTzName);\n        final boolean isUtc = isUtcTimeZone(tz);\n\n        DateTime dt = new DateTime(isUtc);\n        if (dt.isUtc() != isUtc) {\n            throw new RuntimeException(\"UTC mismatch after construction\");\n        }\n        dt.setTime(cur.getLong(i));\n        if (dt.isUtc() != isUtc) {\n            throw new RuntimeException(\"UTC mismatch after setTime\");\n        }\n\n        if (!isUtc) {\n            if (mTzRegistry == null) {\n                mTzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();\n                if (mTzRegistry == null) {\n                    throw new RuntimeException(\"Failed to create TZ registry\");\n                }\n            }\n            TimeZone t = mTzRegistry.getTimeZone(tz);\n            if (t == null) {\n                Log_OC.e(TAG, \"Unknown TZ \" + tz + \", assuming UTC\");\n            } else {\n                dt.setTimeZone(t);\n                if (!mInsertedTimeZones.contains(t)) {\n                    cal.getComponents().add(t.getVTimeZone());\n                    mInsertedTimeZones.add(t);\n                }\n            }\n        }\n        return dt;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getDateTime(cur: Cursor, dbName: String, dbTzName: String?, cal: Calendar?) -> Date? {\n    let i = getColumnIndex(cur: cur, dbName: dbName)\n    if i == -1 || cur.isNull(index: i) {\n        Log_OC.e(TAG, \"No valid \\(dbName) column found, index: \\(i)\")\n        return nil\n    }\n\n    if cal == nil {\n        return utcDateFromMs(milliseconds: cur.getLong(index: i))\n    } else if dbTzName == nil {\n        Log_OC.e(TAG, \"No valid tz \\(dbName) column given\")\n    }\n\n    let tz = getString(cur: cur, dbTzName: dbTzName!)\n    let isUtc = isUtcTimeZone(tz: tz)\n\n    var dt = DateTime(isUtc: isUtc)\n    if dt.isUtc() != isUtc {\n        fatalError(\"UTC mismatch after construction\")\n    }\n    dt.setTime(milliseconds: cur.getLong(index: i))\n    if dt.isUtc() != isUtc {\n        fatalError(\"UTC mismatch after setTime\")\n    }\n\n    if !isUtc {\n        if mTzRegistry == nil {\n            mTzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry()\n            if mTzRegistry == nil {\n                fatalError(\"Failed to create TZ registry\")\n            }\n        }\n        if let t = mTzRegistry?.getTimeZone(tz: tz) {\n            dt.setTimeZone(t: t)\n            if !mInsertedTimeZones.contains(t) {\n                cal?.getComponents().add(t.getVTimeZone())\n                mInsertedTimeZones.insert(t)\n            }\n        } else {\n            Log_OC.e(TAG, \"Unknown TZ \\(tz), assuming UTC\")\n        }\n    }\n    return dt\n}\n```"
    },
    {
        "method_name": "copyProperty",
        "method_code": "rivate String copyProperty(PropertyList l, String evName, Cursor cur, String dbName) {\n        // None of the exceptions caught below should be able to be thrown AFAICS.\n        try {\n            String value = getString(cur, dbName);\n            if (value != null) {\n                Property p = mPropertyFactory.createProperty(evName);\n                p.setValue(value);\n                l.add(p);\n                return value;\n            }\n        } catch (IOException | URISyntaxException | ParseException ignored) {\n        }\n        return null;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyProperty from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: copyProperty\n\n        Method Code: rivate String copyProperty(PropertyList l, String evName, Cursor cur, String dbName) {\n        // None of the exceptions caught below should be able to be thrown AFAICS.\n        try {\n            String value = getString(cur, dbName);\n            if (value != null) {\n                Property p = mPropertyFactory.createProperty(evName);\n                p.setValue(value);\n                l.add(p);\n                return value;\n            }\n        } catch (IOException | URISyntaxException | ParseException ignored) {\n        }\n        return null;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func copyProperty(_ list: PropertyList, eventName: String, cursor: Cursor, dbName: String) -> String? {\n    do {\n        if let value = getString(cursor, dbName) {\n            let property = mPropertyFactory.createProperty(eventName)\n            property.setValue(value)\n            list.add(property)\n            return value\n        }\n    } catch {\n        // Ignored exceptions: IOException, URISyntaxException, ParseException\n    }\n    return nil\n}\n```"
    },
    {
        "method_name": "copyEnumProperty",
        "method_code": "rivate void copyEnumProperty(PropertyList l, String evName, Cursor cur, String dbName,\n                                  List<String> vals) {\n        // None of the exceptions caught below should be able to be thrown AFAICS.\n        try {\n            int i = getColumnIndex(cur, dbName);\n            if (i != -1 && !cur.isNull(i)) {\n                int value = (int) cur.getLong(i);\n                if (value >= 0 && value < vals.size() && vals.get(value) != null) {\n                    Property p = mPropertyFactory.createProperty(evName);\n                    p.setValue(vals.get(value));\n                    l.add(p);\n                }\n            }\n        } catch (IOException | URISyntaxException | ParseException ignored) {\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyEnumProperty from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: copyEnumProperty\n\n        Method Code: rivate void copyEnumProperty(PropertyList l, String evName, Cursor cur, String dbName,\n                                  List<String> vals) {\n        // None of the exceptions caught below should be able to be thrown AFAICS.\n        try {\n            int i = getColumnIndex(cur, dbName);\n            if (i != -1 && !cur.isNull(i)) {\n                int value = (int) cur.getLong(i);\n                if (value >= 0 && value < vals.size() && vals.get(value) != null) {\n                    Property p = mPropertyFactory.createProperty(evName);\n                    p.setValue(vals.get(value));\n                    l.add(p);\n                }\n            }\n        } catch (IOException | URISyntaxException | ParseException ignored) {\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func copyEnumProperty(_ l: inout PropertyList, evName: String, cur: Cursor, dbName: String, vals: [String]) {\n    do {\n        let i = getColumnIndex(cur: cur, dbName: dbName)\n        if i != -1 && !cur.isNull(at: i) {\n            let value = Int(cur.getLong(at: i))\n            if value >= 0 && value < vals.count && vals[value] != nil {\n                let p = mPropertyFactory.createProperty(evName)\n                p.setValue(vals[value])\n                l.add(p)\n            }\n        }\n    } catch {\n        // Ignored exceptions\n    }\n}\n```"
    },
    {
        "method_name": "generateUid",
        "method_code": "rivate String generateUid() {\n        // Generated UIDs take the form <ms>-<uuid>@nextcloud.com.\n        if (mUidTail == null) {\n            String uidPid = preferences.getUidPid();\n            if (uidPid.length() == 0) {\n                uidPid = UUID.randomUUID().toString().replace(\"-\", \"\");\n                preferences.setUidPid(uidPid);\n            }\n            mUidTail = uidPid + \"@nextcloud.com\";\n        }\n\n        mUidMs = Math.max(mUidMs, System.currentTimeMillis());\n        String uid = mUidMs + mUidTail;\n        mUidMs++;\n\n        return uid;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled generateUid from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: generateUid\n\n        Method Code: rivate String generateUid() {\n        // Generated UIDs take the form <ms>-<uuid>@nextcloud.com.\n        if (mUidTail == null) {\n            String uidPid = preferences.getUidPid();\n            if (uidPid.length() == 0) {\n                uidPid = UUID.randomUUID().toString().replace(\"-\", \"\");\n                preferences.setUidPid(uidPid);\n            }\n            mUidTail = uidPid + \"@nextcloud.com\";\n        }\n\n        mUidMs = Math.max(mUidMs, System.currentTimeMillis());\n        String uid = mUidMs + mUidTail;\n        mUidMs++;\n\n        return uid;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func generateUid() -> String {\n    if mUidTail == nil {\n        var uidPid = preferences.getUidPid()\n        if uidPid.isEmpty {\n            uidPid = UUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")\n            preferences.setUidPid(uidPid)\n        }\n        mUidTail = uidPid + \"@nextcloud.com\"\n    }\n\n    mUidMs = max(mUidMs, Date().timeIntervalSince1970 * 1000)\n    let uid = \"\\(Int(mUidMs))\\(mUidTail!)\"\n    mUidMs += 1\n\n    return uid\n}\n```"
    },
    {
        "method_name": "upload",
        "method_code": "rivate void upload(File file) {\n        String backupFolder = activity.getResources().getString(R.string.calendar_backup_folder)\n            + OCFile.PATH_SEPARATOR;\n\n        Request request = new UploadRequest.Builder(user, file.getAbsolutePath(), backupFolder + file.getName())\n            .setFileSize(file.length())\n            .setNameConflicPolicy(NameCollisionPolicy.RENAME)\n            .setCreateRemoteFolder(true)\n            .setTrigger(UploadTrigger.USER)\n            .setPostAction(PostUploadAction.MOVE_TO_APP)\n            .setRequireWifi(false)\n            .setRequireCharging(false)\n            .build();\n\n        TransferManagerConnection connection = new TransferManagerConnection(activity, user);\n        connection.enqueue(request);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled upload from SaveCalendar.java into Swift.\n\n        Input:\n\n        Method Name: upload\n\n        Method Code: rivate void upload(File file) {\n        String backupFolder = activity.getResources().getString(R.string.calendar_backup_folder)\n            + OCFile.PATH_SEPARATOR;\n\n        Request request = new UploadRequest.Builder(user, file.getAbsolutePath(), backupFolder + file.getName())\n            .setFileSize(file.length())\n            .setNameConflicPolicy(NameCollisionPolicy.RENAME)\n            .setCreateRemoteFolder(true)\n            .setTrigger(UploadTrigger.USER)\n            .setPostAction(PostUploadAction.MOVE_TO_APP)\n            .setRequireWifi(false)\n            .setRequireCharging(false)\n            .build();\n\n        TransferManagerConnection connection = new TransferManagerConnection(activity, user);\n        connection.enqueue(request);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func upload(file: File) {\n    let backupFolder = activity.resources.getString(R.string.calendar_backup_folder) + OCFile.PATH_SEPARATOR\n\n    let request = UploadRequest.Builder(user: user, filePath: file.absolutePath, destinationPath: backupFolder + file.name)\n        .setFileSize(file.length())\n        .setNameConflictPolicy(.rename)\n        .setCreateRemoteFolder(true)\n        .setTrigger(.user)\n        .setPostAction(.moveToApp)\n        .setRequireWifi(false)\n        .setRequireCharging(false)\n        .build()\n\n    let connection = TransferManagerConnection(activity: activity, user: user)\n    connection.enqueue(request)\n}\n```"
    }
]