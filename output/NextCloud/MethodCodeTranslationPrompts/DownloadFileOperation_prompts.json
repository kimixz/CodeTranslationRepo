[
    {
        "method_name": "isMatching",
        "method_code": "ublic boolean isMatching(String accountName, long fileId) {\n        return getFile().getFileId() == fileId && getUser().getAccountName().equals(accountName);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled isMatching from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: isMatching\n\n        Method Code: ublic boolean isMatching(String accountName, long fileId) {\n        return getFile().getFileId() == fileId && getUser().getAccountName().equals(accountName);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isMatching(accountName: String, fileId: Int64) -> Bool {\n    return getFile().getFileId() == fileId && getUser().getAccountName() == accountName\n}\n```"
    },
    {
        "method_name": "cancelMatchingOperation",
        "method_code": "ublic void cancelMatchingOperation(String accountName, long fileId) {\n        if (isMatching(accountName, fileId)) {\n            cancel();\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled cancelMatchingOperation from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: cancelMatchingOperation\n\n        Method Code: ublic void cancelMatchingOperation(String accountName, long fileId) {\n        if (isMatching(accountName, fileId)) {\n            cancel();\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc cancelMatchingOperation(accountName: String, fileId: Int64) {\n    if isMatching(accountName: accountName, fileId: fileId) {\n        cancel()\n    }\n}\n```"
    },
    {
        "method_name": "getSavePath",
        "method_code": "ublic String getSavePath() {\n        if (file.getStoragePath() != null) {\n            File parentFile = new File(file.getStoragePath()).getParentFile();\n            if (parentFile != null && !parentFile.exists()) {\n                parentFile.mkdirs();\n            }\n            File path = new File(file.getStoragePath());  // re-downloads should be done over the original file\n            if (path.canWrite() || parentFile != null && parentFile.canWrite()) {\n                return path.getAbsolutePath();\n            }\n        }\n        return FileStorageUtils.getDefaultSavePathFor(user.getAccountName(), file);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getSavePath from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getSavePath\n\n        Method Code: ublic String getSavePath() {\n        if (file.getStoragePath() != null) {\n            File parentFile = new File(file.getStoragePath()).getParentFile();\n            if (parentFile != null && !parentFile.exists()) {\n                parentFile.mkdirs();\n            }\n            File path = new File(file.getStoragePath());  // re-downloads should be done over the original file\n            if (path.canWrite() || parentFile != null && parentFile.canWrite()) {\n                return path.getAbsolutePath();\n            }\n        }\n        return FileStorageUtils.getDefaultSavePathFor(user.getAccountName(), file);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSavePath() -> String {\n    if let storagePath = file.getStoragePath() {\n        let parentFile = URL(fileURLWithPath: storagePath).deletingLastPathComponent()\n        if !FileManager.default.fileExists(atPath: parentFile.path) {\n            try? FileManager.default.createDirectory(at: parentFile, withIntermediateDirectories: true, attributes: nil)\n        }\n        let path = URL(fileURLWithPath: storagePath)\n        if FileManager.default.isWritableFile(atPath: path.path) || FileManager.default.isWritableFile(atPath: parentFile.path) {\n            return path.path\n        }\n    }\n    return FileStorageUtils.getDefaultSavePathFor(user.getAccountName(), file)\n}\n```"
    },
    {
        "method_name": "getTmpPath",
        "method_code": "ublic String getTmpPath() {\n        return FileStorageUtils.getTemporalPath(user.getAccountName()) + file.getRemotePath();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getTmpPath from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getTmpPath\n\n        Method Code: ublic String getTmpPath() {\n        return FileStorageUtils.getTemporalPath(user.getAccountName()) + file.getRemotePath();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getTmpPath() -> String {\n    return FileStorageUtils.getTemporalPath(user.accountName) + file.remotePath\n}\n```"
    },
    {
        "method_name": "getTmpFolder",
        "method_code": "ublic String getTmpFolder() {\n        return FileStorageUtils.getTemporalPath(user.getAccountName());\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getTmpFolder from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getTmpFolder\n\n        Method Code: ublic String getTmpFolder() {\n        return FileStorageUtils.getTemporalPath(user.getAccountName());\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getTmpFolder() -> String {\n    return FileStorageUtils.getTemporalPath(user.accountName)\n}\n```"
    },
    {
        "method_name": "getRemotePath",
        "method_code": "ublic String getRemotePath() {\n        return file.getRemotePath();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getRemotePath from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getRemotePath\n\n        Method Code: ublic String getRemotePath() {\n        return file.getRemotePath();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getRemotePath() -> String {\n    return file.getRemotePath()\n}\n```"
    },
    {
        "method_name": "getMimeType",
        "method_code": "ublic String getMimeType() {\n        String mimeType = file.getMimeType();\n        if (TextUtils.isEmpty(mimeType)) {\n            try {\n                mimeType = MimeTypeMap.getSingleton()\n                    .getMimeTypeFromExtension(\n                        file.getRemotePath().substring(\n                            file.getRemotePath().lastIndexOf('.') + 1));\n            } catch (IndexOutOfBoundsException e) {\n                Log_OC.e(TAG, \"Trying to find out MIME type of a file without extension: \" +\n                    file.getRemotePath());\n            }\n        }\n        if (mimeType == null) {\n            mimeType = \"application/octet-stream\";\n        }\n        return mimeType;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getMimeType from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getMimeType\n\n        Method Code: ublic String getMimeType() {\n        String mimeType = file.getMimeType();\n        if (TextUtils.isEmpty(mimeType)) {\n            try {\n                mimeType = MimeTypeMap.getSingleton()\n                    .getMimeTypeFromExtension(\n                        file.getRemotePath().substring(\n                            file.getRemotePath().lastIndexOf('.') + 1));\n            } catch (IndexOutOfBoundsException e) {\n                Log_OC.e(TAG, \"Trying to find out MIME type of a file without extension: \" +\n                    file.getRemotePath());\n            }\n        }\n        if (mimeType == null) {\n            mimeType = \"application/octet-stream\";\n        }\n        return mimeType;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getMimeType() -> String {\n    var mimeType = file.getMimeType()\n    if mimeType.isEmpty {\n        do {\n            let fileExtension = file.getRemotePath().components(separatedBy: \".\").last ?? \"\"\n            mimeType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, fileExtension as CFString, nil)?.takeRetainedValue() as String? ?? \"\"\n        } catch {\n            print(\"Trying to find out MIME type of a file without extension: \\(file.getRemotePath())\")\n        }\n    }\n    if mimeType.isEmpty {\n        mimeType = \"application/octet-stream\"\n    }\n    return mimeType\n}\n```"
    },
    {
        "method_name": "getSize",
        "method_code": "ublic long getSize() {\n        return file.getFileLength();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getSize from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getSize\n\n        Method Code: ublic long getSize() {\n        return file.getFileLength();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSize() -> Int64 {\n    return file.getFileLength()\n}\n```"
    },
    {
        "method_name": "getModificationTimestamp",
        "method_code": "ublic long getModificationTimestamp() {\n        return modificationTimestamp > 0 ? modificationTimestamp : file.getModificationTimestamp();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getModificationTimestamp from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getModificationTimestamp\n\n        Method Code: ublic long getModificationTimestamp() {\n        return modificationTimestamp > 0 ? modificationTimestamp : file.getModificationTimestamp();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getModificationTimestamp() -> Int64 {\n    return modificationTimestamp > 0 ? modificationTimestamp : file.getModificationTimestamp()\n}\n```"
    },
    {
        "method_name": "run",
        "method_code": "Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        /// perform the download\n        synchronized(cancellationRequested) {\n            if (cancellationRequested.get()) {\n                return new RemoteOperationResult(new OperationCancelledException());\n            }\n        }\n\n        Context operationContext = context.get();\n        if (operationContext == null) {\n            return new RemoteOperationResult(RemoteOperationResult.ResultCode.UNKNOWN_ERROR);\n        }\n\n        RemoteOperationResult result;\n        File newFile = null;\n        boolean moved;\n\n        /// download will be performed to a temporal file, then moved to the final location\n        File tmpFile = new File(getTmpPath());\n\n        String tmpFolder = getTmpFolder();\n\n        downloadOperation = new DownloadFileRemoteOperation(file.getRemotePath(), tmpFolder);\n\n        if (downloadType == DownloadType.DOWNLOAD) {\n            Iterator<OnDatatransferProgressListener> listener = dataTransferListeners.iterator();\n            while (listener.hasNext()) {\n                downloadOperation.addDatatransferProgressListener(listener.next());\n            }\n        }\n\n        result = downloadOperation.execute(client);\n\n\n\n        if (result.isSuccess()) {\n            modificationTimestamp = downloadOperation.getModificationTimestamp();\n            etag = downloadOperation.getEtag();\n\n            if (downloadType == DownloadType.DOWNLOAD) {\n                newFile = new File(getSavePath());\n\n                if (!newFile.getParentFile().exists() && !newFile.getParentFile().mkdirs()) {\n                    Log_OC.e(TAG, \"Unable to create parent folder \" + newFile.getParentFile().getAbsolutePath());\n                }\n            }\n\n            // decrypt file\n            if (file.isEncrypted()) {\n                FileDataStorageManager fileDataStorageManager = new FileDataStorageManager(user, operationContext.getContentResolver());\n\n                OCFile parent = fileDataStorageManager.getFileByEncryptedRemotePath(file.getParentRemotePath());\n\n                Object object = EncryptionUtils.downloadFolderMetadata(parent,\n                                                                       client,\n                                                                       operationContext,\n                                                                       user);\n\n                if (object == null) {\n                    return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                }\n\n                String keyString;\n                String nonceString;\n                String authenticationTagString;\n                if (object instanceof DecryptedFolderMetadataFile) {\n                    DecryptedFile decryptedFile = ((DecryptedFolderMetadataFile) object)\n                        .getMetadata()\n                        .getFiles()\n                        .get(file.getEncryptedFileName());\n\n                    if (decryptedFile == null) {\n                        return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                    }\n\n                    keyString = decryptedFile.getKey();\n                    nonceString = decryptedFile.getNonce();\n                    authenticationTagString = decryptedFile.getAuthenticationTag();\n                } else {\n                    com.owncloud.android.datamodel.e2e.v1.decrypted.DecryptedFile decryptedFile =\n                        ((DecryptedFolderMetadataFileV1) object)\n                            .getFiles()\n                            .get(file.getEncryptedFileName());\n\n                    if (decryptedFile == null) {\n                        return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                    }\n\n                    keyString = decryptedFile.getEncrypted().getKey();\n                    nonceString = decryptedFile.getInitializationVector();\n                    authenticationTagString = decryptedFile.getAuthenticationTag();\n                }\n\n                byte[] key = decodeStringToBase64Bytes(keyString);\n                byte[] iv = decodeStringToBase64Bytes(nonceString);\n\n                try {\n                    Cipher cipher = EncryptionUtils.getCipher(Cipher.DECRYPT_MODE, key, iv);\n                    EncryptionUtils.decryptFile(cipher, tmpFile, newFile, authenticationTagString, new ArbitraryDataProviderImpl(operationContext), user);\n                } catch (Exception e) {\n                    return new RemoteOperationResult(e);\n                }\n            }\n\n            if (downloadType == DownloadType.DOWNLOAD && !file.isEncrypted()) {\n                moved = tmpFile.renameTo(newFile);\n                boolean isLastModifiedSet = newFile.setLastModified(file.getModificationTimestamp());\n                Log_OC.d(TAG, \"Last modified set: \" + isLastModifiedSet);\n                if (!moved) {\n                    result = new RemoteOperationResult(RemoteOperationResult.ResultCode.LOCAL_STORAGE_NOT_MOVED);\n                }\n            } else if (downloadType == DownloadType.EXPORT) {\n                new FileExportUtils().exportFile(file.getFileName(),\n                                                 file.getMimeType(),\n                                                 operationContext.getContentResolver(),\n                                                 null,\n                                                 tmpFile);\n                if (!tmpFile.delete()) {\n                    Log_OC.e(TAG, \"Deletion of \" + tmpFile.getAbsolutePath() + \" failed!\");\n                }\n            }\n        }\n\n        Log_OC.i(TAG, \"Download of \" + file.getRemotePath() + \" to \" + getSavePath() + \": \" +\n                result.getLogMessage());\n\n        return result;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled run from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: run\n\n        Method Code: Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        /// perform the download\n        synchronized(cancellationRequested) {\n            if (cancellationRequested.get()) {\n                return new RemoteOperationResult(new OperationCancelledException());\n            }\n        }\n\n        Context operationContext = context.get();\n        if (operationContext == null) {\n            return new RemoteOperationResult(RemoteOperationResult.ResultCode.UNKNOWN_ERROR);\n        }\n\n        RemoteOperationResult result;\n        File newFile = null;\n        boolean moved;\n\n        /// download will be performed to a temporal file, then moved to the final location\n        File tmpFile = new File(getTmpPath());\n\n        String tmpFolder = getTmpFolder();\n\n        downloadOperation = new DownloadFileRemoteOperation(file.getRemotePath(), tmpFolder);\n\n        if (downloadType == DownloadType.DOWNLOAD) {\n            Iterator<OnDatatransferProgressListener> listener = dataTransferListeners.iterator();\n            while (listener.hasNext()) {\n                downloadOperation.addDatatransferProgressListener(listener.next());\n            }\n        }\n\n        result = downloadOperation.execute(client);\n\n\n\n        if (result.isSuccess()) {\n            modificationTimestamp = downloadOperation.getModificationTimestamp();\n            etag = downloadOperation.getEtag();\n\n            if (downloadType == DownloadType.DOWNLOAD) {\n                newFile = new File(getSavePath());\n\n                if (!newFile.getParentFile().exists() && !newFile.getParentFile().mkdirs()) {\n                    Log_OC.e(TAG, \"Unable to create parent folder \" + newFile.getParentFile().getAbsolutePath());\n                }\n            }\n\n            // decrypt file\n            if (file.isEncrypted()) {\n                FileDataStorageManager fileDataStorageManager = new FileDataStorageManager(user, operationContext.getContentResolver());\n\n                OCFile parent = fileDataStorageManager.getFileByEncryptedRemotePath(file.getParentRemotePath());\n\n                Object object = EncryptionUtils.downloadFolderMetadata(parent,\n                                                                       client,\n                                                                       operationContext,\n                                                                       user);\n\n                if (object == null) {\n                    return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                }\n\n                String keyString;\n                String nonceString;\n                String authenticationTagString;\n                if (object instanceof DecryptedFolderMetadataFile) {\n                    DecryptedFile decryptedFile = ((DecryptedFolderMetadataFile) object)\n                        .getMetadata()\n                        .getFiles()\n                        .get(file.getEncryptedFileName());\n\n                    if (decryptedFile == null) {\n                        return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                    }\n\n                    keyString = decryptedFile.getKey();\n                    nonceString = decryptedFile.getNonce();\n                    authenticationTagString = decryptedFile.getAuthenticationTag();\n                } else {\n                    com.owncloud.android.datamodel.e2e.v1.decrypted.DecryptedFile decryptedFile =\n                        ((DecryptedFolderMetadataFileV1) object)\n                            .getFiles()\n                            .get(file.getEncryptedFileName());\n\n                    if (decryptedFile == null) {\n                        return new RemoteOperationResult(RemoteOperationResult.ResultCode.METADATA_NOT_FOUND);\n                    }\n\n                    keyString = decryptedFile.getEncrypted().getKey();\n                    nonceString = decryptedFile.getInitializationVector();\n                    authenticationTagString = decryptedFile.getAuthenticationTag();\n                }\n\n                byte[] key = decodeStringToBase64Bytes(keyString);\n                byte[] iv = decodeStringToBase64Bytes(nonceString);\n\n                try {\n                    Cipher cipher = EncryptionUtils.getCipher(Cipher.DECRYPT_MODE, key, iv);\n                    EncryptionUtils.decryptFile(cipher, tmpFile, newFile, authenticationTagString, new ArbitraryDataProviderImpl(operationContext), user);\n                } catch (Exception e) {\n                    return new RemoteOperationResult(e);\n                }\n            }\n\n            if (downloadType == DownloadType.DOWNLOAD && !file.isEncrypted()) {\n                moved = tmpFile.renameTo(newFile);\n                boolean isLastModifiedSet = newFile.setLastModified(file.getModificationTimestamp());\n                Log_OC.d(TAG, \"Last modified set: \" + isLastModifiedSet);\n                if (!moved) {\n                    result = new RemoteOperationResult(RemoteOperationResult.ResultCode.LOCAL_STORAGE_NOT_MOVED);\n                }\n            } else if (downloadType == DownloadType.EXPORT) {\n                new FileExportUtils().exportFile(file.getFileName(),\n                                                 file.getMimeType(),\n                                                 operationContext.getContentResolver(),\n                                                 null,\n                                                 tmpFile);\n                if (!tmpFile.delete()) {\n                    Log_OC.e(TAG, \"Deletion of \" + tmpFile.getAbsolutePath() + \" failed!\");\n                }\n            }\n        }\n\n        Log_OC.i(TAG, \"Download of \" + file.getRemotePath() + \" to \" + getSavePath() + \": \" +\n                result.getLogMessage());\n\n        return result;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func run(client: OwnCloudClient) -> RemoteOperationResult {\n    // perform the download\n    objc_sync_enter(cancellationRequested)\n    defer { objc_sync_exit(cancellationRequested) }\n    if cancellationRequested.boolValue {\n        return RemoteOperationResult(OperationCancelledException())\n    }\n\n    guard let operationContext = context.get() else {\n        return RemoteOperationResult(.unknownError)\n    }\n\n    var result: RemoteOperationResult\n    var newFile: File?\n    var moved: Bool\n\n    // download will be performed to a temporal file, then moved to the final location\n    let tmpFile = File(getTmpPath())\n\n    let tmpFolder = getTmpFolder()\n\n    downloadOperation = DownloadFileRemoteOperation(file.remotePath, tmpFolder)\n\n    if downloadType == .download {\n        for listener in dataTransferListeners {\n            downloadOperation.addDatatransferProgressListener(listener)\n        }\n    }\n\n    result = downloadOperation.execute(client)\n\n    if result.isSuccess {\n        modificationTimestamp = downloadOperation.modificationTimestamp\n        etag = downloadOperation.etag\n\n        if downloadType == .download {\n            newFile = File(getSavePath())\n\n            if !(newFile?.parentFile.exists() ?? false) && !(newFile?.parentFile.mkdirs() ?? false) {\n                Log_OC.e(TAG, \"Unable to create parent folder \\(newFile?.parentFile.absolutePath ?? \"\")\")\n            }\n        }\n\n        // decrypt file\n        if file.isEncrypted {\n            let fileDataStorageManager = FileDataStorageManager(user: user, contentResolver: operationContext.contentResolver)\n\n            let parent = fileDataStorageManager.getFileByEncryptedRemotePath(file.parentRemotePath)\n\n            let object = EncryptionUtils.downloadFolderMetadata(parent, client: client, context: operationContext, user: user)\n\n            guard let object = object else {\n                return RemoteOperationResult(.metadataNotFound)\n            }\n\n            var keyString: String\n            var nonceString: String\n            var authenticationTagString: String\n            if let decryptedFolderMetadataFile = object as? DecryptedFolderMetadataFile {\n                guard let decryptedFile = decryptedFolderMetadataFile.metadata.files[file.encryptedFileName] else {\n                    return RemoteOperationResult(.metadataNotFound)\n                }\n\n                keyString = decryptedFile.key\n                nonceString = decryptedFile.nonce\n                authenticationTagString = decryptedFile.authenticationTag\n            } else if let decryptedFolderMetadataFileV1 = object as? DecryptedFolderMetadataFileV1 {\n                guard let decryptedFile = decryptedFolderMetadataFileV1.files[file.encryptedFileName] else {\n                    return RemoteOperationResult(.metadataNotFound)\n                }\n\n                keyString = decryptedFile.encrypted.key\n                nonceString = decryptedFile.initializationVector\n                authenticationTagString = decryptedFile.authenticationTag\n            } else {\n                return RemoteOperationResult(.metadataNotFound)\n            }\n\n            let key = decodeStringToBase64Bytes(keyString)\n            let iv = decodeStringToBase64Bytes(nonceString)\n\n            do {\n                let cipher = try EncryptionUtils.getCipher(.decryptMode, key: key, iv: iv)\n                try EncryptionUtils.decryptFile(cipher, tmpFile: tmpFile, newFile: newFile, authenticationTag: authenticationTagString, dataProvider: ArbitraryDataProviderImpl(operationContext), user: user)\n            } catch {\n                return RemoteOperationResult(error)\n            }\n        }\n\n        if downloadType == .download && !file.isEncrypted {\n            moved = tmpFile.renameTo(newFile)\n            let isLastModifiedSet = newFile?.setLastModified(file.modificationTimestamp) ?? false\n            Log_OC.d(TAG, \"Last modified set: \\(isLastModifiedSet)\")\n            if !moved {\n                result = RemoteOperationResult(.localStorageNotMoved)\n            }\n        } else if downloadType == .export {\n            FileExportUtils().exportFile(file.fileName, mimeType: file.mimeType, contentResolver: operationContext.contentResolver, uri: nil, tmpFile: tmpFile)\n            if !tmpFile.delete() {\n                Log_OC.e(TAG, \"Deletion of \\(tmpFile.absolutePath) failed!\")\n            }\n        }\n    }\n\n    Log_OC.i(TAG, \"Download of \\(file.remotePath) to \\(getSavePath()): \\(result.logMessage)\")\n\n    return result\n}\n```"
    },
    {
        "method_name": "cancel",
        "method_code": "ublic void cancel() {\n        cancellationRequested.set(true);   // atomic set; there is no need of synchronizing it\n        if (downloadOperation != null) {\n            downloadOperation.cancel();\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled cancel from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: cancel\n\n        Method Code: ublic void cancel() {\n        cancellationRequested.set(true);   // atomic set; there is no need of synchronizing it\n        if (downloadOperation != null) {\n            downloadOperation.cancel();\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc cancel() {\n    cancellationRequested = true // atomic set; there is no need of synchronizing it\n    downloadOperation?.cancel()\n}\n```"
    },
    {
        "method_name": "addDownloadDataTransferProgressListener",
        "method_code": "ublic void addDownloadDataTransferProgressListener(OnDatatransferProgressListener listener) {\n        synchronized (dataTransferListeners) {\n            dataTransferListeners.add(listener);\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled addDownloadDataTransferProgressListener from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: addDownloadDataTransferProgressListener\n\n        Method Code: ublic void addDownloadDataTransferProgressListener(OnDatatransferProgressListener listener) {\n        synchronized (dataTransferListeners) {\n            dataTransferListeners.add(listener);\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc addDownloadDataTransferProgressListener(listener: OnDatatransferProgressListener) {\n    objc_sync_enter(dataTransferListeners)\n    dataTransferListeners.append(listener)\n    objc_sync_exit(dataTransferListeners)\n}\n```"
    },
    {
        "method_name": "removeDatatransferProgressListener",
        "method_code": "ublic void removeDatatransferProgressListener(OnDatatransferProgressListener listener) {\n        synchronized (dataTransferListeners) {\n            dataTransferListeners.remove(listener);\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled removeDatatransferProgressListener from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: removeDatatransferProgressListener\n\n        Method Code: ublic void removeDatatransferProgressListener(OnDatatransferProgressListener listener) {\n        synchronized (dataTransferListeners) {\n            dataTransferListeners.remove(listener);\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc removeDatatransferProgressListener(listener: OnDatatransferProgressListener) {\n    objc_sync_enter(dataTransferListeners)\n    defer { objc_sync_exit(dataTransferListeners) }\n    if let index = dataTransferListeners.firstIndex(where: { $0 === listener }) {\n        dataTransferListeners.remove(at: index)\n    }\n}\n```"
    },
    {
        "method_name": "getUser",
        "method_code": "ublic User getUser() {\n        return this.user;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getUser from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getUser\n\n        Method Code: ublic User getUser() {\n        return this.user;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getUser() -> User {\n    return self.user\n}\n```"
    },
    {
        "method_name": "getFile",
        "method_code": "ublic OCFile getFile() {\n        return this.file;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getFile from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getFile\n\n        Method Code: ublic OCFile getFile() {\n        return this.file;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getFile() -> OCFile? {\n    return self.file\n}\n```"
    },
    {
        "method_name": "getBehaviour",
        "method_code": "ublic String getBehaviour() {\n        return this.behaviour;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getBehaviour from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getBehaviour\n\n        Method Code: ublic String getBehaviour() {\n        return this.behaviour;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getBehaviour() -> String {\n    return self.behaviour\n}\n```"
    },
    {
        "method_name": "getEtag",
        "method_code": "ublic String getEtag() {\n        return this.etag;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getEtag from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getEtag\n\n        Method Code: ublic String getEtag() {\n        return this.etag;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getEtag() -> String {\n    return self.etag\n}\n```"
    },
    {
        "method_name": "getActivityName",
        "method_code": "ublic String getActivityName() {\n        return this.activityName;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getActivityName from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getActivityName\n\n        Method Code: ublic String getActivityName() {\n        return this.activityName;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getActivityName() -> String {\n    return self.activityName\n}\n```"
    },
    {
        "method_name": "getPackageName",
        "method_code": "ublic String getPackageName() {\n        return this.packageName;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getPackageName from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getPackageName\n\n        Method Code: ublic String getPackageName() {\n        return this.packageName;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getPackageName() -> String {\n    return self.packageName\n}\n```"
    },
    {
        "method_name": "getDownloadType",
        "method_code": "ublic DownloadType getDownloadType() {\n        return downloadType;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDownloadType from DownloadFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getDownloadType\n\n        Method Code: ublic DownloadType getDownloadType() {\n        return downloadType;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getDownloadType() -> DownloadType {\n    return downloadType\n}\n```"
    }
]