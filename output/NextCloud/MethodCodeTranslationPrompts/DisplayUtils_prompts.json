[
    {
        "method_name": "bytesToHumanReadable",
        "method_code": "blic static String bytesToHumanReadable(long bytes) {\n        if (bytes < 0) {\n            return MainApp.string(R.string.common_pending);\n        } else {\n            double result = bytes;\n            int suffixIndex = 0;\n            while (result > BYTE_SIZE_DIVIDER && suffixIndex < sizeSuffixes.length) {\n                result /= BYTE_SIZE_DIVIDER_DOUBLE;\n                suffixIndex++;\n            }\n\n            return new BigDecimal(String.valueOf(result)).setScale(\n                sizeScales[suffixIndex], BigDecimal.ROUND_HALF_UP) + \" \" + sizeSuffixes[suffixIndex];\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled bytesToHumanReadable from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: bytesToHumanReadable\n\n        Method Code: blic static String bytesToHumanReadable(long bytes) {\n        if (bytes < 0) {\n            return MainApp.string(R.string.common_pending);\n        } else {\n            double result = bytes;\n            int suffixIndex = 0;\n            while (result > BYTE_SIZE_DIVIDER && suffixIndex < sizeSuffixes.length) {\n                result /= BYTE_SIZE_DIVIDER_DOUBLE;\n                suffixIndex++;\n            }\n\n            return new BigDecimal(String.valueOf(result)).setScale(\n                sizeScales[suffixIndex], BigDecimal.ROUND_HALF_UP) + \" \" + sizeSuffixes[suffixIndex];\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc bytesToHumanReadable(_ bytes: Int64) -> String {\n    if bytes < 0 {\n        return MainApp.string(R.string.common_pending)\n    } else {\n        var result = Double(bytes)\n        var suffixIndex = 0\n        while result > BYTE_SIZE_DIVIDER && suffixIndex < sizeSuffixes.count {\n            result /= BYTE_SIZE_DIVIDER_DOUBLE\n            suffixIndex += 1\n        }\n\n        let roundedResult = BigDecimal(String(result)).setScale(sizeScales[suffixIndex], .roundHalfUp)\n        return \"\\(roundedResult) \\(sizeSuffixes[suffixIndex])\"\n    }\n}\n```"
    },
    {
        "method_name": "convertMIMEtoPrettyPrint",
        "method_code": "blic static String convertMIMEtoPrettyPrint(String mimetype) {\n        final String humanReadableMime = mimeType2HumanReadable.get(mimetype);\n        if (humanReadableMime != null) {\n            return humanReadableMime;\n        }\n        if (mimetype.split(\"/\").length >= MIMETYPE_PARTS_COUNT) {\n            return mimetype.split(\"/\")[1].toUpperCase(Locale.getDefault()) + \" file\";\n        }\n        return MIME_TYPE_UNKNOWN;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertMIMEtoPrettyPrint from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: convertMIMEtoPrettyPrint\n\n        Method Code: blic static String convertMIMEtoPrettyPrint(String mimetype) {\n        final String humanReadableMime = mimeType2HumanReadable.get(mimetype);\n        if (humanReadableMime != null) {\n            return humanReadableMime;\n        }\n        if (mimetype.split(\"/\").length >= MIMETYPE_PARTS_COUNT) {\n            return mimetype.split(\"/\")[1].toUpperCase(Locale.getDefault()) + \" file\";\n        }\n        return MIME_TYPE_UNKNOWN;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func convertMIMEtoPrettyPrint(_ mimetype: String) -> String {\n    if let humanReadableMime = mimeType2HumanReadable[mimetype] {\n        return humanReadableMime\n    }\n    let parts = mimetype.split(separator: \"/\")\n    if parts.count >= MIMETYPE_PARTS_COUNT {\n        return parts[1].uppercased() + \" file\"\n    }\n    return MIME_TYPE_UNKNOWN\n}\n```"
    },
    {
        "method_name": "unixTimeToHumanReadable",
        "method_code": "blic static String unixTimeToHumanReadable(long milliseconds) {\n        Date date = new Date(milliseconds);\n        DateFormat df = DateFormat.getDateTimeInstance();\n        return df.format(date);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled unixTimeToHumanReadable from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: unixTimeToHumanReadable\n\n        Method Code: blic static String unixTimeToHumanReadable(long milliseconds) {\n        Date date = new Date(milliseconds);\n        DateFormat df = DateFormat.getDateTimeInstance();\n        return df.format(date);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc unixTimeToHumanReadable(milliseconds: Int64) -> String {\n    let date = Date(timeIntervalSince1970: TimeInterval(milliseconds) / 1000)\n    let dateFormatter = DateFormatter()\n    dateFormatter.dateStyle = .medium\n    dateFormatter.timeStyle = .medium\n    return dateFormatter.string(from: date)\n}\n```"
    },
    {
        "method_name": "beautifyURL",
        "method_code": "blic static String beautifyURL(@Nullable String url) {\n        if (TextUtils.isEmpty(url)) {\n            return \"\";\n        }\n\n        if (url.length() >= 7 && HTTP_PROTOCOL.equalsIgnoreCase(url.substring(0, 7))) {\n            return url.substring(HTTP_PROTOCOL.length()).trim();\n        }\n\n        if (url.length() >= 8 && HTTPS_PROTOCOL.equalsIgnoreCase(url.substring(0, 8))) {\n            return url.substring(HTTPS_PROTOCOL.length()).trim();\n        }\n\n        return url.trim();\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled beautifyURL from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: beautifyURL\n\n        Method Code: blic static String beautifyURL(@Nullable String url) {\n        if (TextUtils.isEmpty(url)) {\n            return \"\";\n        }\n\n        if (url.length() >= 7 && HTTP_PROTOCOL.equalsIgnoreCase(url.substring(0, 7))) {\n            return url.substring(HTTP_PROTOCOL.length()).trim();\n        }\n\n        if (url.length() >= 8 && HTTPS_PROTOCOL.equalsIgnoreCase(url.substring(0, 8))) {\n            return url.substring(HTTPS_PROTOCOL.length()).trim();\n        }\n\n        return url.trim();\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc beautifyURL(_ url: String?) -> String {\n    guard let url = url, !url.isEmpty else {\n        return \"\"\n    }\n\n    if url.count >= 7 && url.prefix(7).caseInsensitiveCompare(\"http://\") == .orderedSame {\n        return String(url.dropFirst(7)).trimmingCharacters(in: .whitespaces)\n    }\n\n    if url.count >= 8 && url.prefix(8).caseInsensitiveCompare(\"https://\") == .orderedSame {\n        return String(url.dropFirst(8)).trimmingCharacters(in: .whitespaces)\n    }\n\n    return url.trimmingCharacters(in: .whitespaces)\n}\n```"
    },
    {
        "method_name": "beautifyTwitterHandle",
        "method_code": "blic static String beautifyTwitterHandle(@Nullable String handle) {\n        if (handle != null) {\n            String trimmedHandle = handle.trim();\n\n            if (TextUtils.isEmpty(trimmedHandle)) {\n                return \"\";\n            }\n\n            if (trimmedHandle.startsWith(TWITTER_HANDLE_PREFIX)) {\n                return trimmedHandle;\n            } else {\n                return TWITTER_HANDLE_PREFIX + trimmedHandle;\n            }\n        } else {\n            return \"\";\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled beautifyTwitterHandle from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: beautifyTwitterHandle\n\n        Method Code: blic static String beautifyTwitterHandle(@Nullable String handle) {\n        if (handle != null) {\n            String trimmedHandle = handle.trim();\n\n            if (TextUtils.isEmpty(trimmedHandle)) {\n                return \"\";\n            }\n\n            if (trimmedHandle.startsWith(TWITTER_HANDLE_PREFIX)) {\n                return trimmedHandle;\n            } else {\n                return TWITTER_HANDLE_PREFIX + trimmedHandle;\n            }\n        } else {\n            return \"\";\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc beautifyTwitterHandle(_ handle: String?) -> String {\n    if let handle = handle {\n        let trimmedHandle = handle.trimmingCharacters(in: .whitespaces)\n\n        if trimmedHandle.isEmpty {\n            return \"\"\n        }\n\n        if trimmedHandle.hasPrefix(TWITTER_HANDLE_PREFIX) {\n            return trimmedHandle\n        } else {\n            return TWITTER_HANDLE_PREFIX + trimmedHandle\n        }\n    } else {\n        return \"\"\n    }\n}\n```"
    },
    {
        "method_name": "convertIdn",
        "method_code": "blic static String convertIdn(String url, boolean toASCII) {\n\n        String urlNoDots = url;\n        String dots = \"\";\n        while (urlNoDots.length() > 0 && urlNoDots.charAt(0) == '.') {\n            urlNoDots = url.substring(1);\n            dots = dots + \".\";\n        }\n\n        // Find host name after '//' or '@'\n        int hostStart = 0;\n        if (urlNoDots.contains(\"//\")) {\n            hostStart = url.indexOf(\"//\") + \"//\".length();\n        } else if (url.contains(\"@\")) {\n            hostStart = url.indexOf('@') + \"@\".length();\n        }\n\n        int hostEnd = url.substring(hostStart).indexOf('/');\n        // Handle URL which doesn't have a path (path is implicitly '/')\n        hostEnd = hostEnd == -1 ? urlNoDots.length() : hostStart + hostEnd;\n\n        String host = urlNoDots.substring(hostStart, hostEnd);\n        host = toASCII ? IDN.toASCII(host) : IDN.toUnicode(host);\n\n        return dots + urlNoDots.substring(0, hostStart) + host + urlNoDots.substring(hostEnd);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertIdn from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: convertIdn\n\n        Method Code: blic static String convertIdn(String url, boolean toASCII) {\n\n        String urlNoDots = url;\n        String dots = \"\";\n        while (urlNoDots.length() > 0 && urlNoDots.charAt(0) == '.') {\n            urlNoDots = url.substring(1);\n            dots = dots + \".\";\n        }\n\n        // Find host name after '//' or '@'\n        int hostStart = 0;\n        if (urlNoDots.contains(\"//\")) {\n            hostStart = url.indexOf(\"//\") + \"//\".length();\n        } else if (url.contains(\"@\")) {\n            hostStart = url.indexOf('@') + \"@\".length();\n        }\n\n        int hostEnd = url.substring(hostStart).indexOf('/');\n        // Handle URL which doesn't have a path (path is implicitly '/')\n        hostEnd = hostEnd == -1 ? urlNoDots.length() : hostStart + hostEnd;\n\n        String host = urlNoDots.substring(hostStart, hostEnd);\n        host = toASCII ? IDN.toASCII(host) : IDN.toUnicode(host);\n\n        return dots + urlNoDots.substring(0, hostStart) + host + urlNoDots.substring(hostEnd);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc convertIdn(url: String, toASCII: Bool) -> String {\n    var urlNoDots = url\n    var dots = \"\"\n    while urlNoDots.count > 0 && urlNoDots.first == \".\" {\n        urlNoDots = String(urlNoDots.dropFirst())\n        dots += \".\"\n    }\n\n    var hostStart = 0\n    if urlNoDots.contains(\"//\") {\n        hostStart = url.range(of: \"//\")!.upperBound.utf16Offset(in: url)\n    } else if url.contains(\"@\") {\n        hostStart = url.range(of: \"@\")!.upperBound.utf16Offset(in: url)\n    }\n\n    let hostEndIndex = urlNoDots[hostStart...].firstIndex(of: \"/\") ?? urlNoDots.endIndex\n    let hostEnd = hostEndIndex.utf16Offset(in: urlNoDots)\n    \n    let host = String(urlNoDots[urlNoDots.index(urlNoDots.startIndex, offsetBy: hostStart)..<urlNoDots.index(urlNoDots.startIndex, offsetBy: hostEnd)])\n    let convertedHost = toASCII ? host.applyingTransform(.toLatin, reverse: false) ?? host : host.applyingTransform(.toUnicodeName, reverse: true) ?? host\n\n    return dots + urlNoDots.prefix(hostStart) + convertedHost + urlNoDots.suffix(from: urlNoDots.index(urlNoDots.startIndex, offsetBy: hostEnd))\n}\n```"
    },
    {
        "method_name": "getAccountNameDisplayText",
        "method_code": "blic static String getAccountNameDisplayText(User user) {\n        final OwnCloudAccount ocs = user.toOwnCloudAccount();\n        final String accountName = user.getAccountName();\n        return ocs.getDisplayName()\n                + \"@\"\n                + convertIdn(accountName.substring(accountName.lastIndexOf('@') + 1), false);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getAccountNameDisplayText from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getAccountNameDisplayText\n\n        Method Code: blic static String getAccountNameDisplayText(User user) {\n        final OwnCloudAccount ocs = user.toOwnCloudAccount();\n        final String accountName = user.getAccountName();\n        return ocs.getDisplayName()\n                + \"@\"\n                + convertIdn(accountName.substring(accountName.lastIndexOf('@') + 1), false);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getAccountNameDisplayText(user: User) -> String {\n    let ocs = user.toOwnCloudAccount()\n    let accountName = user.getAccountName()\n    let domain = accountName.split(separator: \"@\").last ?? \"\"\n    return \"\\(ocs.getDisplayName())@\\(convertIdn(String(domain), false))\"\n}\n```"
    },
    {
        "method_name": "getRelativeTimestamp",
        "method_code": "blic static CharSequence getRelativeTimestamp(Context context, long modificationTimestamp) {\n        return getRelativeDateTimeString(context, modificationTimestamp, DateUtils.SECOND_IN_MILLIS,\n                                         DateUtils.WEEK_IN_MILLIS, 0);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getRelativeTimestamp from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getRelativeTimestamp\n\n        Method Code: blic static CharSequence getRelativeTimestamp(Context context, long modificationTimestamp) {\n        return getRelativeDateTimeString(context, modificationTimestamp, DateUtils.SECOND_IN_MILLIS,\n                                         DateUtils.WEEK_IN_MILLIS, 0);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getRelativeTimestamp(modificationTimestamp: TimeInterval) -> String {\n    let date = Date(timeIntervalSince1970: modificationTimestamp)\n    let formatter = RelativeDateTimeFormatter()\n    formatter.unitsStyle = .full\n    return formatter.localizedString(for: date, relativeTo: Date())\n}\n```"
    },
    {
        "method_name": "getRelativeTimestamp",
        "method_code": "blic static CharSequence getRelativeTimestamp(Context context, long modificationTimestamp, boolean showFuture) {\n        return getRelativeDateTimeString(context,\n                                         modificationTimestamp,\n                                         DateUtils.SECOND_IN_MILLIS,\n                                         DateUtils.WEEK_IN_MILLIS,\n                                         0,\n                                         showFuture);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getRelativeTimestamp from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getRelativeTimestamp\n\n        Method Code: blic static CharSequence getRelativeTimestamp(Context context, long modificationTimestamp, boolean showFuture) {\n        return getRelativeDateTimeString(context,\n                                         modificationTimestamp,\n                                         DateUtils.SECOND_IN_MILLIS,\n                                         DateUtils.WEEK_IN_MILLIS,\n                                         0,\n                                         showFuture);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getRelativeTimestamp(context: Context, modificationTimestamp: Int64, showFuture: Bool) -> String {\n    return getRelativeDateTimeString(context: context,\n                                     time: modificationTimestamp,\n                                     minResolution: DateUtils.SECOND_IN_MILLIS,\n                                     transitionResolution: DateUtils.WEEK_IN_MILLIS,\n                                     flags: 0,\n                                     showFuture: showFuture)\n}\n```"
    },
    {
        "method_name": "getRelativeDateTimeString",
        "method_code": "blic static CharSequence getRelativeDateTimeString(Context c, long time, long minResolution,\n                                                         long transitionResolution, int flags) {\n        return getRelativeDateTimeString(c, time, minResolution, transitionResolution, flags, false);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getRelativeDateTimeString from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getRelativeDateTimeString\n\n        Method Code: blic static CharSequence getRelativeDateTimeString(Context c, long time, long minResolution,\n                                                         long transitionResolution, int flags) {\n        return getRelativeDateTimeString(c, time, minResolution, transitionResolution, flags, false);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func getRelativeDateTimeString(context: Context, time: Int64, minResolution: Int64, transitionResolution: Int64, flags: Int) -> String {\n    return getRelativeDateTimeString(context: context, time: time, minResolution: minResolution, transitionResolution: transitionResolution, flags: flags, isRelative: false)\n}\n```"
    },
    {
        "method_name": "getRelativeDateTimeString",
        "method_code": "blic static CharSequence getRelativeDateTimeString(Context c,\n                                                         long time,\n                                                         long minResolution,\n                                                         long transitionResolution,\n                                                         int flags,\n                                                         boolean showFuture) {\n\n        CharSequence dateString = \"\";\n\n        // in Future\n        if (!showFuture && time > System.currentTimeMillis()) {\n            return DisplayUtils.unixTimeToHumanReadable(time);\n        }\n        // < 60 seconds -> seconds ago\n        long diff = System.currentTimeMillis() - time;\n        if (diff > 0 && diff < 60 * 1000 && minResolution == DateUtils.SECOND_IN_MILLIS) {\n            return c.getString(R.string.file_list_seconds_ago);\n        } else {\n            dateString = DateUtils.getRelativeDateTimeString(c, time, minResolution, transitionResolution, flags);\n        }\n\n        String[] parts = dateString.toString().split(\",\");\n        if (parts.length == DATE_TIME_PARTS_SIZE) {\n            if (parts[1].contains(\":\") && !parts[0].contains(\":\")) {\n                return parts[0];\n            } else if (parts[0].contains(\":\") && !parts[1].contains(\":\")) {\n                return parts[1];\n            }\n        }\n        // dateString contains unexpected format. fallback: use relative date time string from android api as is.\n        return dateString.toString();\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getRelativeDateTimeString from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getRelativeDateTimeString\n\n        Method Code: blic static CharSequence getRelativeDateTimeString(Context c,\n                                                         long time,\n                                                         long minResolution,\n                                                         long transitionResolution,\n                                                         int flags,\n                                                         boolean showFuture) {\n\n        CharSequence dateString = \"\";\n\n        // in Future\n        if (!showFuture && time > System.currentTimeMillis()) {\n            return DisplayUtils.unixTimeToHumanReadable(time);\n        }\n        // < 60 seconds -> seconds ago\n        long diff = System.currentTimeMillis() - time;\n        if (diff > 0 && diff < 60 * 1000 && minResolution == DateUtils.SECOND_IN_MILLIS) {\n            return c.getString(R.string.file_list_seconds_ago);\n        } else {\n            dateString = DateUtils.getRelativeDateTimeString(c, time, minResolution, transitionResolution, flags);\n        }\n\n        String[] parts = dateString.toString().split(\",\");\n        if (parts.length == DATE_TIME_PARTS_SIZE) {\n            if (parts[1].contains(\":\") && !parts[0].contains(\":\")) {\n                return parts[0];\n            } else if (parts[0].contains(\":\") && !parts[1].contains(\":\")) {\n                return parts[1];\n            }\n        }\n        // dateString contains unexpected format. fallback: use relative date time string from android api as is.\n        return dateString.toString();\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getRelativeDateTimeString(context: Context, time: Int64, minResolution: Int64, transitionResolution: Int64, flags: Int, showFuture: Bool) -> String {\n    var dateString: String = \"\"\n\n    if !showFuture && time > Date().timeIntervalSince1970 * 1000 {\n        return DisplayUtils.unixTimeToHumanReadable(time: time)\n    }\n\n    let diff = Int64(Date().timeIntervalSince1970 * 1000) - time\n    if diff > 0 && diff < 60 * 1000 && minResolution == DateUtils.SECOND_IN_MILLIS {\n        return context.getString(R.string.file_list_seconds_ago)\n    } else {\n        dateString = DateUtils.getRelativeDateTimeString(context: context, time: time, minResolution: minResolution, transitionResolution: transitionResolution, flags: flags)\n    }\n\n    let parts = dateString.split(separator: \",\")\n    if parts.count == DATE_TIME_PARTS_SIZE {\n        if parts[1].contains(\":\") && !parts[0].contains(\":\") {\n            return String(parts[0])\n        } else if parts[0].contains(\":\") && !parts[1].contains(\":\") {\n            return String(parts[1])\n        }\n    }\n\n    return dateString\n}\n```"
    },
    {
        "method_name": "getPathWithoutLastSlash",
        "method_code": "blic static String getPathWithoutLastSlash(String path) {\n\n        // Remove last slash from path\n        if (path.length() > 1 && path.charAt(path.length() - 1) == OCFile.PATH_SEPARATOR.charAt(0)) {\n            return path.substring(0, path.length() - 1);\n        }\n\n        return path;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getPathWithoutLastSlash from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getPathWithoutLastSlash\n\n        Method Code: blic static String getPathWithoutLastSlash(String path) {\n\n        // Remove last slash from path\n        if (path.length() > 1 && path.charAt(path.length() - 1) == OCFile.PATH_SEPARATOR.charAt(0)) {\n            return path.substring(0, path.length() - 1);\n        }\n\n        return path;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getPathWithoutLastSlash(_ path: String) -> String {\n    if path.count > 1 && path.last == OCFile.PATH_SEPARATOR.first {\n        return String(path.dropLast())\n    }\n    return path\n}\n```"
    },
    {
        "method_name": "getScreenSize",
        "method_code": "blic static Point getScreenSize(Activity caller) {\n        Point size = new Point();\n        if (caller != null) {\n            caller.getWindowManager().getDefaultDisplay().getSize(size);\n        }\n        return size;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getScreenSize from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getScreenSize\n\n        Method Code: blic static Point getScreenSize(Activity caller) {\n        Point size = new Point();\n        if (caller != null) {\n            caller.getWindowManager().getDefaultDisplay().getSize(size);\n        }\n        return size;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc getScreenSize(caller: UIViewController?) -> CGPoint {\n    var size = CGPoint.zero\n    if let caller = caller {\n        size = caller.view.window?.screen.bounds.size ?? CGPoint.zero\n    }\n    return size\n}\n```"
    },
    {
        "method_name": "createTextWithSpan",
        "method_code": "blic static SpannableStringBuilder createTextWithSpan(String text, String spanText, StyleSpan style) {\n        if (text == null) {\n            return null;\n        }\n\n        SpannableStringBuilder sb = new SpannableStringBuilder(text);\n        if (spanText == null) {\n            return sb;\n        }\n\n        int start = text.lastIndexOf(spanText);\n\n        if (start < 0) {\n            return sb;\n        }\n\n        int end = start + spanText.length();\n        sb.setSpan(style, start, end, Spannable.SPAN_INCLUSIVE_INCLUSIVE);\n        return sb;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled createTextWithSpan from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: createTextWithSpan\n\n        Method Code: blic static SpannableStringBuilder createTextWithSpan(String text, String spanText, StyleSpan style) {\n        if (text == null) {\n            return null;\n        }\n\n        SpannableStringBuilder sb = new SpannableStringBuilder(text);\n        if (spanText == null) {\n            return sb;\n        }\n\n        int start = text.lastIndexOf(spanText);\n\n        if (start < 0) {\n            return sb;\n        }\n\n        int end = start + spanText.length();\n        sb.setSpan(style, start, end, Spannable.SPAN_INCLUSIVE_INCLUSIVE);\n        return sb;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc createTextWithSpan(text: String?, spanText: String?, style: UIFont) -> NSMutableAttributedString? {\n    guard let text = text else {\n        return nil\n    }\n\n    let attributedString = NSMutableAttributedString(string: text)\n    guard let spanText = spanText else {\n        return attributedString\n    }\n\n    if let range = text.range(of: spanText, options: .backwards) {\n        let nsRange = NSRange(range, in: text)\n        attributedString.addAttribute(.font, value: style, range: nsRange)\n    }\n\n    return attributedString\n}\n```"
    },
    {
        "method_name": "avatarGenerated",
        "method_code": "id avatarGenerated(Drawable avatarDrawable, Object callContext);\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled avatarGenerated from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: avatarGenerated\n\n        Method Code: id avatarGenerated(Drawable avatarDrawable, Object callContext);\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc avatarGenerated(avatarDrawable: Drawable, callContext: Any) -> Any {\n    // Implementation goes here\n}\n```"
    },
    {
        "method_name": "shouldCallGeneratedCallback",
        "method_code": "olean shouldCallGeneratedCallback(String tag, Object callContext);\n ",
        "prompt": "\n        Please translate the following Java (Android) method titled shouldCallGeneratedCallback from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: shouldCallGeneratedCallback\n\n        Method Code: olean shouldCallGeneratedCallback(String tag, Object callContext);\n \n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc shouldCallGeneratedCallback(tag: String, callContext: Any) -> Bool {\n    // Implementation goes here\n}\n```"
    },
    {
        "method_name": "setAvatar",
        "method_code": "blic static void setAvatar(@NonNull User user, AvatarGenerationListener listener,\n                                 float avatarRadius, Resources resources, Object callContext, Context context) {\n\n        AccountManager accountManager = AccountManager.get(context);\n        String userId = accountManager.getUserData(user.toPlatformAccount(),\n                com.owncloud.android.lib.common.accounts.AccountUtils.Constants.KEY_USER_ID);\n\n        setAvatar(user, userId, listener, avatarRadius, resources, callContext, context);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled setAvatar from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: setAvatar\n\n        Method Code: blic static void setAvatar(@NonNull User user, AvatarGenerationListener listener,\n                                 float avatarRadius, Resources resources, Object callContext, Context context) {\n\n        AccountManager accountManager = AccountManager.get(context);\n        String userId = accountManager.getUserData(user.toPlatformAccount(),\n                com.owncloud.android.lib.common.accounts.AccountUtils.Constants.KEY_USER_ID);\n\n        setAvatar(user, userId, listener, avatarRadius, resources, callContext, context);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func setAvatar(user: User, listener: AvatarGenerationListener, avatarRadius: Float, resources: Resources, callContext: Any, context: Context) {\n    let accountManager = AccountManager(context: context)\n    let userId = accountManager.getUserData(user.toPlatformAccount(), key: com.owncloud.android.lib.common.accounts.AccountUtils.Constants.KEY_USER_ID)\n    \n    setAvatar(user: user, userId: userId, listener: listener, avatarRadius: avatarRadius, resources: resources, callContext: callContext, context: context)\n}\n```"
    },
    {
        "method_name": "setAvatar",
        "method_code": "blic static void setAvatar(@NonNull User user, @NonNull String userId, AvatarGenerationListener listener,\n                                 float avatarRadius, Resources resources, Object callContext, Context context) {\n        setAvatar(user, userId, userId, listener, avatarRadius, resources, callContext, context);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled setAvatar from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: setAvatar\n\n        Method Code: blic static void setAvatar(@NonNull User user, @NonNull String userId, AvatarGenerationListener listener,\n                                 float avatarRadius, Resources resources, Object callContext, Context context) {\n        setAvatar(user, userId, userId, listener, avatarRadius, resources, callContext, context);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func setAvatar(user: User, userId: String, listener: AvatarGenerationListener, avatarRadius: Float, resources: Resources, callContext: Any, context: Context) {\n    setAvatar(user: user, userId: userId, anotherUserId: userId, listener: listener, avatarRadius: avatarRadius, resources: resources, callContext: callContext, context: context)\n}\n```"
    },
    {
        "method_name": "setAvatar",
        "method_code": "blic static void setAvatar(@NonNull User user,\n                                 @NonNull String userId,\n                                 String displayName,\n                                 AvatarGenerationListener listener,\n                                 float avatarRadius,\n                                 Resources resources,\n                                 Object callContext,\n                                 Context context) {\n        if (callContext instanceof View) {\n            ((View) callContext).setContentDescription(String.valueOf(user.toPlatformAccount().hashCode()));\n        }\n\n        ArbitraryDataProvider arbitraryDataProvider = new ArbitraryDataProviderImpl(context);\n\n        final String accountName = user.getAccountName();\n        String serverName = accountName.substring(accountName.lastIndexOf('@') + 1);\n        String eTag = arbitraryDataProvider.getValue(userId + \"@\" + serverName, ThumbnailsCacheManager.AVATAR);\n        String avatarKey = \"a_\" + userId + \"_\" + serverName + \"_\" + eTag;\n\n        // first show old one\n        Drawable avatar = BitmapUtils.bitmapToCircularBitmapDrawable(resources,\n                                                                     ThumbnailsCacheManager.getBitmapFromDiskCache(avatarKey));\n\n        // if no one exists, show colored icon with initial char\n        if (avatar == null) {\n            try {\n                avatar = TextDrawable.createAvatarByUserId(displayName, avatarRadius);\n            } catch (Exception e) {\n                Log_OC.e(TAG, \"Error calculating RGB value for active account icon.\", e);\n                avatar = ResourcesCompat.getDrawable(resources,\n                                                     R.drawable.account_circle_white,\n                                                     null);\n            }\n        }\n\n        listener.avatarGenerated(avatar, callContext);\n\n        // check for new avatar, eTag is compared, so only new one is downloaded\n        final ThumbnailsCacheManager.AvatarGenerationTask task =\n            new ThumbnailsCacheManager.AvatarGenerationTask(listener,\n                                                            callContext,\n                                                            user,\n                                                            resources,\n                                                            avatarRadius,\n                                                            userId,\n                                                            displayName,\n                                                            serverName,\n                                                            context);\n\n        task.execute(userId);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled setAvatar from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: setAvatar\n\n        Method Code: blic static void setAvatar(@NonNull User user,\n                                 @NonNull String userId,\n                                 String displayName,\n                                 AvatarGenerationListener listener,\n                                 float avatarRadius,\n                                 Resources resources,\n                                 Object callContext,\n                                 Context context) {\n        if (callContext instanceof View) {\n            ((View) callContext).setContentDescription(String.valueOf(user.toPlatformAccount().hashCode()));\n        }\n\n        ArbitraryDataProvider arbitraryDataProvider = new ArbitraryDataProviderImpl(context);\n\n        final String accountName = user.getAccountName();\n        String serverName = accountName.substring(accountName.lastIndexOf('@') + 1);\n        String eTag = arbitraryDataProvider.getValue(userId + \"@\" + serverName, ThumbnailsCacheManager.AVATAR);\n        String avatarKey = \"a_\" + userId + \"_\" + serverName + \"_\" + eTag;\n\n        // first show old one\n        Drawable avatar = BitmapUtils.bitmapToCircularBitmapDrawable(resources,\n                                                                     ThumbnailsCacheManager.getBitmapFromDiskCache(avatarKey));\n\n        // if no one exists, show colored icon with initial char\n        if (avatar == null) {\n            try {\n                avatar = TextDrawable.createAvatarByUserId(displayName, avatarRadius);\n            } catch (Exception e) {\n                Log_OC.e(TAG, \"Error calculating RGB value for active account icon.\", e);\n                avatar = ResourcesCompat.getDrawable(resources,\n                                                     R.drawable.account_circle_white,\n                                                     null);\n            }\n        }\n\n        listener.avatarGenerated(avatar, callContext);\n\n        // check for new avatar, eTag is compared, so only new one is downloaded\n        final ThumbnailsCacheManager.AvatarGenerationTask task =\n            new ThumbnailsCacheManager.AvatarGenerationTask(listener,\n                                                            callContext,\n                                                            user,\n                                                            resources,\n                                                            avatarRadius,\n                                                            userId,\n                                                            displayName,\n                                                            serverName,\n                                                            context);\n\n        task.execute(userId);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc setAvatar(user: User, userId: String, displayName: String?, listener: AvatarGenerationListener, avatarRadius: Float, resources: Resources, callContext: AnyObject, context: Context) {\n    if let view = callContext as? UIView {\n        view.accessibilityLabel = String(user.toPlatformAccount().hashValue)\n    }\n\n    let arbitraryDataProvider = ArbitraryDataProviderImpl(context: context)\n\n    let accountName = user.getAccountName()\n    let serverName = accountName.substring(from: accountName.lastIndex(of: \"@\")!.utf16Offset(in: accountName) + 1)\n    let eTag = arbitraryDataProvider.getValue(key: \"\\(userId)@\\(serverName)\", type: ThumbnailsCacheManager.AVATAR)\n    let avatarKey = \"a_\\(userId)_\\(serverName)_\\(eTag)\"\n\n    var avatar: Drawable? = BitmapUtils.bitmapToCircularBitmapDrawable(resources: resources, bitmap: ThumbnailsCacheManager.getBitmapFromDiskCache(key: avatarKey))\n\n    if avatar == nil {\n        do {\n            avatar = try TextDrawable.createAvatarByUserId(displayName: displayName, avatarRadius: avatarRadius)\n        } catch {\n            print(\"Error calculating RGB value for active account icon.\")\n            avatar = ResourcesCompat.getDrawable(resources: resources, id: R.drawable.account_circle_white, theme: nil)\n        }\n    }\n\n    listener.avatarGenerated(avatar: avatar, callContext: callContext)\n\n    let task = ThumbnailsCacheManager.AvatarGenerationTask(listener: listener, callContext: callContext, user: user, resources: resources, avatarRadius: avatarRadius, userId: userId, displayName: displayName, serverName: serverName, context: context)\n\n    task.execute(userId: userId)\n}\n```"
    },
    {
        "method_name": "downloadIcon",
        "method_code": "blic static void downloadIcon(CurrentAccountProvider currentAccountProvider,\n                                    ClientFactory clientFactory,\n                                    Context context,\n                                    String iconUrl,\n                                    SimpleTarget imageView,\n                                    int placeholder) {\n        try {\n            if (Uri.parse(iconUrl).getEncodedPath().endsWith(\".svg\")) {\n                downloadSVGIcon(currentAccountProvider, clientFactory, context, iconUrl, imageView, placeholder);\n            } else {\n                downloadPNGIcon(context, iconUrl, imageView, placeholder);\n            }\n        } catch (Exception e) {\n            Log_OC.d(TAG, \"not setting image as activity is destroyed\");\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled downloadIcon from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: downloadIcon\n\n        Method Code: blic static void downloadIcon(CurrentAccountProvider currentAccountProvider,\n                                    ClientFactory clientFactory,\n                                    Context context,\n                                    String iconUrl,\n                                    SimpleTarget imageView,\n                                    int placeholder) {\n        try {\n            if (Uri.parse(iconUrl).getEncodedPath().endsWith(\".svg\")) {\n                downloadSVGIcon(currentAccountProvider, clientFactory, context, iconUrl, imageView, placeholder);\n            } else {\n                downloadPNGIcon(context, iconUrl, imageView, placeholder);\n            }\n        } catch (Exception e) {\n            Log_OC.d(TAG, \"not setting image as activity is destroyed\");\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func downloadIcon(currentAccountProvider: CurrentAccountProvider,\n                         clientFactory: ClientFactory,\n                         context: Context,\n                         iconUrl: String,\n                         imageView: SimpleTarget,\n                         placeholder: Int) {\n    do {\n        if URL(string: iconUrl)?.pathExtension == \"svg\" {\n            downloadSVGIcon(currentAccountProvider: currentAccountProvider, clientFactory: clientFactory, context: context, iconUrl: iconUrl, imageView: imageView, placeholder: placeholder)\n        } else {\n            downloadPNGIcon(context: context, iconUrl: iconUrl, imageView: imageView, placeholder: placeholder)\n        }\n    } catch {\n        Log_OC.d(TAG, \"not setting image as activity is destroyed\")\n    }\n}\n```"
    },
    {
        "method_name": "downloadPNGIcon",
        "method_code": "ivate static void downloadPNGIcon(Context context, String iconUrl, SimpleTarget imageView, int placeholder) {\n        Glide\n            .with(context)\n            .load(iconUrl)\n            .centerCrop()\n            .placeholder(placeholder)\n            .error(placeholder)\n            .crossFade()\n            .into(imageView);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled downloadPNGIcon from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: downloadPNGIcon\n\n        Method Code: ivate static void downloadPNGIcon(Context context, String iconUrl, SimpleTarget imageView, int placeholder) {\n        Glide\n            .with(context)\n            .load(iconUrl)\n            .centerCrop()\n            .placeholder(placeholder)\n            .error(placeholder)\n            .crossFade()\n            .into(imageView);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport SDWebImage\n\nfunc downloadPNGIcon(context: UIViewController, iconUrl: String, imageView: UIImageView, placeholder: UIImage) {\n    imageView.sd_setImage(with: URL(string: iconUrl), placeholderImage: placeholder, options: [.continueInBackground, .scaleDownLargeImages], completed: nil)\n}\n```"
    },
    {
        "method_name": "downloadSVGIcon",
        "method_code": "ivate static void downloadSVGIcon(CurrentAccountProvider currentAccountProvider,\n                                        ClientFactory clientFactory,\n                                        Context context,\n                                        String iconUrl,\n                                        SimpleTarget imageView,\n                                        int placeholder) {\n        GenericRequestBuilder<Uri, InputStream, SVG, Drawable> requestBuilder = Glide.with(context)\n            .using(new CustomGlideUriLoader(currentAccountProvider.getUser(), clientFactory), InputStream.class)\n            .from(Uri.class)\n            .as(SVG.class)\n            .transcode(new SvgDrawableTranscoder(context), Drawable.class)\n            .sourceEncoder(new StreamEncoder())\n            .cacheDecoder(new FileToStreamDecoder<>(new SvgDecoder()))\n            .decoder(new SvgDecoder())\n            .placeholder(placeholder)\n            .error(placeholder)\n            .animate(android.R.anim.fade_in);\n\n\n        Uri uri = Uri.parse(iconUrl);\n        requestBuilder\n            .diskCacheStrategy(DiskCacheStrategy.SOURCE)\n            .load(uri)\n            .into(imageView);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled downloadSVGIcon from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: downloadSVGIcon\n\n        Method Code: ivate static void downloadSVGIcon(CurrentAccountProvider currentAccountProvider,\n                                        ClientFactory clientFactory,\n                                        Context context,\n                                        String iconUrl,\n                                        SimpleTarget imageView,\n                                        int placeholder) {\n        GenericRequestBuilder<Uri, InputStream, SVG, Drawable> requestBuilder = Glide.with(context)\n            .using(new CustomGlideUriLoader(currentAccountProvider.getUser(), clientFactory), InputStream.class)\n            .from(Uri.class)\n            .as(SVG.class)\n            .transcode(new SvgDrawableTranscoder(context), Drawable.class)\n            .sourceEncoder(new StreamEncoder())\n            .cacheDecoder(new FileToStreamDecoder<>(new SvgDecoder()))\n            .decoder(new SvgDecoder())\n            .placeholder(placeholder)\n            .error(placeholder)\n            .animate(android.R.anim.fade_in);\n\n\n        Uri uri = Uri.parse(iconUrl);\n        requestBuilder\n            .diskCacheStrategy(DiskCacheStrategy.SOURCE)\n            .load(uri)\n            .into(imageView);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport SDWebImageSVGCoder\n\nfunc downloadSVGIcon(currentAccountProvider: CurrentAccountProvider, clientFactory: ClientFactory, context: UIViewController, iconUrl: String, imageView: UIImageView, placeholder: UIImage) {\n    let svgCoder = SDImageSVGCoder.shared\n    SDImageCodersManager.shared.addCoder(svgCoder)\n    \n    let url = URL(string: iconUrl)\n    imageView.sd_setImage(with: url, placeholderImage: placeholder, options: .continueInBackground, context: [.imageTransformer: SDImageSVGTransformer(size: imageView.bounds.size)]) { (image, error, cacheType, url) in\n        if error != nil {\n            imageView.image = placeholder\n        }\n    }\n}\n```"
    },
    {
        "method_name": "downloadImageSynchronous",
        "method_code": "blic static Bitmap downloadImageSynchronous(Context context, String imageUrl) {\n        try {\n            return Glide.with(context)\n                .load(imageUrl)\n                .asBitmap()\n                .diskCacheStrategy(DiskCacheStrategy.NONE)\n                .skipMemoryCache(true)\n                .into(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)\n                .get();\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Could not download image \" + imageUrl);\n            return null;\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled downloadImageSynchronous from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: downloadImageSynchronous\n\n        Method Code: blic static Bitmap downloadImageSynchronous(Context context, String imageUrl) {\n        try {\n            return Glide.with(context)\n                .load(imageUrl)\n                .asBitmap()\n                .diskCacheStrategy(DiskCacheStrategy.NONE)\n                .skipMemoryCache(true)\n                .into(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)\n                .get();\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Could not download image \" + imageUrl);\n            return null;\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport SDWebImage\n\nfunc downloadImageSynchronous(imageUrl: String) -> UIImage? {\n    let semaphore = DispatchSemaphore(value: 0)\n    var downloadedImage: UIImage? = nil\n    \n    SDWebImageDownloader.shared.downloadImage(with: URL(string: imageUrl), options: .continueInBackground, progress: nil) { (image, data, error, finished) in\n        if let image = image {\n            downloadedImage = image\n        } else {\n            print(\"Could not download image \\(imageUrl)\")\n        }\n        semaphore.signal()\n    }\n    \n    _ = semaphore.wait(timeout: .distantFuture)\n    return downloadedImage\n}\n```"
    },
    {
        "method_name": "switchToSearchFragment",
        "method_code": "ivate static void switchToSearchFragment(Activity activity, SearchEvent event) {\n        if (activity instanceof FileDisplayActivity) {\n            EventBus.getDefault().post(event);\n        } else {\n            Intent recentlyAddedIntent = new Intent(activity.getBaseContext(), FileDisplayActivity.class);\n            recentlyAddedIntent.putExtra(OCFileListFragment.SEARCH_EVENT, event);\n            recentlyAddedIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            activity.startActivity(recentlyAddedIntent);\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled switchToSearchFragment from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: switchToSearchFragment\n\n        Method Code: ivate static void switchToSearchFragment(Activity activity, SearchEvent event) {\n        if (activity instanceof FileDisplayActivity) {\n            EventBus.getDefault().post(event);\n        } else {\n            Intent recentlyAddedIntent = new Intent(activity.getBaseContext(), FileDisplayActivity.class);\n            recentlyAddedIntent.putExtra(OCFileListFragment.SEARCH_EVENT, event);\n            recentlyAddedIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            activity.startActivity(recentlyAddedIntent);\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func switchToSearchFragment(activity: Activity, event: SearchEvent) {\n    if activity is FileDisplayActivity {\n        EventBus.getDefault().post(event)\n    } else {\n        let recentlyAddedIntent = Intent(context: activity.baseContext, cls: FileDisplayActivity.self)\n        recentlyAddedIntent.putExtra(OCFileListFragment.SEARCH_EVENT, event)\n        recentlyAddedIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n        activity.startActivity(recentlyAddedIntent)\n    }\n}\n```"
    },
    {
        "method_name": "getData",
        "method_code": "blic static String getData(InputStream inputStream) {\n\n        BufferedReader buffreader = new BufferedReader(new InputStreamReader(inputStream, Charset.defaultCharset()));\n        String line;\n        StringBuilder text = new StringBuilder();\n        try {\n            while ((line = buffreader.readLine()) != null) {\n                text.append(line);\n                text.append('\\n');\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, e.getMessage());\n        }\n        return text.toString();\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getData from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getData\n\n        Method Code: blic static String getData(InputStream inputStream) {\n\n        BufferedReader buffreader = new BufferedReader(new InputStreamReader(inputStream, Charset.defaultCharset()));\n        String line;\n        StringBuilder text = new StringBuilder();\n        try {\n            while ((line = buffreader.readLine()) != null) {\n                text.append(line);\n                text.append('\\n');\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, e.getMessage());\n        }\n        return text.toString();\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getData(inputStream: InputStream) -> String {\n    let reader = InputStreamReader(inputStream: inputStream, encoding: .utf8)\n    var text = \"\"\n    reader.open()\n    defer { reader.close() }\n    \n    let buffer = UnsafeMutablePointer<UInt8>.allocate(capacity: 1024)\n    defer { buffer.deallocate() }\n    \n    while reader.hasBytesAvailable {\n        let bytesRead = reader.read(buffer, maxLength: 1024)\n        if bytesRead < 0 {\n            if let error = reader.streamError {\n                print(\"Error: \\(error.localizedDescription)\")\n            }\n            break\n        }\n        if let line = String(bytesNoCopy: buffer, length: bytesRead, encoding: .utf8, freeWhenDone: false) {\n            text.append(line)\n            text.append(\"\\n\")\n        }\n    }\n    \n    return text\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(Activity activity, @StringRes int messageResource) {\n        return showSnackMessage(activity.findViewById(android.R.id.content), messageResource);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(Activity activity, @StringRes int messageResource) {\n        return showSnackMessage(activity.findViewById(android.R.id.content), messageResource);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\nfunc showSnackMessage(activity: UIViewController, messageResource: String) -> Snackbar {\n    return showSnackMessage(view: activity.view, messageResource: messageResource)\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(Activity activity, String message) {\n        final Snackbar snackbar = Snackbar.make(activity.findViewById(android.R.id.content), message, Snackbar.LENGTH_LONG);\n        var fab = findFABView(activity);\n        if (fab != null && fab.getVisibility() == View.VISIBLE) {\n            snackbar.setAnchorView(fab);\n        }\n        snackbar.show();\n        return snackbar;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(Activity activity, String message) {\n        final Snackbar snackbar = Snackbar.make(activity.findViewById(android.R.id.content), message, Snackbar.LENGTH_LONG);\n        var fab = findFABView(activity);\n        if (fab != null && fab.getVisibility() == View.VISIBLE) {\n            snackbar.setAnchorView(fab);\n        }\n        snackbar.show();\n        return snackbar;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\n@discardableResult\nfunc showSnackMessage(activity: UIViewController, message: String) -> Snackbar {\n    let snackbar = Snackbar(message: message, duration: .lengthLong)\n    if let fab = findFABView(activity: activity), fab.isHidden == false {\n        snackbar.anchorView = fab\n    }\n    snackbar.show()\n    return snackbar\n}\n\nfunc findFABView(activity: UIViewController) -> UIView? {\n    // Implement the logic to find the FAB view in the activity\n    return nil\n}\n```"
    },
    {
        "method_name": "findFABView",
        "method_code": "ivate static View findFABView(Activity activity) {\n        return activity.findViewById(R.id.fab_main);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled findFABView from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: findFABView\n\n        Method Code: ivate static View findFABView(Activity activity) {\n        return activity.findViewById(R.id.fab_main);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func findFABView(activity: UIViewController) -> UIView? {\n    return activity.view.viewWithTag(R.id.fab_main)\n}\n```"
    },
    {
        "method_name": "findFABView",
        "method_code": "ivate static View findFABView(View view) {\n        return view.findViewById(R.id.fab_main);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled findFABView from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: findFABView\n\n        Method Code: ivate static View findFABView(View view) {\n        return view.findViewById(R.id.fab_main);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func findFABView(in view: UIView) -> UIView? {\n    return view.viewWithTag(R.id.fab_main)\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(View view, @StringRes int messageResource) {\n        final Snackbar snackbar = Snackbar.make(view, messageResource, Snackbar.LENGTH_LONG);\n        var fab = findFABView(view.getRootView());\n        if (fab != null && fab.getVisibility() == View.VISIBLE) {\n            snackbar.setAnchorView(fab);\n        }\n        snackbar.show();\n        return snackbar;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(View view, @StringRes int messageResource) {\n        final Snackbar snackbar = Snackbar.make(view, messageResource, Snackbar.LENGTH_LONG);\n        var fab = findFABView(view.getRootView());\n        if (fab != null && fab.getVisibility() == View.VISIBLE) {\n            snackbar.setAnchorView(fab);\n        }\n        snackbar.show();\n        return snackbar;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\nfunc showSnackMessage(view: UIView, messageResource: String) -> Snackbar {\n    let snackbar = Snackbar.make(view: view, message: messageResource, duration: .lengthLong)\n    if let fab = findFABView(view: view.rootView), fab.isVisible {\n        snackbar.anchorView = fab\n    }\n    snackbar.show()\n    return snackbar\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(View view, String message) {\n        final Snackbar snackbar = Snackbar.make(view, message, Snackbar.LENGTH_LONG);\n        snackbar.show();\n        return snackbar;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(View view, String message) {\n        final Snackbar snackbar = Snackbar.make(view, message, Snackbar.LENGTH_LONG);\n        snackbar.show();\n        return snackbar;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport SnackBar_swift\n\nfunc showSnackMessage(view: UIView, message: String) -> SnackBar {\n    let snackbar = SnackBar.make(in: view, message: message, duration: .lengthLong)\n    snackbar.show()\n    return snackbar\n}\n```"
    },
    {
        "method_name": "createSnackbar",
        "method_code": "blic static Snackbar createSnackbar(View view, @StringRes int messageResource, int length) {\n        return Snackbar.make(view, messageResource, length);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled createSnackbar from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: createSnackbar\n\n        Method Code: blic static Snackbar createSnackbar(View view, @StringRes int messageResource, int length) {\n        return Snackbar.make(view, messageResource, length);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\nfunc createSnackbar(view: UIView, messageResource: String, length: SnackbarDuration) -> Snackbar {\n    return Snackbar.make(view: view, message: messageResource, duration: length)\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(Activity activity, @StringRes int messageResource, Object... formatArgs) {\n        return showSnackMessage(activity, activity.findViewById(android.R.id.content), messageResource, formatArgs);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(Activity activity, @StringRes int messageResource, Object... formatArgs) {\n        return showSnackMessage(activity, activity.findViewById(android.R.id.content), messageResource, formatArgs);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func showSnackMessage(activity: UIViewController, messageResource: String, formatArgs: CVarArg...) -> Snackbar {\n    return showSnackMessage(activity: activity, view: activity.view, messageResource: messageResource, formatArgs: formatArgs)\n}\n```"
    },
    {
        "method_name": "showSnackMessage",
        "method_code": "blic static Snackbar showSnackMessage(Context context, View view, @StringRes int messageResource, Object... formatArgs) {\n        final Snackbar snackbar = Snackbar.make(\n            view,\n            String.format(context.getString(messageResource, formatArgs)),\n            Snackbar.LENGTH_LONG);\n        snackbar\n            .show();\n        return snackbar;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showSnackMessage from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showSnackMessage\n\n        Method Code: blic static Snackbar showSnackMessage(Context context, View view, @StringRes int messageResource, Object... formatArgs) {\n        final Snackbar snackbar = Snackbar.make(\n            view,\n            String.format(context.getString(messageResource, formatArgs)),\n            Snackbar.LENGTH_LONG);\n        snackbar\n            .show();\n        return snackbar;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\nfunc showSnackMessage(context: UIViewController, view: UIView, messageResource: String, formatArgs: CVarArg...) -> Snackbar {\n    let message = String(format: NSLocalizedString(messageResource, comment: \"\"), arguments: formatArgs)\n    let snackbar = Snackbar(message: message, duration: .lengthLong)\n    snackbar.show()\n    return snackbar\n}\n```"
    },
    {
        "method_name": "useCompatVectorIfNeeded",
        "method_code": "blic static void useCompatVectorIfNeeded() {\n        try {\n            @SuppressLint(\"RestrictedApi\") AppCompatDrawableManager drawableManager = AppCompatDrawableManager.get();\n            Class<?> inflateDelegateClass = Class.forName(\"android.support.v7.widget.AppCompatDrawableManager$InflateDelegate\");\n            Class<?> vdcInflateDelegateClass = Class.forName(\"android.support.v7.widget.AppCompatDrawableManager$VdcInflateDelegate\");\n\n            Constructor<?> constructor = vdcInflateDelegateClass.getDeclaredConstructor();\n            constructor.setAccessible(true);\n            Object vdcInflateDelegate = constructor.newInstance();\n\n            Class<?> args[] = {String.class, inflateDelegateClass};\n            Method addDelegate = AppCompatDrawableManager.class.getDeclaredMethod(\"addDelegate\", args);\n            addDelegate.setAccessible(true);\n            addDelegate.invoke(drawableManager, \"vector\", vdcInflateDelegate);\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Failed to use reflection to enable proper vector scaling\");\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled useCompatVectorIfNeeded from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: useCompatVectorIfNeeded\n\n        Method Code: blic static void useCompatVectorIfNeeded() {\n        try {\n            @SuppressLint(\"RestrictedApi\") AppCompatDrawableManager drawableManager = AppCompatDrawableManager.get();\n            Class<?> inflateDelegateClass = Class.forName(\"android.support.v7.widget.AppCompatDrawableManager$InflateDelegate\");\n            Class<?> vdcInflateDelegateClass = Class.forName(\"android.support.v7.widget.AppCompatDrawableManager$VdcInflateDelegate\");\n\n            Constructor<?> constructor = vdcInflateDelegateClass.getDeclaredConstructor();\n            constructor.setAccessible(true);\n            Object vdcInflateDelegate = constructor.newInstance();\n\n            Class<?> args[] = {String.class, inflateDelegateClass};\n            Method addDelegate = AppCompatDrawableManager.class.getDeclaredMethod(\"addDelegate\", args);\n            addDelegate.setAccessible(true);\n            addDelegate.invoke(drawableManager, \"vector\", vdcInflateDelegate);\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Failed to use reflection to enable proper vector scaling\");\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nclass DisplayUtils {\n    static func useCompatVectorIfNeeded() {\n        do {\n            let drawableManagerClass = NSClassFromString(\"AppCompatDrawableManager\") as? NSObject.Type\n            let drawableManager = drawableManagerClass?.perform(NSSelectorFromString(\"get\")).takeUnretainedValue()\n\n            let inflateDelegateClass = NSClassFromString(\"android.support.v7.widget.AppCompatDrawableManager$InflateDelegate\")\n            let vdcInflateDelegateClass = NSClassFromString(\"android.support.v7.widget.AppCompatDrawableManager$VdcInflateDelegate\")\n\n            let constructor = vdcInflateDelegateClass?.perform(NSSelectorFromString(\"init\")).takeUnretainedValue()\n            let vdcInflateDelegate = constructor as AnyObject\n\n            let addDelegateSelector = NSSelectorFromString(\"addDelegate:withDelegate:\")\n            let addDelegateMethod = drawableManagerClass?.instanceMethod(for: addDelegateSelector)\n\n            let addDelegateIMP = addDelegateMethod?.getImplementation()\n            typealias AddDelegateFunction = @convention(c) (AnyObject, Selector, String, AnyObject) -> Void\n            let addDelegate = unsafeBitCast(addDelegateIMP, to: AddDelegateFunction.self)\n\n            addDelegate(drawableManager!, addDelegateSelector, \"vector\", vdcInflateDelegate)\n        } catch {\n            print(\"Failed to use reflection to enable proper vector scaling\")\n        }\n    }\n}\n```"
    },
    {
        "method_name": "convertDpToPixel",
        "method_code": "blic static int convertDpToPixel(float dp, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n\n        return (int) (dp * ((float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT));\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertDpToPixel from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: convertDpToPixel\n\n        Method Code: blic static int convertDpToPixel(float dp, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n\n        return (int) (dp * ((float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT));\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc convertDpToPixel(dp: CGFloat, context: UIViewController) -> Int {\n    let scale = context.view.traitCollection.displayScale\n    return Int(dp * scale)\n}\n```"
    },
    {
        "method_name": "convertPixelToDp",
        "method_code": "blic static float convertPixelToDp(int px, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n\n        return px * (DisplayMetrics.DENSITY_DEFAULT / (float) metrics.densityDpi);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertPixelToDp from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: convertPixelToDp\n\n        Method Code: blic static float convertPixelToDp(int px, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n\n        return px * (DisplayMetrics.DENSITY_DEFAULT / (float) metrics.densityDpi);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc convertPixelToDp(px: Int, context: UIViewController) -> Float {\n    let scale = UIScreen.main.scale\n    return Float(px) * (Float(UIScreen.main.nativeScale) / scale)\n}\n```"
    },
    {
        "method_name": "showServerOutdatedSnackbar",
        "method_code": "atic public void showServerOutdatedSnackbar(Activity activity, int length) {\n        Snackbar.make(activity.findViewById(android.R.id.content),\n                      R.string.outdated_server, length)\n            .setAction(R.string.dismiss, v -> {\n            })\n            .show();\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showServerOutdatedSnackbar from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showServerOutdatedSnackbar\n\n        Method Code: atic public void showServerOutdatedSnackbar(Activity activity, int length) {\n        Snackbar.make(activity.findViewById(android.R.id.content),\n                      R.string.outdated_server, length)\n            .setAction(R.string.dismiss, v -> {\n            })\n            .show();\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport Snackbar\n\nfunc showServerOutdatedSnackbar(activity: UIViewController, length: SnackbarDuration) {\n    let snackbar = Snackbar(message: NSLocalizedString(\"outdated_server\", comment: \"\"), duration: length)\n    snackbar.actionText = NSLocalizedString(\"dismiss\", comment: \"\")\n    snackbar.actionHandler = { _ in }\n    snackbar.show()\n}\n```"
    },
    {
        "method_name": "startLinkIntent",
        "method_code": "atic public void startLinkIntent(Activity activity, @StringRes int link) {\n        startLinkIntent(activity, activity.getString(link));\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled startLinkIntent from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: startLinkIntent\n\n        Method Code: atic public void startLinkIntent(Activity activity, @StringRes int link) {\n        startLinkIntent(activity, activity.getString(link));\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func startLinkIntent(activity: UIViewController, link: String) {\n    startLinkIntent(activity: activity, link: NSLocalizedString(link, comment: \"\"))\n}\n```"
    },
    {
        "method_name": "startLinkIntent",
        "method_code": "atic public void startLinkIntent(Activity activity, String url) {\n        if (!TextUtils.isEmpty(url)) {\n            startLinkIntent(activity, Uri.parse(url));\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled startLinkIntent from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: startLinkIntent\n\n        Method Code: atic public void startLinkIntent(Activity activity, String url) {\n        if (!TextUtils.isEmpty(url)) {\n            startLinkIntent(activity, Uri.parse(url));\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc startLinkIntent(activity: UIViewController, url: String?) {\n    if let urlString = url, !urlString.isEmpty, let url = URL(string: urlString) {\n        startLinkIntent(activity: activity, url: url)\n    }\n}\n```"
    },
    {
        "method_name": "startLinkIntent",
        "method_code": "atic public void startLinkIntent(Activity activity, Uri uri) {\n        Intent intent = new Intent(Intent.ACTION_VIEW, uri);\n        DisplayUtils.startIntentIfAppAvailable(intent, activity, R.string.no_browser_available);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled startLinkIntent from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: startLinkIntent\n\n        Method Code: atic public void startLinkIntent(Activity activity, Uri uri) {\n        Intent intent = new Intent(Intent.ACTION_VIEW, uri);\n        DisplayUtils.startIntentIfAppAvailable(intent, activity, R.string.no_browser_available);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc startLinkIntent(activity: UIViewController, uri: URL) {\n    if UIApplication.shared.canOpenURL(uri) {\n        UIApplication.shared.open(uri, options: [:], completionHandler: nil)\n    } else {\n        let alert = UIAlertController(title: nil, message: NSLocalizedString(\"no_browser_available\", comment: \"\"), preferredStyle: .alert)\n        alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))\n        activity.present(alert, animated: true, completion: nil)\n    }\n}\n```"
    },
    {
        "method_name": "startIntentIfAppAvailable",
        "method_code": "atic public void startIntentIfAppAvailable(Intent intent, Activity activity, @StringRes int error) {\n        if (intent.resolveActivity(activity.getPackageManager()) != null) {\n            activity.startActivity(intent);\n        } else {\n            DisplayUtils.showSnackMessage(activity, error);\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled startIntentIfAppAvailable from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: startIntentIfAppAvailable\n\n        Method Code: atic public void startIntentIfAppAvailable(Intent intent, Activity activity, @StringRes int error) {\n        if (intent.resolveActivity(activity.getPackageManager()) != null) {\n            activity.startActivity(intent);\n        } else {\n            DisplayUtils.showSnackMessage(activity, error);\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc startIntentIfAppAvailable(intent: URL, activity: UIViewController, error: String) {\n    if UIApplication.shared.canOpenURL(intent) {\n        UIApplication.shared.open(intent, options: [:], completionHandler: nil)\n    } else {\n        DisplayUtils.showSnackMessage(activity: activity, message: error)\n    }\n}\n```"
    },
    {
        "method_name": "showErrorAndFinishActivity",
        "method_code": "atic public void showErrorAndFinishActivity(Activity activity, String errorMessage) {\n        Toast.makeText(activity, errorMessage, Toast.LENGTH_LONG).show();\n        activity.finish();\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled showErrorAndFinishActivity from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: showErrorAndFinishActivity\n\n        Method Code: atic public void showErrorAndFinishActivity(Activity activity, String errorMessage) {\n        Toast.makeText(activity, errorMessage, Toast.LENGTH_LONG).show();\n        activity.finish();\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc showErrorAndFinishActivity(activity: UIViewController, errorMessage: String) {\n    let alert = UIAlertController(title: nil, message: errorMessage, preferredStyle: .alert)\n    alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { _ in\n        activity.dismiss(animated: true, completion: nil)\n    }))\n    activity.present(alert, animated: true, completion: nil)\n}\n```"
    },
    {
        "method_name": "openSortingOrderDialogFragment",
        "method_code": "atic public void openSortingOrderDialogFragment(FragmentManager supportFragmentManager, FileSortOrder sortOrder) {\n        FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction();\n        fragmentTransaction.addToBackStack(null);\n\n        SortingOrderDialogFragment.newInstance(sortOrder).show(fragmentTransaction, SORTING_ORDER_FRAGMENT);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled openSortingOrderDialogFragment from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: openSortingOrderDialogFragment\n\n        Method Code: atic public void openSortingOrderDialogFragment(FragmentManager supportFragmentManager, FileSortOrder sortOrder) {\n        FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction();\n        fragmentTransaction.addToBackStack(null);\n\n        SortingOrderDialogFragment.newInstance(sortOrder).show(fragmentTransaction, SORTING_ORDER_FRAGMENT);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func openSortingOrderDialogFragment(supportFragmentManager: FragmentManager, sortOrder: FileSortOrder) {\n    let fragmentTransaction = supportFragmentManager.beginTransaction()\n    fragmentTransaction.addToBackStack(nil)\n    \n    SortingOrderDialogFragment.newInstance(sortOrder).show(fragmentTransaction, SORTING_ORDER_FRAGMENT)\n}\n```"
    },
    {
        "method_name": "getSortOrderStringId",
        "method_code": "blic static @StringRes int getSortOrderStringId(FileSortOrder sortOrder) {\n        switch (sortOrder.name) {\n            case SORT_Z_TO_A_ID:\n                return R.string.menu_item_sort_by_name_z_a;\n            case SORT_NEW_TO_OLD_ID:\n                return R.string.menu_item_sort_by_date_newest_first;\n            case SORT_OLD_TO_NEW_ID:\n                return R.string.menu_item_sort_by_date_oldest_first;\n            case SORT_BIG_TO_SMALL_ID:\n                return R.string.menu_item_sort_by_size_biggest_first;\n            case SORT_SMALL_TO_BIG_ID:\n                return R.string.menu_item_sort_by_size_smallest_first;\n            case SORT_A_TO_Z_ID:\n            default:\n                return R.string.menu_item_sort_by_name_a_z;\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getSortOrderStringId from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getSortOrderStringId\n\n        Method Code: blic static @StringRes int getSortOrderStringId(FileSortOrder sortOrder) {\n        switch (sortOrder.name) {\n            case SORT_Z_TO_A_ID:\n                return R.string.menu_item_sort_by_name_z_a;\n            case SORT_NEW_TO_OLD_ID:\n                return R.string.menu_item_sort_by_date_newest_first;\n            case SORT_OLD_TO_NEW_ID:\n                return R.string.menu_item_sort_by_date_oldest_first;\n            case SORT_BIG_TO_SMALL_ID:\n                return R.string.menu_item_sort_by_size_biggest_first;\n            case SORT_SMALL_TO_BIG_ID:\n                return R.string.menu_item_sort_by_size_smallest_first;\n            case SORT_A_TO_Z_ID:\n            default:\n                return R.string.menu_item_sort_by_name_a_z;\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSortOrderStringId(sortOrder: FileSortOrder) -> Int {\n    switch sortOrder.name {\n    case SORT_Z_TO_A_ID:\n        return R.string.menu_item_sort_by_name_z_a\n    case SORT_NEW_TO_OLD_ID:\n        return R.string.menu_item_sort_by_date_newest_first\n    case SORT_OLD_TO_NEW_ID:\n        return R.string.menu_item_sort_by_date_oldest_first\n    case SORT_BIG_TO_SMALL_ID:\n        return R.string.menu_item_sort_by_size_biggest_first\n    case SORT_SMALL_TO_BIG_ID:\n        return R.string.menu_item_sort_by_size_smallest_first\n    case SORT_A_TO_Z_ID:\n        fallthrough\n    default:\n        return R.string.menu_item_sort_by_name_a_z\n    }\n}\n```"
    },
    {
        "method_name": "getDateByPattern",
        "method_code": "blic static String getDateByPattern(long timestamp, String pattern) {\n        return getDateByPattern(timestamp, null, pattern);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDateByPattern from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getDateByPattern\n\n        Method Code: blic static String getDateByPattern(long timestamp, String pattern) {\n        return getDateByPattern(timestamp, null, pattern);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func getDateByPattern(timestamp: Int64, pattern: String) -> String {\n    return getDateByPattern(timestamp: timestamp, timeZone: nil, pattern: pattern)\n}\n```"
    },
    {
        "method_name": "getDateByPattern",
        "method_code": "blic static String getDateByPattern(long timestamp, @Nullable Context context, String pattern) {\n        DateFormat df;\n        if (context == null) {\n            context = MainApp.getAppContext();\n        }\n        df = new SimpleDateFormat(pattern, context.getResources().getConfiguration().locale);\n        df.setTimeZone(TimeZone.getTimeZone(TimeZone.getDefault().getID()));\n\n        return df.format(timestamp);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDateByPattern from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getDateByPattern\n\n        Method Code: blic static String getDateByPattern(long timestamp, @Nullable Context context, String pattern) {\n        DateFormat df;\n        if (context == null) {\n            context = MainApp.getAppContext();\n        }\n        df = new SimpleDateFormat(pattern, context.getResources().getConfiguration().locale);\n        df.setTimeZone(TimeZone.getTimeZone(TimeZone.getDefault().getID()));\n\n        return df.format(timestamp);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getDateByPattern(timestamp: TimeInterval, context: Locale?, pattern: String) -> String {\n    let locale = context ?? Locale.current\n    let dateFormatter = DateFormatter()\n    dateFormatter.dateFormat = pattern\n    dateFormatter.locale = locale\n    dateFormatter.timeZone = TimeZone.current\n\n    let date = Date(timeIntervalSince1970: timestamp)\n    return dateFormatter.string(from: date)\n}\n```"
    },
    {
        "method_name": "setThumbnail",
        "method_code": "blic static void setThumbnail(OCFile file,\n                                    ImageView thumbnailView,\n                                    User user,\n                                    FileDataStorageManager storageManager,\n                                    List<ThumbnailsCacheManager.ThumbnailGenerationTask> asyncTasks,\n                                    boolean gridView,\n                                    Context context,\n                                    LoaderImageView shimmerThumbnail,\n                                    AppPreferences preferences,\n                                    ViewThemeUtils viewThemeUtils,\n                                    SyncedFolderProvider syncedFolderProvider) {\n        if (file.isFolder()) {\n            stopShimmer(shimmerThumbnail, thumbnailView);\n\n            boolean isAutoUploadFolder = SyncedFolderProvider.isAutoUploadFolder(syncedFolderProvider, file, user);\n            boolean isDarkModeActive = preferences.isDarkModeEnabled();\n\n            Integer overlayIconId = file.getFileOverlayIconId(isAutoUploadFolder);\n            LayerDrawable fileIcon = MimeTypeUtil.getFolderIcon(isDarkModeActive, overlayIconId, context, viewThemeUtils);\n            thumbnailView.setImageDrawable(fileIcon);\n        } else {\n            if (file.getRemoteId() != null && file.isPreviewAvailable()) {\n                // Thumbnail in cache?\n                Bitmap thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(\n                    ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId());\n\n                if (thumbnail != null && !file.isUpdateThumbnailNeeded()) {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n\n                    if (MimeTypeUtil.isVideo(file)) {\n                        Bitmap withOverlay = ThumbnailsCacheManager.addVideoOverlay(thumbnail, context);\n                        thumbnailView.setImageBitmap(withOverlay);\n                    } else {\n                        if (gridView) {\n                            BitmapUtils.setRoundedBitmapForGridMode(thumbnail, thumbnailView);\n                        } else {\n                            BitmapUtils.setRoundedBitmap(thumbnail, thumbnailView);\n                        }\n                    }\n                } else {\n                    generateNewThumbnail(file, thumbnailView, user, storageManager, asyncTasks, gridView, context, shimmerThumbnail, preferences, viewThemeUtils);\n                }\n\n                if (\"image/png\".equalsIgnoreCase(file.getMimeType())) {\n                    thumbnailView.setBackgroundColor(context.getResources().getColor(R.color.bg_default));\n                }\n            } else {\n                if (file.getRemoteId() != null) {\n                    generateNewThumbnail(file, thumbnailView, user, storageManager, asyncTasks, gridView, context, shimmerThumbnail, preferences, viewThemeUtils);\n                } else {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                    thumbnailView.setImageDrawable(MimeTypeUtil.getFileTypeIcon(file.getMimeType(),\n                                                                                file.getFileName(),\n                                                                                context,\n                                                                                viewThemeUtils));\n                }\n            }\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled setThumbnail from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: setThumbnail\n\n        Method Code: blic static void setThumbnail(OCFile file,\n                                    ImageView thumbnailView,\n                                    User user,\n                                    FileDataStorageManager storageManager,\n                                    List<ThumbnailsCacheManager.ThumbnailGenerationTask> asyncTasks,\n                                    boolean gridView,\n                                    Context context,\n                                    LoaderImageView shimmerThumbnail,\n                                    AppPreferences preferences,\n                                    ViewThemeUtils viewThemeUtils,\n                                    SyncedFolderProvider syncedFolderProvider) {\n        if (file.isFolder()) {\n            stopShimmer(shimmerThumbnail, thumbnailView);\n\n            boolean isAutoUploadFolder = SyncedFolderProvider.isAutoUploadFolder(syncedFolderProvider, file, user);\n            boolean isDarkModeActive = preferences.isDarkModeEnabled();\n\n            Integer overlayIconId = file.getFileOverlayIconId(isAutoUploadFolder);\n            LayerDrawable fileIcon = MimeTypeUtil.getFolderIcon(isDarkModeActive, overlayIconId, context, viewThemeUtils);\n            thumbnailView.setImageDrawable(fileIcon);\n        } else {\n            if (file.getRemoteId() != null && file.isPreviewAvailable()) {\n                // Thumbnail in cache?\n                Bitmap thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(\n                    ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId());\n\n                if (thumbnail != null && !file.isUpdateThumbnailNeeded()) {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n\n                    if (MimeTypeUtil.isVideo(file)) {\n                        Bitmap withOverlay = ThumbnailsCacheManager.addVideoOverlay(thumbnail, context);\n                        thumbnailView.setImageBitmap(withOverlay);\n                    } else {\n                        if (gridView) {\n                            BitmapUtils.setRoundedBitmapForGridMode(thumbnail, thumbnailView);\n                        } else {\n                            BitmapUtils.setRoundedBitmap(thumbnail, thumbnailView);\n                        }\n                    }\n                } else {\n                    generateNewThumbnail(file, thumbnailView, user, storageManager, asyncTasks, gridView, context, shimmerThumbnail, preferences, viewThemeUtils);\n                }\n\n                if (\"image/png\".equalsIgnoreCase(file.getMimeType())) {\n                    thumbnailView.setBackgroundColor(context.getResources().getColor(R.color.bg_default));\n                }\n            } else {\n                if (file.getRemoteId() != null) {\n                    generateNewThumbnail(file, thumbnailView, user, storageManager, asyncTasks, gridView, context, shimmerThumbnail, preferences, viewThemeUtils);\n                } else {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                    thumbnailView.setImageDrawable(MimeTypeUtil.getFileTypeIcon(file.getMimeType(),\n                                                                                file.getFileName(),\n                                                                                context,\n                                                                                viewThemeUtils));\n                }\n            }\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc setThumbnail(file: OCFile,\n                  thumbnailView: UIImageView,\n                  user: User,\n                  storageManager: FileDataStorageManager,\n                  asyncTasks: [ThumbnailsCacheManager.ThumbnailGenerationTask],\n                  gridView: Bool,\n                  context: Context,\n                  shimmerThumbnail: LoaderImageView,\n                  preferences: AppPreferences,\n                  viewThemeUtils: ViewThemeUtils,\n                  syncedFolderProvider: SyncedFolderProvider) {\n    if file.isFolder() {\n        stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n\n        let isAutoUploadFolder = SyncedFolderProvider.isAutoUploadFolder(syncedFolderProvider, file: file, user: user)\n        let isDarkModeActive = preferences.isDarkModeEnabled()\n\n        let overlayIconId = file.getFileOverlayIconId(isAutoUploadFolder: isAutoUploadFolder)\n        let fileIcon = MimeTypeUtil.getFolderIcon(isDarkModeActive: isDarkModeActive, overlayIconId: overlayIconId, context: context, viewThemeUtils: viewThemeUtils)\n        thumbnailView.image = fileIcon\n    } else {\n        if let remoteId = file.getRemoteId(), file.isPreviewAvailable() {\n            // Thumbnail in cache?\n            let thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(key: ThumbnailsCacheManager.PREFIX_THUMBNAIL + remoteId)\n\n            if let thumbnail = thumbnail, !file.isUpdateThumbnailNeeded() {\n                stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n\n                if MimeTypeUtil.isVideo(file: file) {\n                    let withOverlay = ThumbnailsCacheManager.addVideoOverlay(thumbnail: thumbnail, context: context)\n                    thumbnailView.image = withOverlay\n                } else {\n                    if gridView {\n                        BitmapUtils.setRoundedBitmapForGridMode(thumbnail: thumbnail, imageView: thumbnailView)\n                    } else {\n                        BitmapUtils.setRoundedBitmap(thumbnail: thumbnail, imageView: thumbnailView)\n                    }\n                }\n            } else {\n                generateNewThumbnail(file: file, thumbnailView: thumbnailView, user: user, storageManager: storageManager, asyncTasks: asyncTasks, gridView: gridView, context: context, shimmerThumbnail: shimmerThumbnail, preferences: preferences, viewThemeUtils: viewThemeUtils)\n            }\n\n            if file.getMimeType().caseInsensitiveCompare(\"image/png\") == .orderedSame {\n                thumbnailView.backgroundColor = context.resources.getColor(R.color.bg_default)\n            }\n        } else {\n            if file.getRemoteId() != nil {\n                generateNewThumbnail(file: file, thumbnailView: thumbnailView, user: user, storageManager: storageManager, asyncTasks: asyncTasks, gridView: gridView, context: context, shimmerThumbnail: shimmerThumbnail, preferences: preferences, viewThemeUtils: viewThemeUtils)\n            } else {\n                stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n                thumbnailView.image = MimeTypeUtil.getFileTypeIcon(mimeType: file.getMimeType(), fileName: file.getFileName(), context: context, viewThemeUtils: viewThemeUtils)\n            }\n        }\n    }\n}\n```"
    },
    {
        "method_name": "generateNewThumbnail",
        "method_code": "ivate static void generateNewThumbnail(OCFile file,\n                                             ImageView thumbnailView,\n                                             User user,\n                                             FileDataStorageManager storageManager,\n                                             List<ThumbnailsCacheManager.ThumbnailGenerationTask> asyncTasks,\n                                             boolean gridView,\n                                             Context context,\n                                             LoaderImageView shimmerThumbnail,\n                                             AppPreferences preferences,\n                                             ViewThemeUtils viewThemeUtils) {\n        if (!ThumbnailsCacheManager.cancelPotentialThumbnailWork(file, thumbnailView)) {\n            return;\n        }\n\n        Bitmap thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(\n            ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId());\n\n        if (thumbnail != null) {\n            // If thumbnail is already in cache, display it immediately\n            thumbnailView.setImageBitmap(thumbnail);\n            stopShimmer(shimmerThumbnail, thumbnailView);\n            return;\n        }\n\n        for (ThumbnailsCacheManager.ThumbnailGenerationTask task : asyncTasks) {\n            if (file.getRemoteId() != null && task.getImageKey() != null &&\n                file.getRemoteId().equals(task.getImageKey())) {\n                return;\n            }\n        }\n\n        try {\n            final ThumbnailsCacheManager.ThumbnailGenerationTask task =\n                new ThumbnailsCacheManager.ThumbnailGenerationTask(thumbnailView,\n                                                                   storageManager,\n                                                                   user,\n                                                                   asyncTasks,\n                                                                   gridView,\n                                                                   file.getRemoteId());\n            Drawable drawable = MimeTypeUtil.getFileTypeIcon(file.getMimeType(),\n                                                             file.getFileName(),\n                                                             context,\n                                                             viewThemeUtils);\n            if (drawable == null) {\n                drawable = ResourcesCompat.getDrawable(context.getResources(),\n                                                       R.drawable.file_image,\n                                                       null);\n            }\n            if (drawable == null) {\n                drawable = new ColorDrawable(Color.GRAY);\n            }\n\n            int px = ThumbnailsCacheManager.getThumbnailDimension();\n            thumbnail = BitmapUtils.drawableToBitmap(drawable, px, px);\n            final ThumbnailsCacheManager.AsyncThumbnailDrawable asyncDrawable =\n                new ThumbnailsCacheManager.AsyncThumbnailDrawable(context.getResources(),\n                                                                  thumbnail, task);\n\n            if (shimmerThumbnail != null) {\n                shimmerThumbnail.postDelayed(() -> {\n                    if (thumbnailView.getDrawable() == null) {\n                        if (gridView) {\n                            configShimmerGridImageSize(shimmerThumbnail, preferences.getGridColumns());\n                        }\n                        startShimmer(shimmerThumbnail, thumbnailView);\n                    }\n                }, 100);\n            }\n\n            task.setListener(new ThumbnailsCacheManager.ThumbnailGenerationTask.Listener() {\n                @Override\n                public void onSuccess() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n\n                @Override\n                public void onError() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n            });\n\n            thumbnailView.setImageDrawable(asyncDrawable);\n            asyncTasks.add(task);\n            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,\n                                   new ThumbnailsCacheManager.ThumbnailGenerationTaskObject(file,\n                                                                                            file.getRemoteId()));\n        } catch (IllegalArgumentException e) {\n            Log_OC.d(TAG, \"ThumbnailGenerationTask : \" + e.getMessage());\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled generateNewThumbnail from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: generateNewThumbnail\n\n        Method Code: ivate static void generateNewThumbnail(OCFile file,\n                                             ImageView thumbnailView,\n                                             User user,\n                                             FileDataStorageManager storageManager,\n                                             List<ThumbnailsCacheManager.ThumbnailGenerationTask> asyncTasks,\n                                             boolean gridView,\n                                             Context context,\n                                             LoaderImageView shimmerThumbnail,\n                                             AppPreferences preferences,\n                                             ViewThemeUtils viewThemeUtils) {\n        if (!ThumbnailsCacheManager.cancelPotentialThumbnailWork(file, thumbnailView)) {\n            return;\n        }\n\n        Bitmap thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(\n            ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId());\n\n        if (thumbnail != null) {\n            // If thumbnail is already in cache, display it immediately\n            thumbnailView.setImageBitmap(thumbnail);\n            stopShimmer(shimmerThumbnail, thumbnailView);\n            return;\n        }\n\n        for (ThumbnailsCacheManager.ThumbnailGenerationTask task : asyncTasks) {\n            if (file.getRemoteId() != null && task.getImageKey() != null &&\n                file.getRemoteId().equals(task.getImageKey())) {\n                return;\n            }\n        }\n\n        try {\n            final ThumbnailsCacheManager.ThumbnailGenerationTask task =\n                new ThumbnailsCacheManager.ThumbnailGenerationTask(thumbnailView,\n                                                                   storageManager,\n                                                                   user,\n                                                                   asyncTasks,\n                                                                   gridView,\n                                                                   file.getRemoteId());\n            Drawable drawable = MimeTypeUtil.getFileTypeIcon(file.getMimeType(),\n                                                             file.getFileName(),\n                                                             context,\n                                                             viewThemeUtils);\n            if (drawable == null) {\n                drawable = ResourcesCompat.getDrawable(context.getResources(),\n                                                       R.drawable.file_image,\n                                                       null);\n            }\n            if (drawable == null) {\n                drawable = new ColorDrawable(Color.GRAY);\n            }\n\n            int px = ThumbnailsCacheManager.getThumbnailDimension();\n            thumbnail = BitmapUtils.drawableToBitmap(drawable, px, px);\n            final ThumbnailsCacheManager.AsyncThumbnailDrawable asyncDrawable =\n                new ThumbnailsCacheManager.AsyncThumbnailDrawable(context.getResources(),\n                                                                  thumbnail, task);\n\n            if (shimmerThumbnail != null) {\n                shimmerThumbnail.postDelayed(() -> {\n                    if (thumbnailView.getDrawable() == null) {\n                        if (gridView) {\n                            configShimmerGridImageSize(shimmerThumbnail, preferences.getGridColumns());\n                        }\n                        startShimmer(shimmerThumbnail, thumbnailView);\n                    }\n                }, 100);\n            }\n\n            task.setListener(new ThumbnailsCacheManager.ThumbnailGenerationTask.Listener() {\n                @Override\n                public void onSuccess() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n\n                @Override\n                public void onError() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n            });\n\n            thumbnailView.setImageDrawable(asyncDrawable);\n            asyncTasks.add(task);\n            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,\n                                   new ThumbnailsCacheManager.ThumbnailGenerationTaskObject(file,\n                                                                                            file.getRemoteId()));\n        } catch (IllegalArgumentException e) {\n            Log_OC.d(TAG, \"ThumbnailGenerationTask : \" + e.getMessage());\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func generateNewThumbnail(file: OCFile,\n                                         thumbnailView: UIImageView,\n                                         user: User,\n                                         storageManager: FileDataStorageManager,\n                                         asyncTasks: inout [ThumbnailsCacheManager.ThumbnailGenerationTask],\n                                         gridView: Bool,\n                                         context: Context,\n                                         shimmerThumbnail: LoaderImageView?,\n                                         preferences: AppPreferences,\n                                         viewThemeUtils: ViewThemeUtils) {\n    if !ThumbnailsCacheManager.cancelPotentialThumbnailWork(file: file, thumbnailView: thumbnailView) {\n        return\n    }\n\n    if let thumbnail = ThumbnailsCacheManager.getBitmapFromDiskCache(key: ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId()) {\n        thumbnailView.image = thumbnail\n        stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n        return\n    }\n\n    for task in asyncTasks {\n        if let remoteId = file.getRemoteId(), let imageKey = task.getImageKey(), remoteId == imageKey {\n            return\n        }\n    }\n\n    do {\n        let task = ThumbnailsCacheManager.ThumbnailGenerationTask(thumbnailView: thumbnailView,\n                                                                  storageManager: storageManager,\n                                                                  user: user,\n                                                                  asyncTasks: &asyncTasks,\n                                                                  gridView: gridView,\n                                                                  imageKey: file.getRemoteId())\n        var drawable = MimeTypeUtil.getFileTypeIcon(mimeType: file.getMimeType(),\n                                                    fileName: file.getFileName(),\n                                                    context: context,\n                                                    viewThemeUtils: viewThemeUtils)\n        if drawable == nil {\n            drawable = ResourcesCompat.getDrawable(context.getResources(), R.drawable.file_image, nil)\n        }\n        if drawable == nil {\n            drawable = ColorDrawable(color: .gray)\n        }\n\n        let px = ThumbnailsCacheManager.getThumbnailDimension()\n        let thumbnail = BitmapUtils.drawableToBitmap(drawable: drawable, width: px, height: px)\n        let asyncDrawable = ThumbnailsCacheManager.AsyncThumbnailDrawable(resources: context.getResources(),\n                                                                          bitmap: thumbnail, task: task)\n\n        if let shimmerThumbnail = shimmerThumbnail {\n            shimmerThumbnail.postDelayed({\n                if thumbnailView.image == nil {\n                    if gridView {\n                        configShimmerGridImageSize(shimmerThumbnail: shimmerThumbnail, columns: preferences.getGridColumns())\n                    }\n                    startShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n                }\n            }, delay: 100)\n        }\n\n        task.setListener(listener: ThumbnailsCacheManager.ThumbnailGenerationTask.Listener(\n            onSuccess: {\n                stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n            },\n            onError: {\n                stopShimmer(shimmerThumbnail: shimmerThumbnail, thumbnailView: thumbnailView)\n            }\n        ))\n\n        thumbnailView.image = asyncDrawable\n        asyncTasks.append(task)\n        task.executeOnExecutor(executor: .threadPoolExecutor,\n                               params: ThumbnailsCacheManager.ThumbnailGenerationTaskObject(file: file, imageKey: file.getRemoteId()))\n    } catch let e as IllegalArgumentException {\n        Log_OC.d(TAG, \"ThumbnailGenerationTask : \\(e.message)\")\n    }\n}\n```"
    },
    {
        "method_name": "onSuccess",
        "method_code": "verride\n                public void onSuccess() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled onSuccess from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: onSuccess\n\n        Method Code: verride\n                public void onSuccess() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc onSuccess() {\n    stopShimmer(shimmerThumbnail, thumbnailView)\n}\n```"
    },
    {
        "method_name": "onError",
        "method_code": "verride\n                public void onError() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n ",
        "prompt": "\n        Please translate the following Java (Android) method titled onError from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: onError\n\n        Method Code: verride\n                public void onError() {\n                    stopShimmer(shimmerThumbnail, thumbnailView);\n                }\n \n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onError() {\n    stopShimmer(shimmerThumbnail, thumbnailView)\n}\n```"
    },
    {
        "method_name": "startShimmer",
        "method_code": "blic static void startShimmer(LoaderImageView thumbnailShimmer, ImageView thumbnailView) {\n        thumbnailShimmer.setImageResource(R.drawable.background);\n        thumbnailShimmer.resetLoader();\n        thumbnailView.setVisibility(View.GONE);\n        thumbnailShimmer.setVisibility(View.VISIBLE);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled startShimmer from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: startShimmer\n\n        Method Code: blic static void startShimmer(LoaderImageView thumbnailShimmer, ImageView thumbnailView) {\n        thumbnailShimmer.setImageResource(R.drawable.background);\n        thumbnailShimmer.resetLoader();\n        thumbnailView.setVisibility(View.GONE);\n        thumbnailShimmer.setVisibility(View.VISIBLE);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc startShimmer(thumbnailShimmer: LoaderImageView, thumbnailView: UIImageView) {\n    thumbnailShimmer.image = UIImage(named: \"background\")\n    thumbnailShimmer.resetLoader()\n    thumbnailView.isHidden = true\n    thumbnailShimmer.isHidden = false\n}\n```"
    },
    {
        "method_name": "stopShimmer",
        "method_code": "blic static void stopShimmer(@Nullable LoaderImageView thumbnailShimmer, ImageView thumbnailView) {\n        if (thumbnailShimmer != null) {\n            thumbnailShimmer.setVisibility(View.GONE);\n        }\n\n        thumbnailView.setVisibility(View.VISIBLE);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled stopShimmer from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: stopShimmer\n\n        Method Code: blic static void stopShimmer(@Nullable LoaderImageView thumbnailShimmer, ImageView thumbnailView) {\n        if (thumbnailShimmer != null) {\n            thumbnailShimmer.setVisibility(View.GONE);\n        }\n\n        thumbnailView.setVisibility(View.VISIBLE);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc stopShimmer(thumbnailShimmer: LoaderImageView?, thumbnailView: UIImageView) {\n    if let shimmer = thumbnailShimmer {\n        shimmer.isHidden = true\n    }\n    \n    thumbnailView.isHidden = false\n}\n```"
    },
    {
        "method_name": "configShimmerGridImageSize",
        "method_code": "ivate static void configShimmerGridImageSize(LoaderImageView thumbnailShimmer, float gridColumns) {\n        try {\n            FrameLayout.LayoutParams targetLayoutParams = (FrameLayout.LayoutParams) thumbnailShimmer.getLayoutParams();\n\n            final Point screenSize = getScreenSize(thumbnailShimmer.getContext());\n            final int marginLeftAndRight = targetLayoutParams.leftMargin + targetLayoutParams.rightMargin;\n            final int size = Math.round(screenSize.x / gridColumns - marginLeftAndRight);\n\n            FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(size, size);\n            params.setMargins(targetLayoutParams.leftMargin,\n                              targetLayoutParams.topMargin,\n                              targetLayoutParams.rightMargin,\n                              targetLayoutParams.bottomMargin);\n            thumbnailShimmer.setLayoutParams(params);\n        } catch (Exception exception) {\n            Log_OC.e(\"ConfigShimmer\", exception.getMessage());\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled configShimmerGridImageSize from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: configShimmerGridImageSize\n\n        Method Code: ivate static void configShimmerGridImageSize(LoaderImageView thumbnailShimmer, float gridColumns) {\n        try {\n            FrameLayout.LayoutParams targetLayoutParams = (FrameLayout.LayoutParams) thumbnailShimmer.getLayoutParams();\n\n            final Point screenSize = getScreenSize(thumbnailShimmer.getContext());\n            final int marginLeftAndRight = targetLayoutParams.leftMargin + targetLayoutParams.rightMargin;\n            final int size = Math.round(screenSize.x / gridColumns - marginLeftAndRight);\n\n            FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(size, size);\n            params.setMargins(targetLayoutParams.leftMargin,\n                              targetLayoutParams.topMargin,\n                              targetLayoutParams.rightMargin,\n                              targetLayoutParams.bottomMargin);\n            thumbnailShimmer.setLayoutParams(params);\n        } catch (Exception exception) {\n            Log_OC.e(\"ConfigShimmer\", exception.getMessage());\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func configShimmerGridImageSize(thumbnailShimmer: LoaderImageView, gridColumns: Float) {\n    do {\n        if let targetLayoutParams = thumbnailShimmer.layoutParams as? FrameLayout.LayoutParams {\n            let screenSize = getScreenSize(context: thumbnailShimmer.context)\n            let marginLeftAndRight = targetLayoutParams.leftMargin + targetLayoutParams.rightMargin\n            let size = Int(round(Float(screenSize.x) / gridColumns - Float(marginLeftAndRight)))\n\n            let params = FrameLayout.LayoutParams(width: size, height: size)\n            params.setMargins(left: targetLayoutParams.leftMargin,\n                              top: targetLayoutParams.topMargin,\n                              right: targetLayoutParams.rightMargin,\n                              bottom: targetLayoutParams.bottomMargin)\n            thumbnailShimmer.layoutParams = params\n        }\n    } catch {\n        Log_OC.e(\"ConfigShimmer\", error.localizedDescription)\n    }\n}\n```"
    },
    {
        "method_name": "getScreenSize",
        "method_code": "ivate static Point getScreenSize(Context context) throws Exception {\n        final WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        if (windowManager != null) {\n            final Point displaySize = new Point();\n            windowManager.getDefaultDisplay().getSize(displaySize);\n            return displaySize;\n        } else {\n            throw new Exception(\"WindowManager not found\");\n        }\n    }\n}",
        "prompt": "\n        Please translate the following Java (Android) method titled getScreenSize from DisplayUtils.java into Swift.\n\n        Input:\n\n        Method Name: getScreenSize\n\n        Method Code: ivate static Point getScreenSize(Context context) throws Exception {\n        final WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        if (windowManager != null) {\n            final Point displaySize = new Point();\n            windowManager.getDefaultDisplay().getSize(displaySize);\n            return displaySize;\n        } else {\n            throw new Exception(\"WindowManager not found\");\n        }\n    }\n}\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc getScreenSize() throws -> CGPoint {\n    if let window = UIApplication.shared.windows.first {\n        let displaySize = window.bounds.size\n        return CGPoint(x: displaySize.width, y: displaySize.height)\n    } else {\n        throw NSError(domain: \"Window not found\", code: 0, userInfo: nil)\n    }\n}\n```"
    }
]