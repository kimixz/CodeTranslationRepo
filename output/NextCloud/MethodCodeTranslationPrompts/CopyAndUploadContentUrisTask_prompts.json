[
    {
        "method_name": "makeParamsToExecute",
        "method_code": "blic static Object[] makeParamsToExecute(\n        User user,\n        Uri[] sourceUris,\n        String[] remotePaths,\n        int behaviour,\n        ContentResolver contentResolver\n                                              ) {\n\n        return new Object[]{\n            user,\n            sourceUris,\n            remotePaths,\n            Integer.valueOf(behaviour),\n            contentResolver\n        };\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled makeParamsToExecute from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: makeParamsToExecute\n\n        Method Code: blic static Object[] makeParamsToExecute(\n        User user,\n        Uri[] sourceUris,\n        String[] remotePaths,\n        int behaviour,\n        ContentResolver contentResolver\n                                              ) {\n\n        return new Object[]{\n            user,\n            sourceUris,\n            remotePaths,\n            Integer.valueOf(behaviour),\n            contentResolver\n        };\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func makeParamsToExecute(\n    user: User,\n    sourceUris: [URL],\n    remotePaths: [String],\n    behaviour: Int,\n    contentResolver: ContentResolver\n) -> [Any] {\n    return [\n        user,\n        sourceUris,\n        remotePaths,\n        behaviour,\n        contentResolver\n    ]\n}\n```"
    },
    {
        "method_name": "doInBackground",
        "method_code": "verride\n    protected ResultCode doInBackground(Object[] params) {\n\n        ResultCode result = ResultCode.UNKNOWN_ERROR;\n\n        InputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        String fullTempPath = null;\n        Uri currentUri = null;\n\n        try {\n            User user = (User) params[0];\n            Uri[] uris = (Uri[]) params[1];\n            String[] remotePaths = (String[]) params[2];\n            int behaviour = (Integer) params[3];\n            ContentResolver leakedContentResolver = (ContentResolver) params[4];\n\n            String currentRemotePath;\n\n            for (int i = 0; i < uris.length; i++) {\n                currentUri = uris[i];\n                currentRemotePath = remotePaths[i];\n\n                long lastModified = 0;\n                try (Cursor cursor = leakedContentResolver.query(currentUri,\n                                                                 null,\n                                                                 null,\n                                                                 null,\n                                                                 null)) {\n                    if (cursor != null && cursor.moveToFirst()) {\n                        // this check prevents a crash when last modification time is not available on certain phones\n                        int columnIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_LAST_MODIFIED);\n                        if (columnIndex >= 0) {\n                            lastModified = cursor.getLong(columnIndex);\n                        }\n                    }\n                }\n\n                fullTempPath = FileStorageUtils.getTemporalPath(user.getAccountName()) + currentRemotePath;\n                inputStream = leakedContentResolver.openInputStream(currentUri);\n                File cacheFile = new File(fullTempPath);\n                File tempDir = cacheFile.getParentFile();\n                if (!tempDir.exists()) {\n                    tempDir.mkdirs();\n                }\n                cacheFile.createNewFile();\n                outputStream = new FileOutputStream(fullTempPath);\n                byte[] buffer = new byte[4096];\n\n                int count;\n                while ((count = inputStream.read(buffer)) > 0) {\n                    outputStream.write(buffer, 0, count);\n                }\n\n                if (lastModified != 0) {\n                    try {\n                        if (!cacheFile.setLastModified(lastModified)) {\n                            Log_OC.w(TAG, \"Could not change mtime of cacheFile\");\n                        }\n                    } catch (SecurityException e) {\n                        Log_OC.e(TAG, \"Not enough permissions to change mtime of cacheFile\", e);\n                    } catch (IllegalArgumentException e) {\n                        Log_OC.e(TAG, \"Could not change mtime of cacheFile, mtime is negativ: \"+lastModified, e);\n                    }\n                }\n\n                requestUpload(\n                    user,\n                    fullTempPath,\n                    currentRemotePath,\n                    behaviour\n                );\n                fullTempPath = null;\n            }\n\n            result = ResultCode.OK;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n            Log_OC.e(TAG, \"Wrong number of arguments received \", e);\n\n        } catch (ClassCastException e) {\n            Log_OC.e(TAG, \"Wrong parameter received \", e);\n\n        } catch (FileNotFoundException e) {\n            Log_OC.e(TAG, \"Could not find source file \" + currentUri, e);\n            result = ResultCode.LOCAL_FILE_NOT_FOUND;\n\n        } catch (SecurityException e) {\n            Log_OC.e(TAG, \"Not enough permissions to read source file \" + currentUri, e);\n            result = ResultCode.FORBIDDEN;\n\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Exception while copying \" + currentUri + \" to temporary file\", e);\n            result =  ResultCode.LOCAL_STORAGE_NOT_COPIED;\n\n            // clean\n            if (fullTempPath != null) {\n                File f = new File(fullTempPath);\n                if (f.exists() && !f.delete()) {\n                    Log_OC.e(TAG, \"Could not delete temporary file \" + fullTempPath);\n                }\n            }\n\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (Exception e) {\n                    Log_OC.w(TAG, \"Ignoring exception of inputStream closure\");\n                }\n            }\n\n            if (outputStream != null) {\n                try {\n                    outputStream.close();\n                } catch (Exception e) {\n                    Log_OC.w(TAG, \"Ignoring exception of outStream closure\");\n                }\n            }\n        }\n\n        return result;\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled doInBackground from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: doInBackground\n\n        Method Code: verride\n    protected ResultCode doInBackground(Object[] params) {\n\n        ResultCode result = ResultCode.UNKNOWN_ERROR;\n\n        InputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        String fullTempPath = null;\n        Uri currentUri = null;\n\n        try {\n            User user = (User) params[0];\n            Uri[] uris = (Uri[]) params[1];\n            String[] remotePaths = (String[]) params[2];\n            int behaviour = (Integer) params[3];\n            ContentResolver leakedContentResolver = (ContentResolver) params[4];\n\n            String currentRemotePath;\n\n            for (int i = 0; i < uris.length; i++) {\n                currentUri = uris[i];\n                currentRemotePath = remotePaths[i];\n\n                long lastModified = 0;\n                try (Cursor cursor = leakedContentResolver.query(currentUri,\n                                                                 null,\n                                                                 null,\n                                                                 null,\n                                                                 null)) {\n                    if (cursor != null && cursor.moveToFirst()) {\n                        // this check prevents a crash when last modification time is not available on certain phones\n                        int columnIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_LAST_MODIFIED);\n                        if (columnIndex >= 0) {\n                            lastModified = cursor.getLong(columnIndex);\n                        }\n                    }\n                }\n\n                fullTempPath = FileStorageUtils.getTemporalPath(user.getAccountName()) + currentRemotePath;\n                inputStream = leakedContentResolver.openInputStream(currentUri);\n                File cacheFile = new File(fullTempPath);\n                File tempDir = cacheFile.getParentFile();\n                if (!tempDir.exists()) {\n                    tempDir.mkdirs();\n                }\n                cacheFile.createNewFile();\n                outputStream = new FileOutputStream(fullTempPath);\n                byte[] buffer = new byte[4096];\n\n                int count;\n                while ((count = inputStream.read(buffer)) > 0) {\n                    outputStream.write(buffer, 0, count);\n                }\n\n                if (lastModified != 0) {\n                    try {\n                        if (!cacheFile.setLastModified(lastModified)) {\n                            Log_OC.w(TAG, \"Could not change mtime of cacheFile\");\n                        }\n                    } catch (SecurityException e) {\n                        Log_OC.e(TAG, \"Not enough permissions to change mtime of cacheFile\", e);\n                    } catch (IllegalArgumentException e) {\n                        Log_OC.e(TAG, \"Could not change mtime of cacheFile, mtime is negativ: \"+lastModified, e);\n                    }\n                }\n\n                requestUpload(\n                    user,\n                    fullTempPath,\n                    currentRemotePath,\n                    behaviour\n                );\n                fullTempPath = null;\n            }\n\n            result = ResultCode.OK;\n\n        } catch (ArrayIndexOutOfBoundsException e) {\n            Log_OC.e(TAG, \"Wrong number of arguments received \", e);\n\n        } catch (ClassCastException e) {\n            Log_OC.e(TAG, \"Wrong parameter received \", e);\n\n        } catch (FileNotFoundException e) {\n            Log_OC.e(TAG, \"Could not find source file \" + currentUri, e);\n            result = ResultCode.LOCAL_FILE_NOT_FOUND;\n\n        } catch (SecurityException e) {\n            Log_OC.e(TAG, \"Not enough permissions to read source file \" + currentUri, e);\n            result = ResultCode.FORBIDDEN;\n\n        } catch (Exception e) {\n            Log_OC.e(TAG, \"Exception while copying \" + currentUri + \" to temporary file\", e);\n            result =  ResultCode.LOCAL_STORAGE_NOT_COPIED;\n\n            // clean\n            if (fullTempPath != null) {\n                File f = new File(fullTempPath);\n                if (f.exists() && !f.delete()) {\n                    Log_OC.e(TAG, \"Could not delete temporary file \" + fullTempPath);\n                }\n            }\n\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (Exception e) {\n                    Log_OC.w(TAG, \"Ignoring exception of inputStream closure\");\n                }\n            }\n\n            if (outputStream != null) {\n                try {\n                    outputStream.close();\n                } catch (Exception e) {\n                    Log_OC.w(TAG, \"Ignoring exception of outStream closure\");\n                }\n            }\n        }\n\n        return result;\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc doInBackground(params: [Any]) -> ResultCode {\n    var result: ResultCode = .unknownError\n\n    var inputStream: InputStream? = nil\n    var outputStream: OutputStream? = nil\n    var fullTempPath: String? = nil\n    var currentUri: URL? = nil\n\n    do {\n        guard let user = params[0] as? User,\n              let uris = params[1] as? [URL],\n              let remotePaths = params[2] as? [String],\n              let behaviour = params[3] as? Int,\n              let leakedContentResolver = params[4] as? ContentResolver else {\n            throw NSError(domain: \"Invalid parameters\", code: 0, userInfo: nil)\n        }\n\n        for i in 0..<uris.count {\n            currentUri = uris[i]\n            let currentRemotePath = remotePaths[i]\n\n            var lastModified: TimeInterval = 0\n            if let cursor = leakedContentResolver.query(currentUri!, nil, nil, nil, nil) {\n                if cursor.moveToFirst() {\n                    let columnIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_LAST_MODIFIED)\n                    if columnIndex >= 0 {\n                        lastModified = cursor.getDouble(columnIndex)\n                    }\n                }\n                cursor.close()\n            }\n\n            fullTempPath = FileStorageUtils.getTemporalPath(user.accountName) + currentRemotePath\n            inputStream = InputStream(url: currentUri!)\n            let cacheFile = FileManager.default.temporaryDirectory.appendingPathComponent(fullTempPath!)\n            let tempDir = cacheFile.deletingLastPathComponent()\n            if !FileManager.default.fileExists(atPath: tempDir.path) {\n                try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true, attributes: nil)\n            }\n            FileManager.default.createFile(atPath: cacheFile.path, contents: nil, attributes: nil)\n            outputStream = OutputStream(url: cacheFile, append: false)\n\n            inputStream?.open()\n            outputStream?.open()\n\n            var buffer = [UInt8](repeating: 0, count: 4096)\n            while inputStream!.hasBytesAvailable {\n                let count = inputStream!.read(&buffer, maxLength: buffer.count)\n                if count > 0 {\n                    outputStream!.write(buffer, maxLength: count)\n                }\n            }\n\n            if lastModified != 0 {\n                do {\n                    try FileManager.default.setAttributes([.modificationDate: Date(timeIntervalSince1970: lastModified)], ofItemAtPath: cacheFile.path)\n                } catch {\n                    print(\"Could not change mtime of cacheFile\")\n                }\n            }\n\n            requestUpload(user: user, fullTempPath: fullTempPath!, currentRemotePath: currentRemotePath, behaviour: behaviour)\n            fullTempPath = nil\n        }\n\n        result = .ok\n\n    } catch {\n        if let error = error as? NSError {\n            switch error.code {\n            case NSFileReadNoSuchFileError:\n                print(\"Could not find source file \\(String(describing: currentUri))\")\n                result = .localFileNotFound\n            case NSFileReadNoPermissionError:\n                print(\"Not enough permissions to read source file \\(String(describing: currentUri))\")\n                result = .forbidden\n            default:\n                print(\"Exception while copying \\(String(describing: currentUri)) to temporary file\")\n                result = .localStorageNotCopied\n            }\n        }\n\n        if let fullTempPath = fullTempPath {\n            let file = URL(fileURLWithPath: fullTempPath)\n            if FileManager.default.fileExists(atPath: file.path) {\n                do {\n                    try FileManager.default.removeItem(at: file)\n                } catch {\n                    print(\"Could not delete temporary file \\(fullTempPath)\")\n                }\n            }\n        }\n    } finally: {\n        inputStream?.close()\n        outputStream?.close()\n    }\n\n    return result\n}\n```"
    },
    {
        "method_name": "requestUpload",
        "method_code": "ivate void requestUpload(User user, String localPath, String remotePath, int behaviour) {\n        FileUploadHelper.Companion.instance().uploadNewFiles(\n            user,\n            new String[]{ localPath },\n            new String[]{ remotePath },\n            behaviour,\n            false,      // do not create parent folder if not existent\n            UploadFileOperation.CREATED_BY_USER,\n            false,\n            false,\n            NameCollisionPolicy.ASK_USER);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled requestUpload from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: requestUpload\n\n        Method Code: ivate void requestUpload(User user, String localPath, String remotePath, int behaviour) {\n        FileUploadHelper.Companion.instance().uploadNewFiles(\n            user,\n            new String[]{ localPath },\n            new String[]{ remotePath },\n            behaviour,\n            false,      // do not create parent folder if not existent\n            UploadFileOperation.CREATED_BY_USER,\n            false,\n            false,\n            NameCollisionPolicy.ASK_USER);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func requestUpload(user: User, localPath: String, remotePath: String, behaviour: Int) {\n    FileUploadHelper.instance().uploadNewFiles(\n        user: user,\n        localPaths: [localPath],\n        remotePaths: [remotePath],\n        behaviour: behaviour,\n        createParentFolderIfNotExistent: false,\n        createdBy: .createdByUser,\n        isFolder: false,\n        isUpdate: false,\n        nameCollisionPolicy: .askUser\n    )\n}\n```"
    },
    {
        "method_name": "onPostExecute",
        "method_code": "verride\n    protected void onPostExecute(ResultCode result) {\n        OnCopyTmpFilesTaskListener listener = mListener.get();\n        if (listener!= null) {\n            listener.onTmpFilesCopied(result);\n\n        } else {\n            Log_OC.i(TAG, \"User left the caller activity before the temporal copies were finished \");\n            if (result != ResultCode.OK) {\n                // if the user left the app, report background error in a Toast\n                int messageId;\n                switch (result) {\n                    case LOCAL_FILE_NOT_FOUND:\n                        messageId = R.string.uploader_error_message_source_file_not_found;\n                        break;\n                    case LOCAL_STORAGE_NOT_COPIED:\n                        messageId = R.string.uploader_error_message_source_file_not_copied;\n                        break;\n                    case FORBIDDEN:\n                        messageId = R.string.uploader_error_message_read_permission_not_granted;\n                        break;\n                    default:\n                        messageId = R.string.common_error_unknown;\n                        break;\n                }\n                String message = String.format(\n                    mAppContext.getString(messageId),\n                    mAppContext.getString(R.string.app_name)\n                );\n                Toast.makeText(mAppContext, message, Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled onPostExecute from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: onPostExecute\n\n        Method Code: verride\n    protected void onPostExecute(ResultCode result) {\n        OnCopyTmpFilesTaskListener listener = mListener.get();\n        if (listener!= null) {\n            listener.onTmpFilesCopied(result);\n\n        } else {\n            Log_OC.i(TAG, \"User left the caller activity before the temporal copies were finished \");\n            if (result != ResultCode.OK) {\n                // if the user left the app, report background error in a Toast\n                int messageId;\n                switch (result) {\n                    case LOCAL_FILE_NOT_FOUND:\n                        messageId = R.string.uploader_error_message_source_file_not_found;\n                        break;\n                    case LOCAL_STORAGE_NOT_COPIED:\n                        messageId = R.string.uploader_error_message_source_file_not_copied;\n                        break;\n                    case FORBIDDEN:\n                        messageId = R.string.uploader_error_message_read_permission_not_granted;\n                        break;\n                    default:\n                        messageId = R.string.common_error_unknown;\n                        break;\n                }\n                String message = String.format(\n                    mAppContext.getString(messageId),\n                    mAppContext.getString(R.string.app_name)\n                );\n                Toast.makeText(mAppContext, message, Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onPostExecute(_ result: ResultCode) {\n    if let listener = mListener {\n        listener.onTmpFilesCopied(result)\n    } else {\n        Log_OC.i(TAG, \"User left the caller activity before the temporal copies were finished \")\n        if result != .OK {\n            let messageId: Int\n            switch result {\n            case .LOCAL_FILE_NOT_FOUND:\n                messageId = R.string.uploader_error_message_source_file_not_found\n            case .LOCAL_STORAGE_NOT_COPIED:\n                messageId = R.string.uploader_error_message_source_file_not_copied\n            case .FORBIDDEN:\n                messageId = R.string.uploader_error_message_read_permission_not_granted\n            default:\n                messageId = R.string.common_error_unknown\n            }\n            let message = String(format: mAppContext.getString(messageId), mAppContext.getString(R.string.app_name))\n            Toast.makeText(mAppContext, message, Toast.LENGTH_LONG).show()\n        }\n    }\n}\n```"
    },
    {
        "method_name": "setListener",
        "method_code": "blic void setListener(OnCopyTmpFilesTaskListener listener) {\n        mListener = new WeakReference<>(listener);\n    }\n\n",
        "prompt": "\n        Please translate the following Java (Android) method titled setListener from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: setListener\n\n        Method Code: blic void setListener(OnCopyTmpFilesTaskListener listener) {\n        mListener = new WeakReference<>(listener);\n    }\n\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc setListener(listener: OnCopyTmpFilesTaskListener) {\n    mListener = WeakReference(value: listener)\n}\n```"
    },
    {
        "method_name": "onTmpFilesCopied",
        "method_code": "id onTmpFilesCopied(ResultCode result);\n ",
        "prompt": "\n        Please translate the following Java (Android) method titled onTmpFilesCopied from CopyAndUploadContentUrisTask.java into Swift.\n\n        Input:\n\n        Method Name: onTmpFilesCopied\n\n        Method Code: id onTmpFilesCopied(ResultCode result);\n \n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc onTmpFilesCopied(result: ResultCode) -> Any? {\n    // Implementation goes here\n    return nil\n}\n```"
    }
]