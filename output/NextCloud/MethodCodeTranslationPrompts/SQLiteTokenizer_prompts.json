[
    {
        "method_name": "isAlpha",
        "method_code": "private static boolean isAlpha(char ch) {\n        return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || (ch == '_');\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isAlpha from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isAlpha\n\n        Method Code: private static boolean isAlpha(char ch) {\n        return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || (ch == '_');\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isAlpha(_ ch: Character) -> Bool {\n    return (\"a\" <= ch && ch <= \"z\") || (\"A\" <= ch && ch <= \"Z\") || (ch == \"_\")\n}\n```"
    },
    {
        "method_name": "isNum",
        "method_code": "private static boolean isNum(char ch) {\n        return ('0' <= ch && ch <= '9');\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isNum from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isNum\n\n        Method Code: private static boolean isNum(char ch) {\n        return ('0' <= ch && ch <= '9');\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isNum(_ ch: Character) -> Bool {\n    return ch >= \"0\" && ch <= \"9\"\n}\n```"
    },
    {
        "method_name": "isAlNum",
        "method_code": "private static boolean isAlNum(char ch) {\n        return isAlpha(ch) || isNum(ch);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isAlNum from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isAlNum\n\n        Method Code: private static boolean isAlNum(char ch) {\n        return isAlpha(ch) || isNum(ch);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isAlNum(_ ch: Character) -> Bool {\n    return isAlpha(ch) || isNum(ch)\n}\n```"
    },
    {
        "method_name": "isAnyOf",
        "method_code": "private static boolean isAnyOf(char ch, String set) {\n        return set.indexOf(ch) >= 0;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isAnyOf from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isAnyOf\n\n        Method Code: private static boolean isAnyOf(char ch, String set) {\n        return set.indexOf(ch) >= 0;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isAnyOf(_ ch: Character, _ set: String) -> Bool {\n    return set.contains(ch)\n}\n```"
    },
    {
        "method_name": "genException",
        "method_code": "private static IllegalArgumentException genException(String message, String sql) {\n        throw new IllegalArgumentException(message + \" in '\" + sql + \"'\");\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled genException from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: genException\n\n        Method Code: private static IllegalArgumentException genException(String message, String sql) {\n        throw new IllegalArgumentException(message + \" in '\" + sql + \"'\");\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func genException(message: String, sql: String) -> Never {\n    fatalError(\"\\(message) in '\\(sql)'\")\n}\n```"
    },
    {
        "method_name": "peek",
        "method_code": "private static char peek(String s, int index) {\n        return index < s.length() ? s.charAt(index) : '\\0';\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled peek from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: peek\n\n        Method Code: private static char peek(String s, int index) {\n        return index < s.length() ? s.charAt(index) : '\\0';\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func peek(_ s: String, _ index: Int) -> Character {\n    return index < s.count ? s[s.index(s.startIndex, offsetBy: index)] : \"\\0\"\n}\n```"
    },
    {
        "method_name": "tokenize",
        "method_code": "public static List<String> tokenize(@Nullable String sql, int options) {\n        final ArrayList<String> res = new ArrayList<>();\n        tokenize(sql, options, res::add);\n        return res;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled tokenize from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: tokenize\n\n        Method Code: public static List<String> tokenize(@Nullable String sql, int options) {\n        final ArrayList<String> res = new ArrayList<>();\n        tokenize(sql, options, res::add);\n        return res;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\npublic static func tokenize(_ sql: String?, options: Int) -> [String] {\n    var res = [String]()\n    tokenize(sql, options) { res.append($0) }\n    return res\n}\n```"
    },
    {
        "method_name": "tokenize",
        "method_code": "public static void tokenize(@Nullable String sql, int options, Consumer<String> checker) {\n        if (sql == null) {\n            return;\n        }\n        int pos = 0;\n        final int len = sql.length();\n        while (pos < len) {\n            final char ch = peek(sql, pos);\n\n            // Regular token.\n            if (isAlpha(ch)) {\n                final int start = pos;\n                pos++;\n                while (isAlNum(peek(sql, pos))) {\n                    pos++;\n                }\n                final int end = pos;\n\n                final String token = sql.substring(start, end);\n                checker.accept(token);\n\n                continue;\n            }\n\n            // Handle quoted tokens\n            if (isAnyOf(ch, \"'\\\"`\")) {\n                final int quoteStart = pos;\n                pos++;\n\n                for (;;) {\n                    pos = sql.indexOf(ch, pos);\n                    if (pos < 0) {\n                        throw genException(\"Unterminated quote\", sql);\n                    }\n                    if (peek(sql, pos + 1) != ch) {\n                        break;\n                    }\n                    // Quoted quote char -- e.g. \"abc\"\"def\" is a single string.\n                    pos += 2;\n                }\n                final int quoteEnd = pos;\n                pos++;\n\n                if (ch != '\\'') {\n                    // Extract the token\n                    final String tokenUnquoted = sql.substring(quoteStart + 1, quoteEnd);\n\n                    final String token;\n\n                    // Unquote if needed. i.e. \"aa\"\"bb\" -> aa\"bb\n                    if (tokenUnquoted.indexOf(ch) >= 0) {\n                        token = tokenUnquoted.replaceAll(\n                            String.valueOf(ch) + ch, String.valueOf(ch));\n                    } else {\n                        token = tokenUnquoted;\n                    }\n                    checker.accept(token);\n                } else {\n                    if ((options &= OPTION_TOKEN_ONLY) != 0) {\n                        throw genException(\"Non-token detected\", sql);\n                    }\n                }\n                continue;\n            }\n            // Handle tokens enclosed in [...]\n            if (ch == '[') {\n                final int quoteStart = pos;\n                pos++;\n\n                pos = sql.indexOf(']', pos);\n                if (pos < 0) {\n                    throw genException(\"Unterminated quote\", sql);\n                }\n                final int quoteEnd = pos;\n                pos++;\n\n                final String token = sql.substring(quoteStart + 1, quoteEnd);\n\n                checker.accept(token);\n                continue;\n            }\n            if ((options &= OPTION_TOKEN_ONLY) != 0) {\n                throw genException(\"Non-token detected\", sql);\n            }\n\n            // Detect comments.\n            if (ch == '-' && peek(sql, pos + 1) == '-') {\n                pos += 2;\n                pos = sql.indexOf('\\n', pos);\n                if (pos < 0) {\n                    // We disallow strings ending in an inline comment.\n                    throw genException(\"Unterminated comment\", sql);\n                }\n                pos++;\n\n                continue;\n            }\n            if (ch == '/' && peek(sql, pos + 1) == '*') {\n                pos += 2;\n                pos = sql.indexOf(\"*/\", pos);\n                if (pos < 0) {\n                    throw genException(\"Unterminated comment\", sql);\n                }\n                pos += 2;\n\n                continue;\n            }\n\n            // Semicolon is never allowed.\n            if (ch == ';') {\n                throw genException(\"Semicolon is not allowed\", sql);\n            }\n\n            // For this purpose, we can simply ignore other characters.\n            // (Note it doesn't handle the X'' literal properly and reports this X as a token,\n            // but that should be fine...)\n            pos++;\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled tokenize from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: tokenize\n\n        Method Code: public static void tokenize(@Nullable String sql, int options, Consumer<String> checker) {\n        if (sql == null) {\n            return;\n        }\n        int pos = 0;\n        final int len = sql.length();\n        while (pos < len) {\n            final char ch = peek(sql, pos);\n\n            // Regular token.\n            if (isAlpha(ch)) {\n                final int start = pos;\n                pos++;\n                while (isAlNum(peek(sql, pos))) {\n                    pos++;\n                }\n                final int end = pos;\n\n                final String token = sql.substring(start, end);\n                checker.accept(token);\n\n                continue;\n            }\n\n            // Handle quoted tokens\n            if (isAnyOf(ch, \"'\\\"`\")) {\n                final int quoteStart = pos;\n                pos++;\n\n                for (;;) {\n                    pos = sql.indexOf(ch, pos);\n                    if (pos < 0) {\n                        throw genException(\"Unterminated quote\", sql);\n                    }\n                    if (peek(sql, pos + 1) != ch) {\n                        break;\n                    }\n                    // Quoted quote char -- e.g. \"abc\"\"def\" is a single string.\n                    pos += 2;\n                }\n                final int quoteEnd = pos;\n                pos++;\n\n                if (ch != '\\'') {\n                    // Extract the token\n                    final String tokenUnquoted = sql.substring(quoteStart + 1, quoteEnd);\n\n                    final String token;\n\n                    // Unquote if needed. i.e. \"aa\"\"bb\" -> aa\"bb\n                    if (tokenUnquoted.indexOf(ch) >= 0) {\n                        token = tokenUnquoted.replaceAll(\n                            String.valueOf(ch) + ch, String.valueOf(ch));\n                    } else {\n                        token = tokenUnquoted;\n                    }\n                    checker.accept(token);\n                } else {\n                    if ((options &= OPTION_TOKEN_ONLY) != 0) {\n                        throw genException(\"Non-token detected\", sql);\n                    }\n                }\n                continue;\n            }\n            // Handle tokens enclosed in [...]\n            if (ch == '[') {\n                final int quoteStart = pos;\n                pos++;\n\n                pos = sql.indexOf(']', pos);\n                if (pos < 0) {\n                    throw genException(\"Unterminated quote\", sql);\n                }\n                final int quoteEnd = pos;\n                pos++;\n\n                final String token = sql.substring(quoteStart + 1, quoteEnd);\n\n                checker.accept(token);\n                continue;\n            }\n            if ((options &= OPTION_TOKEN_ONLY) != 0) {\n                throw genException(\"Non-token detected\", sql);\n            }\n\n            // Detect comments.\n            if (ch == '-' && peek(sql, pos + 1) == '-') {\n                pos += 2;\n                pos = sql.indexOf('\\n', pos);\n                if (pos < 0) {\n                    // We disallow strings ending in an inline comment.\n                    throw genException(\"Unterminated comment\", sql);\n                }\n                pos++;\n\n                continue;\n            }\n            if (ch == '/' && peek(sql, pos + 1) == '*') {\n                pos += 2;\n                pos = sql.indexOf(\"*/\", pos);\n                if (pos < 0) {\n                    throw genException(\"Unterminated comment\", sql);\n                }\n                pos += 2;\n\n                continue;\n            }\n\n            // Semicolon is never allowed.\n            if (ch == ';') {\n                throw genException(\"Semicolon is not allowed\", sql);\n            }\n\n            // For this purpose, we can simply ignore other characters.\n            // (Note it doesn't handle the X'' literal properly and reports this X as a token,\n            // but that should be fine...)\n            pos++;\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc tokenize(_ sql: String?, options: Int, checker: (String) -> Void) {\n    guard let sql = sql else {\n        return\n    }\n    var pos = 0\n    let len = sql.count\n    while pos < len {\n        let ch = peek(sql, pos)\n\n        // Regular token.\n        if isAlpha(ch) {\n            let start = pos\n            pos += 1\n            while isAlNum(peek(sql, pos)) {\n                pos += 1\n            }\n            let end = pos\n\n            let token = String(sql[start..<end])\n            checker(token)\n\n            continue\n        }\n\n        // Handle quoted tokens\n        if isAnyOf(ch, \"'\\\"`\") {\n            let quoteStart = pos\n            pos += 1\n\n            while true {\n                pos = sql.index(of: ch, from: pos)\n                if pos < 0 {\n                    throw genException(\"Unterminated quote\", sql)\n                }\n                if peek(sql, pos + 1) != ch {\n                    break\n                }\n                // Quoted quote char -- e.g. \"abc\"\"def\" is a single string.\n                pos += 2\n            }\n            let quoteEnd = pos\n            pos += 1\n\n            if ch != \"'\" {\n                // Extract the token\n                let tokenUnquoted = String(sql[(quoteStart + 1)..<quoteEnd])\n\n                let token: String\n\n                // Unquote if needed. i.e. \"aa\"\"bb\" -> aa\"bb\n                if tokenUnquoted.contains(ch) {\n                    token = tokenUnquoted.replacingOccurrences(of: String(ch) + String(ch), with: String(ch))\n                } else {\n                    token = tokenUnquoted\n                }\n                checker(token)\n            } else {\n                if (options & OPTION_TOKEN_ONLY) != 0 {\n                    throw genException(\"Non-token detected\", sql)\n                }\n            }\n            continue\n        }\n        // Handle tokens enclosed in [...]\n        if ch == \"[\" {\n            let quoteStart = pos\n            pos += 1\n\n            pos = sql.index(of: \"]\", from: pos)\n            if pos < 0 {\n                throw genException(\"Unterminated quote\", sql)\n            }\n            let quoteEnd = pos\n            pos += 1\n\n            let token = String(sql[(quoteStart + 1)..<quoteEnd])\n\n            checker(token)\n            continue\n        }\n        if (options & OPTION_TOKEN_ONLY) != 0 {\n            throw genException(\"Non-token detected\", sql)\n        }\n\n        // Detect comments.\n        if ch == \"-\" && peek(sql, pos + 1) == \"-\" {\n            pos += 2\n            pos = sql.index(of: \"\\n\", from: pos)\n            if pos < 0 {\n                // We disallow strings ending in an inline comment.\n                throw genException(\"Unterminated comment\", sql)\n            }\n            pos += 1\n\n            continue\n        }\n        if ch == \"/\" && peek(sql, pos + 1) == \"*\" {\n            pos += 2\n            pos = sql.index(of: \"*/\", from: pos)\n            if pos < 0 {\n                throw genException(\"Unterminated comment\", sql)\n            }\n            pos += 2\n\n            continue\n        }\n\n        // Semicolon is never allowed.\n        if ch == \";\" {\n            throw genException(\"Semicolon is not allowed\", sql)\n        }\n\n        // For this purpose, we can simply ignore other characters.\n        // (Note it doesn't handle the X'' literal properly and reports this X as a token,\n        // but that should be fine...)\n        pos += 1\n    }\n}\n```"
    },
    {
        "method_name": "isKeyword",
        "method_code": "public static boolean isKeyword(@NonNull String token) {\n        switch (token.toUpperCase(Locale.US)) {\n            case \"ABORT\": case \"ACTION\": case \"ADD\": case \"AFTER\":\n            case \"ALL\": case \"ALTER\": case \"ANALYZE\": case \"AND\":\n            case \"AS\": case \"ASC\": case \"ATTACH\": case \"AUTOINCREMENT\":\n            case \"BEFORE\": case \"BEGIN\": case \"BETWEEN\": case \"BINARY\":\n            case \"BY\": case \"CASCADE\": case \"CASE\": case \"CAST\":\n            case \"CHECK\": case \"COLLATE\": case \"COLUMN\": case \"COMMIT\":\n            case \"CONFLICT\": case \"CONSTRAINT\": case \"CREATE\": case \"CROSS\":\n            case \"CURRENT\": case \"CURRENT_DATE\": case \"CURRENT_TIME\": case \"CURRENT_TIMESTAMP\":\n            case \"DATABASE\": case \"DEFAULT\": case \"DEFERRABLE\": case \"DEFERRED\":\n            case \"DELETE\": case \"DESC\": case \"DETACH\": case \"DISTINCT\":\n            case \"DO\": case \"DROP\": case \"EACH\": case \"ELSE\":\n            case \"END\": case \"ESCAPE\": case \"EXCEPT\": case \"EXCLUDE\":\n            case \"EXCLUSIVE\": case \"EXISTS\": case \"EXPLAIN\": case \"FAIL\":\n            case \"FILTER\": case \"FOLLOWING\": case \"FOR\": case \"FOREIGN\":\n            case \"FROM\": case \"FULL\": case \"GLOB\": case \"GROUP\":\n            case \"GROUPS\": case \"HAVING\": case \"IF\": case \"IGNORE\":\n            case \"IMMEDIATE\": case \"IN\": case \"INDEX\": case \"INDEXED\":\n            case \"INITIALLY\": case \"INNER\": case \"INSERT\": case \"INSTEAD\":\n            case \"INTERSECT\": case \"INTO\": case \"IS\": case \"ISNULL\":\n            case \"JOIN\": case \"KEY\": case \"LEFT\": case \"LIKE\":\n            case \"LIMIT\": case \"MATCH\": case \"NATURAL\": case \"NO\":\n            case \"NOCASE\": case \"NOT\": case \"NOTHING\": case \"NOTNULL\":\n            case \"NULL\": case \"OF\": case \"OFFSET\": case \"ON\":\n            case \"OR\": case \"ORDER\": case \"OTHERS\": case \"OUTER\":\n            case \"OVER\": case \"PARTITION\": case \"PLAN\": case \"PRAGMA\":\n            case \"PRECEDING\": case \"PRIMARY\": case \"QUERY\": case \"RAISE\":\n            case \"RANGE\": case \"RECURSIVE\": case \"REFERENCES\": case \"REGEXP\":\n            case \"REINDEX\": case \"RELEASE\": case \"RENAME\": case \"REPLACE\":\n            case \"RESTRICT\": case \"RIGHT\": case \"ROLLBACK\": case \"ROW\":\n            case \"ROWS\": case \"RTRIM\": case \"SAVEPOINT\": case \"SELECT\":\n            case \"SET\": case \"TABLE\": case \"TEMP\": case \"TEMPORARY\":\n            case \"THEN\": case \"TIES\": case \"TO\": case \"TRANSACTION\":\n            case \"TRIGGER\": case \"UNBOUNDED\": case \"UNION\": case \"UNIQUE\":\n            case \"UPDATE\": case \"USING\": case \"VACUUM\": case \"VALUES\":\n            case \"VIEW\": case \"VIRTUAL\": case \"WHEN\": case \"WHERE\":\n            case \"WINDOW\": case \"WITH\": case \"WITHOUT\":\n                return true;\n            default:\n                return false;\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isKeyword from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isKeyword\n\n        Method Code: public static boolean isKeyword(@NonNull String token) {\n        switch (token.toUpperCase(Locale.US)) {\n            case \"ABORT\": case \"ACTION\": case \"ADD\": case \"AFTER\":\n            case \"ALL\": case \"ALTER\": case \"ANALYZE\": case \"AND\":\n            case \"AS\": case \"ASC\": case \"ATTACH\": case \"AUTOINCREMENT\":\n            case \"BEFORE\": case \"BEGIN\": case \"BETWEEN\": case \"BINARY\":\n            case \"BY\": case \"CASCADE\": case \"CASE\": case \"CAST\":\n            case \"CHECK\": case \"COLLATE\": case \"COLUMN\": case \"COMMIT\":\n            case \"CONFLICT\": case \"CONSTRAINT\": case \"CREATE\": case \"CROSS\":\n            case \"CURRENT\": case \"CURRENT_DATE\": case \"CURRENT_TIME\": case \"CURRENT_TIMESTAMP\":\n            case \"DATABASE\": case \"DEFAULT\": case \"DEFERRABLE\": case \"DEFERRED\":\n            case \"DELETE\": case \"DESC\": case \"DETACH\": case \"DISTINCT\":\n            case \"DO\": case \"DROP\": case \"EACH\": case \"ELSE\":\n            case \"END\": case \"ESCAPE\": case \"EXCEPT\": case \"EXCLUDE\":\n            case \"EXCLUSIVE\": case \"EXISTS\": case \"EXPLAIN\": case \"FAIL\":\n            case \"FILTER\": case \"FOLLOWING\": case \"FOR\": case \"FOREIGN\":\n            case \"FROM\": case \"FULL\": case \"GLOB\": case \"GROUP\":\n            case \"GROUPS\": case \"HAVING\": case \"IF\": case \"IGNORE\":\n            case \"IMMEDIATE\": case \"IN\": case \"INDEX\": case \"INDEXED\":\n            case \"INITIALLY\": case \"INNER\": case \"INSERT\": case \"INSTEAD\":\n            case \"INTERSECT\": case \"INTO\": case \"IS\": case \"ISNULL\":\n            case \"JOIN\": case \"KEY\": case \"LEFT\": case \"LIKE\":\n            case \"LIMIT\": case \"MATCH\": case \"NATURAL\": case \"NO\":\n            case \"NOCASE\": case \"NOT\": case \"NOTHING\": case \"NOTNULL\":\n            case \"NULL\": case \"OF\": case \"OFFSET\": case \"ON\":\n            case \"OR\": case \"ORDER\": case \"OTHERS\": case \"OUTER\":\n            case \"OVER\": case \"PARTITION\": case \"PLAN\": case \"PRAGMA\":\n            case \"PRECEDING\": case \"PRIMARY\": case \"QUERY\": case \"RAISE\":\n            case \"RANGE\": case \"RECURSIVE\": case \"REFERENCES\": case \"REGEXP\":\n            case \"REINDEX\": case \"RELEASE\": case \"RENAME\": case \"REPLACE\":\n            case \"RESTRICT\": case \"RIGHT\": case \"ROLLBACK\": case \"ROW\":\n            case \"ROWS\": case \"RTRIM\": case \"SAVEPOINT\": case \"SELECT\":\n            case \"SET\": case \"TABLE\": case \"TEMP\": case \"TEMPORARY\":\n            case \"THEN\": case \"TIES\": case \"TO\": case \"TRANSACTION\":\n            case \"TRIGGER\": case \"UNBOUNDED\": case \"UNION\": case \"UNIQUE\":\n            case \"UPDATE\": case \"USING\": case \"VACUUM\": case \"VALUES\":\n            case \"VIEW\": case \"VIRTUAL\": case \"WHEN\": case \"WHERE\":\n            case \"WINDOW\": case \"WITH\": case \"WITHOUT\":\n                return true;\n            default:\n                return false;\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isKeyword(_ token: String) -> Bool {\n    switch token.uppercased() {\n    case \"ABORT\", \"ACTION\", \"ADD\", \"AFTER\",\n         \"ALL\", \"ALTER\", \"ANALYZE\", \"AND\",\n         \"AS\", \"ASC\", \"ATTACH\", \"AUTOINCREMENT\",\n         \"BEFORE\", \"BEGIN\", \"BETWEEN\", \"BINARY\",\n         \"BY\", \"CASCADE\", \"CASE\", \"CAST\",\n         \"CHECK\", \"COLLATE\", \"COLUMN\", \"COMMIT\",\n         \"CONFLICT\", \"CONSTRAINT\", \"CREATE\", \"CROSS\",\n         \"CURRENT\", \"CURRENT_DATE\", \"CURRENT_TIME\", \"CURRENT_TIMESTAMP\",\n         \"DATABASE\", \"DEFAULT\", \"DEFERRABLE\", \"DEFERRED\",\n         \"DELETE\", \"DESC\", \"DETACH\", \"DISTINCT\",\n         \"DO\", \"DROP\", \"EACH\", \"ELSE\",\n         \"END\", \"ESCAPE\", \"EXCEPT\", \"EXCLUDE\",\n         \"EXCLUSIVE\", \"EXISTS\", \"EXPLAIN\", \"FAIL\",\n         \"FILTER\", \"FOLLOWING\", \"FOR\", \"FOREIGN\",\n         \"FROM\", \"FULL\", \"GLOB\", \"GROUP\",\n         \"GROUPS\", \"HAVING\", \"IF\", \"IGNORE\",\n         \"IMMEDIATE\", \"IN\", \"INDEX\", \"INDEXED\",\n         \"INITIALLY\", \"INNER\", \"INSERT\", \"INSTEAD\",\n         \"INTERSECT\", \"INTO\", \"IS\", \"ISNULL\",\n         \"JOIN\", \"KEY\", \"LEFT\", \"LIKE\",\n         \"LIMIT\", \"MATCH\", \"NATURAL\", \"NO\",\n         \"NOCASE\", \"NOT\", \"NOTHING\", \"NOTNULL\",\n         \"NULL\", \"OF\", \"OFFSET\", \"ON\",\n         \"OR\", \"ORDER\", \"OTHERS\", \"OUTER\",\n         \"OVER\", \"PARTITION\", \"PLAN\", \"PRAGMA\",\n         \"PRECEDING\", \"PRIMARY\", \"QUERY\", \"RAISE\",\n         \"RANGE\", \"RECURSIVE\", \"REFERENCES\", \"REGEXP\",\n         \"REINDEX\", \"RELEASE\", \"RENAME\", \"REPLACE\",\n         \"RESTRICT\", \"RIGHT\", \"ROLLBACK\", \"ROW\",\n         \"ROWS\", \"RTRIM\", \"SAVEPOINT\", \"SELECT\",\n         \"SET\", \"TABLE\", \"TEMP\", \"TEMPORARY\",\n         \"THEN\", \"TIES\", \"TO\", \"TRANSACTION\",\n         \"TRIGGER\", \"UNBOUNDED\", \"UNION\", \"UNIQUE\",\n         \"UPDATE\", \"USING\", \"VACUUM\", \"VALUES\",\n         \"VIEW\", \"VIRTUAL\", \"WHEN\", \"WHERE\",\n         \"WINDOW\", \"WITH\", \"WITHOUT\":\n        return true\n    default:\n        return false\n    }\n}\n```"
    },
    {
        "method_name": "isFunction",
        "method_code": "public static boolean isFunction(@NonNull String token) {\n        switch (token.toLowerCase(Locale.US)) {\n            case \"abs\": case \"avg\": case \"char\": case \"coalesce\":\n            case \"count\": case \"glob\": case \"group_concat\": case \"hex\":\n            case \"ifnull\": case \"instr\": case \"length\": case \"like\":\n            case \"likelihood\": case \"likely\": case \"lower\": case \"ltrim\":\n            case \"max\": case \"min\": case \"nullif\": case \"random\":\n            case \"randomblob\": case \"replace\": case \"round\": case \"rtrim\":\n            case \"substr\": case \"sum\": case \"total\": case \"trim\":\n            case \"typeof\": case \"unicode\": case \"unlikely\": case \"upper\":\n            case \"zeroblob\":\n                return true;\n            default:\n                return false;\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isFunction from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isFunction\n\n        Method Code: public static boolean isFunction(@NonNull String token) {\n        switch (token.toLowerCase(Locale.US)) {\n            case \"abs\": case \"avg\": case \"char\": case \"coalesce\":\n            case \"count\": case \"glob\": case \"group_concat\": case \"hex\":\n            case \"ifnull\": case \"instr\": case \"length\": case \"like\":\n            case \"likelihood\": case \"likely\": case \"lower\": case \"ltrim\":\n            case \"max\": case \"min\": case \"nullif\": case \"random\":\n            case \"randomblob\": case \"replace\": case \"round\": case \"rtrim\":\n            case \"substr\": case \"sum\": case \"total\": case \"trim\":\n            case \"typeof\": case \"unicode\": case \"unlikely\": case \"upper\":\n            case \"zeroblob\":\n                return true;\n            default:\n                return false;\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isFunction(_ token: String) -> Bool {\n    switch token.lowercased() {\n    case \"abs\", \"avg\", \"char\", \"coalesce\",\n         \"count\", \"glob\", \"group_concat\", \"hex\",\n         \"ifnull\", \"instr\", \"length\", \"like\",\n         \"likelihood\", \"likely\", \"lower\", \"ltrim\",\n         \"max\", \"min\", \"nullif\", \"random\",\n         \"randomblob\", \"replace\", \"round\", \"rtrim\",\n         \"substr\", \"sum\", \"total\", \"trim\",\n         \"typeof\", \"unicode\", \"unlikely\", \"upper\",\n         \"zeroblob\":\n        return true\n    default:\n        return false\n    }\n}\n```"
    },
    {
        "method_name": "isType",
        "method_code": "public static boolean isType(@NonNull String token) {\n        switch (token.toUpperCase(Locale.US)) {\n            case \"INT\": case \"INTEGER\": case \"TINYINT\": case \"SMALLINT\":\n            case \"MEDIUMINT\": case \"BIGINT\": case \"INT2\": case \"INT8\":\n            case \"CHARACTER\": case \"VARCHAR\": case \"NCHAR\": case \"NVARCHAR\":\n            case \"TEXT\": case \"CLOB\": case \"BLOB\": case \"REAL\":\n            case \"DOUBLE\": case \"FLOAT\": case \"NUMERIC\": case \"DECIMAL\":\n            case \"BOOLEAN\": case \"DATE\": case \"DATETIME\":\n                return true;\n            default:\n                return false;\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isType from SQLiteTokenizer.java into Swift.\n\n        Input:\n\n        Method Name: isType\n\n        Method Code: public static boolean isType(@NonNull String token) {\n        switch (token.toUpperCase(Locale.US)) {\n            case \"INT\": case \"INTEGER\": case \"TINYINT\": case \"SMALLINT\":\n            case \"MEDIUMINT\": case \"BIGINT\": case \"INT2\": case \"INT8\":\n            case \"CHARACTER\": case \"VARCHAR\": case \"NCHAR\": case \"NVARCHAR\":\n            case \"TEXT\": case \"CLOB\": case \"BLOB\": case \"REAL\":\n            case \"DOUBLE\": case \"FLOAT\": case \"NUMERIC\": case \"DECIMAL\":\n            case \"BOOLEAN\": case \"DATE\": case \"DATETIME\":\n                return true;\n            default:\n                return false;\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isType(_ token: String) -> Bool {\n    switch token.uppercased() {\n    case \"INT\", \"INTEGER\", \"TINYINT\", \"SMALLINT\", \"MEDIUMINT\", \"BIGINT\", \"INT2\", \"INT8\",\n         \"CHARACTER\", \"VARCHAR\", \"NCHAR\", \"NVARCHAR\", \"TEXT\", \"CLOB\", \"BLOB\", \"REAL\",\n         \"DOUBLE\", \"FLOAT\", \"NUMERIC\", \"DECIMAL\", \"BOOLEAN\", \"DATE\", \"DATETIME\":\n        return true\n    default:\n        return false\n    }\n}\n```"
    }
]