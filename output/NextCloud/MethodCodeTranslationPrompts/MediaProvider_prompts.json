[
    {
        "method_name": "getImageFolders",
        "method_code": "public static List<MediaFolder> getImageFolders(ContentResolver contentResolver,\n                                                    int itemLimit,\n                                                    @Nullable final AppCompatActivity activity,\n                                                    boolean getWithoutActivity,\n                                                    final ViewThemeUtils viewThemeUtils) {\n        // check permissions\n        checkPermissions(activity, viewThemeUtils);\n\n        // query media/image folders\n        Cursor cursorFolders = null;\n        if (activity != null && PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext())\n            || getWithoutActivity) {\n            cursorFolders = ContentResolverHelper.queryResolver(contentResolver, IMAGES_MEDIA_URI,\n                                                                IMAGES_FOLDER_PROJECTION, null, null,\n                                                                IMAGES_FOLDER_SORT_COLUMN, IMAGES_SORT_DIRECTION, null);\n        }\n\n        List<MediaFolder> mediaFolders = new ArrayList<>();\n        String dataPath = MainApp.getStoragePath() + File.separator + MainApp.getDataFolder();\n\n        if (cursorFolders != null) {\n            Cursor cursorImages;\n\n            Map<String, String> uniqueFolders = new HashMap<>();\n\n            // since sdk 29 we have to manually distinct on bucket id\n            while (cursorFolders.moveToNext()) {\n                uniqueFolders.put(cursorFolders.getString(\n                    cursorFolders.getColumnIndexOrThrow(MediaStore.Images.Media.BUCKET_ID)),\n                                  cursorFolders.getString(\n                                      cursorFolders.getColumnIndexOrThrow(MediaStore.Images.Media.BUCKET_DISPLAY_NAME))\n                );\n            }\n            cursorFolders.close();\n\n            for (Map.Entry<String, String> folder : uniqueFolders.entrySet()) {\n                MediaFolder mediaFolder = new MediaFolder();\n\n                mediaFolder.type = MediaFolderType.IMAGE;\n                mediaFolder.folderName = folder.getValue();\n                mediaFolder.filePaths = new ArrayList<>();\n\n                // query images\n                cursorImages = ContentResolverHelper.queryResolver(contentResolver,\n                                                                   IMAGES_MEDIA_URI,\n                                                                   FILE_PROJECTION,\n                                                                   IMAGES_FILE_SELECTION + folder.getKey(),\n                                                                   null,\n                                                                   MediaStore.Images.Media.DATE_TAKEN,\n                                                                   ContentResolverHelper.SORT_DIRECTION_DESCENDING,\n                                                                   itemLimit);\n                Log_OC.d(TAG, \"Reading images for \" + mediaFolder.folderName);\n\n                if (cursorImages != null) {\n                    String filePath;\n                    int imageCount = 0;\n                    while (cursorImages.moveToNext() && imageCount < itemLimit) {\n                        filePath = cursorImages.getString(cursorImages.getColumnIndexOrThrow(\n                            MediaStore.MediaColumns.DATA));\n\n                        // check if valid path and file exists\n                        if (isValidAndExistingFilePath(filePath)) {\n                            mediaFolder.filePaths.add(filePath);\n                            mediaFolder.absolutePath = filePath.substring(0, filePath.lastIndexOf('/'));\n                        }\n                        // ensure we don't go over the limit due to faulty android implementations\n                        imageCount++;\n                    }\n                    cursorImages.close();\n\n                    // only do further work if folder is not within the Nextcloud app itself\n                    if (isFolderOutsideOfAppPath(dataPath, mediaFolder)) {\n\n                        // count images\n                        Cursor count = contentResolver.query(\n                            IMAGES_MEDIA_URI,\n                            FILE_PROJECTION,\n                            IMAGES_FILE_SELECTION + folder.getKey(),\n                            null,\n                            null);\n\n                        if (count != null) {\n                            mediaFolder.numberOfFiles = count.getCount();\n                            count.close();\n                        }\n\n                        mediaFolders.add(mediaFolder);\n                    }\n                }\n            }\n        }\n\n        return mediaFolders;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getImageFolders from MediaProvider.java into Swift.\n\n        Input:\n\n        Method Name: getImageFolders\n\n        Method Code: public static List<MediaFolder> getImageFolders(ContentResolver contentResolver,\n                                                    int itemLimit,\n                                                    @Nullable final AppCompatActivity activity,\n                                                    boolean getWithoutActivity,\n                                                    final ViewThemeUtils viewThemeUtils) {\n        // check permissions\n        checkPermissions(activity, viewThemeUtils);\n\n        // query media/image folders\n        Cursor cursorFolders = null;\n        if (activity != null && PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext())\n            || getWithoutActivity) {\n            cursorFolders = ContentResolverHelper.queryResolver(contentResolver, IMAGES_MEDIA_URI,\n                                                                IMAGES_FOLDER_PROJECTION, null, null,\n                                                                IMAGES_FOLDER_SORT_COLUMN, IMAGES_SORT_DIRECTION, null);\n        }\n\n        List<MediaFolder> mediaFolders = new ArrayList<>();\n        String dataPath = MainApp.getStoragePath() + File.separator + MainApp.getDataFolder();\n\n        if (cursorFolders != null) {\n            Cursor cursorImages;\n\n            Map<String, String> uniqueFolders = new HashMap<>();\n\n            // since sdk 29 we have to manually distinct on bucket id\n            while (cursorFolders.moveToNext()) {\n                uniqueFolders.put(cursorFolders.getString(\n                    cursorFolders.getColumnIndexOrThrow(MediaStore.Images.Media.BUCKET_ID)),\n                                  cursorFolders.getString(\n                                      cursorFolders.getColumnIndexOrThrow(MediaStore.Images.Media.BUCKET_DISPLAY_NAME))\n                );\n            }\n            cursorFolders.close();\n\n            for (Map.Entry<String, String> folder : uniqueFolders.entrySet()) {\n                MediaFolder mediaFolder = new MediaFolder();\n\n                mediaFolder.type = MediaFolderType.IMAGE;\n                mediaFolder.folderName = folder.getValue();\n                mediaFolder.filePaths = new ArrayList<>();\n\n                // query images\n                cursorImages = ContentResolverHelper.queryResolver(contentResolver,\n                                                                   IMAGES_MEDIA_URI,\n                                                                   FILE_PROJECTION,\n                                                                   IMAGES_FILE_SELECTION + folder.getKey(),\n                                                                   null,\n                                                                   MediaStore.Images.Media.DATE_TAKEN,\n                                                                   ContentResolverHelper.SORT_DIRECTION_DESCENDING,\n                                                                   itemLimit);\n                Log_OC.d(TAG, \"Reading images for \" + mediaFolder.folderName);\n\n                if (cursorImages != null) {\n                    String filePath;\n                    int imageCount = 0;\n                    while (cursorImages.moveToNext() && imageCount < itemLimit) {\n                        filePath = cursorImages.getString(cursorImages.getColumnIndexOrThrow(\n                            MediaStore.MediaColumns.DATA));\n\n                        // check if valid path and file exists\n                        if (isValidAndExistingFilePath(filePath)) {\n                            mediaFolder.filePaths.add(filePath);\n                            mediaFolder.absolutePath = filePath.substring(0, filePath.lastIndexOf('/'));\n                        }\n                        // ensure we don't go over the limit due to faulty android implementations\n                        imageCount++;\n                    }\n                    cursorImages.close();\n\n                    // only do further work if folder is not within the Nextcloud app itself\n                    if (isFolderOutsideOfAppPath(dataPath, mediaFolder)) {\n\n                        // count images\n                        Cursor count = contentResolver.query(\n                            IMAGES_MEDIA_URI,\n                            FILE_PROJECTION,\n                            IMAGES_FILE_SELECTION + folder.getKey(),\n                            null,\n                            null);\n\n                        if (count != null) {\n                            mediaFolder.numberOfFiles = count.getCount();\n                            count.close();\n                        }\n\n                        mediaFolders.add(mediaFolder);\n                    }\n                }\n            }\n        }\n\n        return mediaFolders;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport Photos\nimport UIKit\n\nclass MediaProvider {\n    static func getImageFolders(contentResolver: PHFetchResult<PHAssetCollection>,\n                                itemLimit: Int,\n                                activity: UIViewController?,\n                                getWithoutActivity: Bool,\n                                viewThemeUtils: ViewThemeUtils) -> [MediaFolder] {\n        // check permissions\n        checkPermissions(activity: activity, viewThemeUtils: viewThemeUtils)\n\n        var mediaFolders: [MediaFolder] = []\n        let dataPath = MainApp.getStoragePath() + \"/\" + MainApp.getDataFolder()\n\n        if let activity = activity, PermissionUtil.checkExternalStoragePermission(context: activity.view.window?.windowScene?.delegate as? UIWindowScene) || getWithoutActivity {\n            let fetchOptions = PHFetchOptions()\n            fetchOptions.sortDescriptors = [NSSortDescriptor(key: \"startDate\", ascending: false)]\n            let collections = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .albumRegular, options: fetchOptions)\n\n            var uniqueFolders: [String: String] = [:]\n\n            collections.enumerateObjects { (collection, _, _) in\n                uniqueFolders[collection.localIdentifier] = collection.localizedTitle\n            }\n\n            for (key, value) in uniqueFolders {\n                var mediaFolder = MediaFolder()\n                mediaFolder.type = .image\n                mediaFolder.folderName = value\n                mediaFolder.filePaths = []\n\n                let assetsFetchOptions = PHFetchOptions()\n                assetsFetchOptions.predicate = NSPredicate(format: \"mediaType = %d\", PHAssetMediaType.image.rawValue)\n                assetsFetchOptions.sortDescriptors = [NSSortDescriptor(key: \"creationDate\", ascending: false)]\n                assetsFetchOptions.fetchLimit = itemLimit\n\n                let assets = PHAsset.fetchAssets(in: collections.object(at: collections.index(of: key)), options: assetsFetchOptions)\n\n                var imageCount = 0\n                assets.enumerateObjects { (asset, _, _) in\n                    if imageCount < itemLimit {\n                        let options = PHImageRequestOptions()\n                        options.isSynchronous = true\n                        PHImageManager.default().requestImageData(for: asset, options: options) { (data, _, _, info) in\n                            if let filePath = info?[\"PHImageFileURLKey\"] as? URL, isValidAndExistingFilePath(filePath: filePath.path) {\n                                mediaFolder.filePaths.append(filePath.path)\n                                mediaFolder.absolutePath = filePath.deletingLastPathComponent().path\n                            }\n                        }\n                        imageCount += 1\n                    }\n                }\n\n                if isFolderOutsideOfAppPath(dataPath: dataPath, mediaFolder: mediaFolder) {\n                    mediaFolder.numberOfFiles = assets.count\n                    mediaFolders.append(mediaFolder)\n                }\n            }\n        }\n\n        return mediaFolders\n    }\n\n    // Placeholder functions for missing implementations\n    static func checkPermissions(activity: UIViewController?, viewThemeUtils: ViewThemeUtils) {\n        // Implement permission check logic\n    }\n\n    static func isValidAndExistingFilePath(filePath: String) -> Bool {\n        // Implement file path validation logic\n        return true\n    }\n\n    static func isFolderOutsideOfAppPath(dataPath: String, mediaFolder: MediaFolder) -> Bool {\n        // Implement folder path check logic\n        return true\n    }\n}\n```"
    },
    {
        "method_name": "isFolderOutsideOfAppPath",
        "method_code": "private static boolean isFolderOutsideOfAppPath(String dataPath, MediaFolder mediaFolder) {\n        return mediaFolder.absolutePath != null && !mediaFolder.absolutePath.startsWith(dataPath);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isFolderOutsideOfAppPath from MediaProvider.java into Swift.\n\n        Input:\n\n        Method Name: isFolderOutsideOfAppPath\n\n        Method Code: private static boolean isFolderOutsideOfAppPath(String dataPath, MediaFolder mediaFolder) {\n        return mediaFolder.absolutePath != null && !mediaFolder.absolutePath.startsWith(dataPath);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isFolderOutsideOfAppPath(dataPath: String, mediaFolder: MediaFolder) -> Bool {\n    return mediaFolder.absolutePath != nil && !mediaFolder.absolutePath!.hasPrefix(dataPath)\n}\n```"
    },
    {
        "method_name": "isValidAndExistingFilePath",
        "method_code": "private static boolean isValidAndExistingFilePath(String filePath) {\n        return filePath != null && filePath.lastIndexOf('/') > 0 && new File(filePath).exists();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isValidAndExistingFilePath from MediaProvider.java into Swift.\n\n        Input:\n\n        Method Name: isValidAndExistingFilePath\n\n        Method Code: private static boolean isValidAndExistingFilePath(String filePath) {\n        return filePath != null && filePath.lastIndexOf('/') > 0 && new File(filePath).exists();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func isValidAndExistingFilePath(_ filePath: String?) -> Bool {\n    return filePath != nil && filePath!.lastIndex(of: \"/\") != nil && FileManager.default.fileExists(atPath: filePath!)\n}\n```"
    },
    {
        "method_name": "checkPermissions",
        "method_code": "private static void checkPermissions(@Nullable AppCompatActivity activity,\n                                         final ViewThemeUtils viewThemeUtils) {\n        if (activity != null &&\n            !PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext())) {\n            PermissionUtil.requestExternalStoragePermission(activity, viewThemeUtils, true);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled checkPermissions from MediaProvider.java into Swift.\n\n        Input:\n\n        Method Name: checkPermissions\n\n        Method Code: private static void checkPermissions(@Nullable AppCompatActivity activity,\n                                         final ViewThemeUtils viewThemeUtils) {\n        if (activity != null &&\n            !PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext())) {\n            PermissionUtil.requestExternalStoragePermission(activity, viewThemeUtils, true);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func checkPermissions(activity: AppCompatActivity?, viewThemeUtils: ViewThemeUtils) {\n    if let activity = activity, !PermissionUtil.checkExternalStoragePermission(activity.applicationContext) {\n        PermissionUtil.requestExternalStoragePermission(activity, viewThemeUtils: viewThemeUtils, true)\n    }\n}\n```"
    },
    {
        "method_name": "getVideoFolders",
        "method_code": "public static List<MediaFolder> getVideoFolders(ContentResolver contentResolver,\n                                                    int itemLimit,\n                                                    @Nullable final AppCompatActivity activity,\n                                                    boolean getWithoutActivity,\n                                                    final ViewThemeUtils viewThemeUtils) {\n        // check permissions\n        checkPermissions(activity, viewThemeUtils);\n\n        // query media/image folders\n        Cursor cursorFolders = null;\n        if ((activity != null && PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext()))\n            || getWithoutActivity) {\n            cursorFolders = contentResolver.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, VIDEOS_FOLDER_PROJECTION,\n                                                  null, null, null);\n        }\n\n        List<MediaFolder> mediaFolders = new ArrayList<>();\n        String dataPath = MainApp.getStoragePath() + File.separator + MainApp.getDataFolder();\n\n        if (cursorFolders != null) {\n            Cursor cursorVideos;\n\n            Map<String, String> uniqueFolders = new HashMap<>();\n\n            // since sdk 29 we have to manually distinct on bucket id\n            while (cursorFolders.moveToNext()) {\n                uniqueFolders.put(cursorFolders.getString(\n                    cursorFolders.getColumnIndexOrThrow(MediaStore.Video.Media.BUCKET_ID)),\n                                  cursorFolders.getString(\n                                      cursorFolders.getColumnIndexOrThrow(MediaStore.Video.Media.BUCKET_DISPLAY_NAME))\n                );\n            }\n            cursorFolders.close();\n\n            for (Map.Entry<String, String> folder : uniqueFolders.entrySet()) {\n                MediaFolder mediaFolder = new MediaFolder();\n                mediaFolder.type = MediaFolderType.VIDEO;\n                mediaFolder.folderName = folder.getValue();\n                mediaFolder.filePaths = new ArrayList<>();\n\n                // query videos\n                cursorVideos = ContentResolverHelper.queryResolver(contentResolver,\n                                                                   MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                                                                   FILE_PROJECTION,\n                                                                   MediaStore.Video.Media.BUCKET_ID + \"=\" + folder.getKey(),\n                                                                   null,\n                                                                   MediaStore.Video.Media.DATE_TAKEN,\n                                                                   ContentResolverHelper.SORT_DIRECTION_DESCENDING,\n                                                                   itemLimit);\n\n                Log_OC.d(TAG, \"Reading videos for \" + mediaFolder.folderName);\n\n                if (cursorVideos != null) {\n                    String filePath;\n                    int videoCount = 0;\n                    while (cursorVideos.moveToNext() && videoCount < itemLimit) {\n                        filePath = cursorVideos.getString(cursorVideos.getColumnIndexOrThrow(\n                            MediaStore.MediaColumns.DATA));\n\n                        if (filePath != null) {\n                            mediaFolder.filePaths.add(filePath);\n                            mediaFolder.absolutePath = filePath.substring(0, filePath.lastIndexOf('/'));\n                        }\n                        // ensure we don't go over the limit due to faulty android implementations\n                        videoCount++;\n                    }\n                    cursorVideos.close();\n\n                    // only do further work if folder is not within the Nextcloud app itself\n                    if (isFolderOutsideOfAppPath(dataPath, mediaFolder)) {\n\n                        // count images\n                        Cursor count = contentResolver.query(\n                            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                            FILE_PROJECTION,\n                            MediaStore.Video.Media.BUCKET_ID + \"=\" + folder.getKey(),\n                            null,\n                            null);\n\n                        if (count != null) {\n                            mediaFolder.numberOfFiles = count.getCount();\n                            count.close();\n                        }\n\n                        mediaFolders.add(mediaFolder);\n                    }\n                }\n            }\n            cursorFolders.close();\n        }\n\n        return mediaFolders;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getVideoFolders from MediaProvider.java into Swift.\n\n        Input:\n\n        Method Name: getVideoFolders\n\n        Method Code: public static List<MediaFolder> getVideoFolders(ContentResolver contentResolver,\n                                                    int itemLimit,\n                                                    @Nullable final AppCompatActivity activity,\n                                                    boolean getWithoutActivity,\n                                                    final ViewThemeUtils viewThemeUtils) {\n        // check permissions\n        checkPermissions(activity, viewThemeUtils);\n\n        // query media/image folders\n        Cursor cursorFolders = null;\n        if ((activity != null && PermissionUtil.checkExternalStoragePermission(activity.getApplicationContext()))\n            || getWithoutActivity) {\n            cursorFolders = contentResolver.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, VIDEOS_FOLDER_PROJECTION,\n                                                  null, null, null);\n        }\n\n        List<MediaFolder> mediaFolders = new ArrayList<>();\n        String dataPath = MainApp.getStoragePath() + File.separator + MainApp.getDataFolder();\n\n        if (cursorFolders != null) {\n            Cursor cursorVideos;\n\n            Map<String, String> uniqueFolders = new HashMap<>();\n\n            // since sdk 29 we have to manually distinct on bucket id\n            while (cursorFolders.moveToNext()) {\n                uniqueFolders.put(cursorFolders.getString(\n                    cursorFolders.getColumnIndexOrThrow(MediaStore.Video.Media.BUCKET_ID)),\n                                  cursorFolders.getString(\n                                      cursorFolders.getColumnIndexOrThrow(MediaStore.Video.Media.BUCKET_DISPLAY_NAME))\n                );\n            }\n            cursorFolders.close();\n\n            for (Map.Entry<String, String> folder : uniqueFolders.entrySet()) {\n                MediaFolder mediaFolder = new MediaFolder();\n                mediaFolder.type = MediaFolderType.VIDEO;\n                mediaFolder.folderName = folder.getValue();\n                mediaFolder.filePaths = new ArrayList<>();\n\n                // query videos\n                cursorVideos = ContentResolverHelper.queryResolver(contentResolver,\n                                                                   MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                                                                   FILE_PROJECTION,\n                                                                   MediaStore.Video.Media.BUCKET_ID + \"=\" + folder.getKey(),\n                                                                   null,\n                                                                   MediaStore.Video.Media.DATE_TAKEN,\n                                                                   ContentResolverHelper.SORT_DIRECTION_DESCENDING,\n                                                                   itemLimit);\n\n                Log_OC.d(TAG, \"Reading videos for \" + mediaFolder.folderName);\n\n                if (cursorVideos != null) {\n                    String filePath;\n                    int videoCount = 0;\n                    while (cursorVideos.moveToNext() && videoCount < itemLimit) {\n                        filePath = cursorVideos.getString(cursorVideos.getColumnIndexOrThrow(\n                            MediaStore.MediaColumns.DATA));\n\n                        if (filePath != null) {\n                            mediaFolder.filePaths.add(filePath);\n                            mediaFolder.absolutePath = filePath.substring(0, filePath.lastIndexOf('/'));\n                        }\n                        // ensure we don't go over the limit due to faulty android implementations\n                        videoCount++;\n                    }\n                    cursorVideos.close();\n\n                    // only do further work if folder is not within the Nextcloud app itself\n                    if (isFolderOutsideOfAppPath(dataPath, mediaFolder)) {\n\n                        // count images\n                        Cursor count = contentResolver.query(\n                            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                            FILE_PROJECTION,\n                            MediaStore.Video.Media.BUCKET_ID + \"=\" + folder.getKey(),\n                            null,\n                            null);\n\n                        if (count != null) {\n                            mediaFolder.numberOfFiles = count.getCount();\n                            count.close();\n                        }\n\n                        mediaFolders.add(mediaFolder);\n                    }\n                }\n            }\n            cursorFolders.close();\n        }\n\n        return mediaFolders;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport UIKit\nimport Photos\n\nclass MediaProvider {\n    static func getVideoFolders(contentResolver: PHFetchResult<PHAsset>,\n                                itemLimit: Int,\n                                activity: UIViewController?,\n                                getWithoutActivity: Bool,\n                                viewThemeUtils: ViewThemeUtils) -> [MediaFolder] {\n        // check permissions\n        checkPermissions(activity: activity, viewThemeUtils: viewThemeUtils)\n\n        // query media/image folders\n        var mediaFolders: [MediaFolder] = []\n        let dataPath = MainApp.getStoragePath() + \"/\" + MainApp.getDataFolder()\n\n        if (activity != nil && PermissionUtil.checkExternalStoragePermission(context: activity!.view.window!)) || getWithoutActivity {\n            let fetchOptions = PHFetchOptions()\n            fetchOptions.sortDescriptors = [NSSortDescriptor(key: \"creationDate\", ascending: false)]\n            fetchOptions.fetchLimit = itemLimit\n\n            let assets = PHAsset.fetchAssets(with: .video, options: fetchOptions)\n            var uniqueFolders: [String: String] = [:]\n\n            assets.enumerateObjects { (asset, _, _) in\n                if let folderId = asset.value(forKey: \"localIdentifier\") as? String,\n                   let folderName = asset.value(forKey: \"localizedTitle\") as? String {\n                    uniqueFolders[folderId] = folderName\n                }\n            }\n\n            for (folderId, folderName) in uniqueFolders {\n                var mediaFolder = MediaFolder()\n                mediaFolder.type = .video\n                mediaFolder.folderName = folderName\n                mediaFolder.filePaths = []\n\n                let folderAssets = PHAsset.fetchAssets(withLocalIdentifiers: [folderId], options: fetchOptions)\n                var videoCount = 0\n\n                folderAssets.enumerateObjects { (asset, _, _) in\n                    if videoCount < itemLimit {\n                        if let filePath = asset.value(forKey: \"filename\") as? String {\n                            mediaFolder.filePaths.append(filePath)\n                            mediaFolder.absolutePath = (filePath as NSString).deletingLastPathComponent\n                        }\n                        videoCount += 1\n                    }\n                }\n\n                if isFolderOutsideOfAppPath(dataPath: dataPath, mediaFolder: mediaFolder) {\n                    mediaFolder.numberOfFiles = folderAssets.count\n                    mediaFolders.append(mediaFolder)\n                }\n            }\n        }\n\n        return mediaFolders\n    }\n\n    static func checkPermissions(activity: UIViewController?, viewThemeUtils: ViewThemeUtils) {\n        // Implement permission check logic\n    }\n\n    static func isFolderOutsideOfAppPath(dataPath: String, mediaFolder: MediaFolder) -> Bool {\n        // Implement logic to check if folder is outside of app path\n        return true\n    }\n}\n\nclass MediaFolder {\n    var type: MediaFolderType = .video\n    var folderName: String = \"\"\n    var filePaths: [String] = []\n    var absolutePath: String = \"\"\n    var numberOfFiles: Int = 0\n}\n\nenum MediaFolderType {\n    case video\n}\n\nclass MainApp {\n    static func getStoragePath() -> String {\n        return \"/storage/path\"\n    }\n\n    static func getDataFolder() -> String {\n        return \"dataFolder\"\n    }\n}\n\nclass PermissionUtil {\n    static func checkExternalStoragePermission(context: UIWindow) -> Bool {\n        // Implement permission check logic\n        return true\n    }\n}\n\nclass ViewThemeUtils {\n    // Implement ViewThemeUtils class\n}\n```"
    }
]