[
    {
        "method_name": "onCreate",
        "method_code": "@Override\n    public void onCreate() {\n        super.onCreate();\n        AndroidInjection.inject(this);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onCreate from NCFirebaseMessagingService.java into Swift.\n\n        Input:\n\n        Method Name: onCreate\n\n        Method Code: @Override\n    public void onCreate() {\n        super.onCreate();\n        AndroidInjection.inject(this);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onCreate() {\n    super.onCreate()\n    AndroidInjection.inject(self)\n}\n```"
    },
    {
        "method_name": "handleIntent",
        "method_code": "@Override\n    public void handleIntent(Intent intent) {\n        Log_OC.d(TAG, \"handleIntent - extras: \" +\n            ENABLE_NOTIFICATION_NEW + \": \" + intent.getExtras().getString(ENABLE_NOTIFICATION_NEW) + \", \" +\n            ENABLE_NOTIFICATION_OLD + \": \" + intent.getExtras().getString(ENABLE_NOTIFICATION_OLD));\n\n        // When the app is in background and one of the ENABLE_NOTIFICATION or ENABLE_NOTIFICATION_OLD extras is set\n        // to \"1\" in the intent sent from the FCM system code to the FirebaseMessagingService in the application,\n        // the FCM library code that handles the intent DOES NOT invoke the onMessageReceived method.\n        // It just displays the notification by itself.\n        //\n        // In our case the original FCM message contains dummy values \"NEW_NOTIFICATION\" and we need to get the\n        // message in onMessageReceived to decrypt it.\n        //\n        // So we cheat here a little, by telling the FCM library that the notification flag is not set.\n        //\n        // Code below depends on implementation details of the firebase-messaging library (Firebase Android SDK).\n        // https://github.com/firebase/firebase-android-sdk/tree/master/firebase-messaging\n\n        intent.removeExtra(ENABLE_NOTIFICATION_OLD);\n        intent.removeExtra(ENABLE_NOTIFICATION_NEW);\n        intent.putExtra(ENABLE_NOTIFICATION_NEW, \"0\");\n\n        super.handleIntent(intent);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled handleIntent from NCFirebaseMessagingService.java into Swift.\n\n        Input:\n\n        Method Name: handleIntent\n\n        Method Code: @Override\n    public void handleIntent(Intent intent) {\n        Log_OC.d(TAG, \"handleIntent - extras: \" +\n            ENABLE_NOTIFICATION_NEW + \": \" + intent.getExtras().getString(ENABLE_NOTIFICATION_NEW) + \", \" +\n            ENABLE_NOTIFICATION_OLD + \": \" + intent.getExtras().getString(ENABLE_NOTIFICATION_OLD));\n\n        // When the app is in background and one of the ENABLE_NOTIFICATION or ENABLE_NOTIFICATION_OLD extras is set\n        // to \"1\" in the intent sent from the FCM system code to the FirebaseMessagingService in the application,\n        // the FCM library code that handles the intent DOES NOT invoke the onMessageReceived method.\n        // It just displays the notification by itself.\n        //\n        // In our case the original FCM message contains dummy values \"NEW_NOTIFICATION\" and we need to get the\n        // message in onMessageReceived to decrypt it.\n        //\n        // So we cheat here a little, by telling the FCM library that the notification flag is not set.\n        //\n        // Code below depends on implementation details of the firebase-messaging library (Firebase Android SDK).\n        // https://github.com/firebase/firebase-android-sdk/tree/master/firebase-messaging\n\n        intent.removeExtra(ENABLE_NOTIFICATION_OLD);\n        intent.removeExtra(ENABLE_NOTIFICATION_NEW);\n        intent.putExtra(ENABLE_NOTIFICATION_NEW, \"0\");\n\n        super.handleIntent(intent);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func handleIntent(_ intent: Intent) {\n    Log_OC.d(TAG, \"handleIntent - extras: \" +\n        \"\\(ENABLE_NOTIFICATION_NEW): \\(intent.extras?.getString(ENABLE_NOTIFICATION_NEW) ?? \"\"), \" +\n        \"\\(ENABLE_NOTIFICATION_OLD): \\(intent.extras?.getString(ENABLE_NOTIFICATION_OLD) ?? \"\")\")\n\n    intent.removeExtra(ENABLE_NOTIFICATION_OLD)\n    intent.removeExtra(ENABLE_NOTIFICATION_NEW)\n    intent.putExtra(ENABLE_NOTIFICATION_NEW, \"0\")\n\n    super.handleIntent(intent)\n}\n```"
    },
    {
        "method_name": "onMessageReceived",
        "method_code": "@Override\n    public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {\n        Log_OC.d(TAG, \"onMessageReceived\");\n        final Map<String, String> data = remoteMessage.getData();\n        final String subject = data.get(NotificationWork.KEY_NOTIFICATION_SUBJECT);\n        final String signature = data.get(NotificationWork.KEY_NOTIFICATION_SIGNATURE);\n        if (subject != null && signature != null) {\n            backgroundJobManager.startNotificationJob(subject, signature);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onMessageReceived from NCFirebaseMessagingService.java into Swift.\n\n        Input:\n\n        Method Name: onMessageReceived\n\n        Method Code: @Override\n    public void onMessageReceived(@NonNull RemoteMessage remoteMessage) {\n        Log_OC.d(TAG, \"onMessageReceived\");\n        final Map<String, String> data = remoteMessage.getData();\n        final String subject = data.get(NotificationWork.KEY_NOTIFICATION_SUBJECT);\n        final String signature = data.get(NotificationWork.KEY_NOTIFICATION_SIGNATURE);\n        if (subject != null && signature != null) {\n            backgroundJobManager.startNotificationJob(subject, signature);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func didReceive(_ remoteMessage: MessagingRemoteMessage) {\n    print(\"onMessageReceived\")\n    let data = remoteMessage.appData\n    if let subject = data[NotificationWork.KEY_NOTIFICATION_SUBJECT] as? String,\n       let signature = data[NotificationWork.KEY_NOTIFICATION_SIGNATURE] as? String {\n        backgroundJobManager.startNotificationJob(subject: subject, signature: signature)\n    }\n}\n```"
    },
    {
        "method_name": "onNewToken",
        "method_code": "@Override\n    public void onNewToken(@NonNull String newToken) {\n        Log_OC.d(TAG, \"onNewToken\");\n        super.onNewToken(newToken);\n\n        if (!TextUtils.isEmpty(getResources().getString(R.string.push_server_url))) {\n            preferences.setPushToken(newToken);\n            PushUtils.pushRegistrationToServer(accountManager, preferences.getPushToken());\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onNewToken from NCFirebaseMessagingService.java into Swift.\n\n        Input:\n\n        Method Name: onNewToken\n\n        Method Code: @Override\n    public void onNewToken(@NonNull String newToken) {\n        Log_OC.d(TAG, \"onNewToken\");\n        super.onNewToken(newToken);\n\n        if (!TextUtils.isEmpty(getResources().getString(R.string.push_server_url))) {\n            preferences.setPushToken(newToken);\n            PushUtils.pushRegistrationToServer(accountManager, preferences.getPushToken());\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func didReceiveRegistrationToken(_ fcmToken: String) {\n    print(\"onNewToken\")\n    super.didReceiveRegistrationToken(fcmToken)\n\n    if !getResources().getString(R.string.push_server_url).isEmpty {\n        preferences.setPushToken(fcmToken)\n        PushUtils.pushRegistrationToServer(accountManager, preferences.getPushToken())\n    }\n}\n```"
    }
]