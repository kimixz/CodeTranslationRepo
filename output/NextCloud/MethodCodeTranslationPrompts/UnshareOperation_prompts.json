[
    {
        "method_name": "run",
        "method_code": "Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        RemoteOperationResult result;\n        String token = null;\n\n        // Get Share for a file\n        OCShare share = getStorageManager().getShareById(shareId);\n\n        if (share != null) {\n            OCFile file = getStorageManager().getFileByEncryptedRemotePath(remotePath);\n\n            if (file.isEncrypted() && share.getShareType() != ShareType.PUBLIC_LINK) {\n                // E2E: lock folder\n                try {\n                    token = EncryptionUtils.lockFolder(file, client, file.getE2eCounter() + 1);\n                } catch (UploadException e) {\n                    return new RemoteOperationResult(e);\n                }\n\n                // download metadata\n                Object object = EncryptionUtils.downloadFolderMetadata(file,\n                                                                       client,\n                                                                       context,\n                                                                       user);\n\n                if (object == null) {\n                    return new RemoteOperationResult(new RuntimeException(\"No metadata!\"));\n                }\n\n                if (object instanceof DecryptedFolderMetadataFileV1) {\n                    throw new RuntimeException(\"Trying to unshare on e2e v1!\");\n                }\n\n                DecryptedFolderMetadataFile metadata = (DecryptedFolderMetadataFile) object;\n\n                // remove sharee from metadata\n                EncryptionUtilsV2 encryptionUtilsV2 = new EncryptionUtilsV2();\n                DecryptedFolderMetadataFile newMetadata = encryptionUtilsV2.removeShareeFromMetadata(metadata,\n                                                                                                     share.getShareWith());\n\n                // upload metadata\n                try {\n                    encryptionUtilsV2.serializeAndUploadMetadata(file,\n                                                                 newMetadata,\n                                                                 token,\n                                                                 client,\n                                                                 true,\n                                                                 context,\n                                                                 user,\n                                                                 getStorageManager());\n                } catch (UploadException e) {\n                    return new RemoteOperationResult(new RuntimeException(\"Upload of metadata failed!\"));\n                }\n            }\n\n            RemoveShareRemoteOperation operation = new RemoveShareRemoteOperation(share.getRemoteId());\n            result = operation.execute(client);\n\n            if (result.isSuccess()) {\n                // E2E: unlock folder\n                if (file.isEncrypted() && share.getShareType() != ShareType.PUBLIC_LINK) {\n                    RemoteOperationResult<Void> unlockResult = EncryptionUtils.unlockFolder(file, client, token);\n                    if (!unlockResult.isSuccess()) {\n                        return new RemoteOperationResult<>(new RuntimeException(\"Unlock failed\"));\n                    }\n                }\n\n                Log_OC.d(TAG, \"Share id = \" + share.getRemoteId() + \" deleted\");\n\n                if (ShareType.PUBLIC_LINK == share.getShareType()) {\n                    file.setSharedViaLink(false);\n                } else if (ShareType.USER == share.getShareType() || ShareType.GROUP == share.getShareType()\n                    || ShareType.FEDERATED == share.getShareType()) {\n                    // Check if it is the last share\n                    List<OCShare> sharesWith = getStorageManager().\n                        getSharesWithForAFile(remotePath,\n                                              getStorageManager().getUser().getAccountName());\n                    if (sharesWith.size() == SINGLY_SHARED) {\n                        file.setSharedWithSharee(false);\n                    }\n                }\n\n                getStorageManager().saveFile(file);\n                getStorageManager().removeShare(share);\n\n            } else if (result.getCode() != ResultCode.MAINTENANCE_MODE && !existsFile(client, file.getRemotePath())) {\n                // unshare failed because file was deleted before\n                getStorageManager().removeFile(file, true, true);\n            }\n\n        } else {\n            result = new RemoteOperationResult(ResultCode.SHARE_NOT_FOUND);\n        }\n\n        return result;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled run from UnshareOperation.java into Swift.\n\n        Input:\n\n        Method Name: run\n\n        Method Code: Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        RemoteOperationResult result;\n        String token = null;\n\n        // Get Share for a file\n        OCShare share = getStorageManager().getShareById(shareId);\n\n        if (share != null) {\n            OCFile file = getStorageManager().getFileByEncryptedRemotePath(remotePath);\n\n            if (file.isEncrypted() && share.getShareType() != ShareType.PUBLIC_LINK) {\n                // E2E: lock folder\n                try {\n                    token = EncryptionUtils.lockFolder(file, client, file.getE2eCounter() + 1);\n                } catch (UploadException e) {\n                    return new RemoteOperationResult(e);\n                }\n\n                // download metadata\n                Object object = EncryptionUtils.downloadFolderMetadata(file,\n                                                                       client,\n                                                                       context,\n                                                                       user);\n\n                if (object == null) {\n                    return new RemoteOperationResult(new RuntimeException(\"No metadata!\"));\n                }\n\n                if (object instanceof DecryptedFolderMetadataFileV1) {\n                    throw new RuntimeException(\"Trying to unshare on e2e v1!\");\n                }\n\n                DecryptedFolderMetadataFile metadata = (DecryptedFolderMetadataFile) object;\n\n                // remove sharee from metadata\n                EncryptionUtilsV2 encryptionUtilsV2 = new EncryptionUtilsV2();\n                DecryptedFolderMetadataFile newMetadata = encryptionUtilsV2.removeShareeFromMetadata(metadata,\n                                                                                                     share.getShareWith());\n\n                // upload metadata\n                try {\n                    encryptionUtilsV2.serializeAndUploadMetadata(file,\n                                                                 newMetadata,\n                                                                 token,\n                                                                 client,\n                                                                 true,\n                                                                 context,\n                                                                 user,\n                                                                 getStorageManager());\n                } catch (UploadException e) {\n                    return new RemoteOperationResult(new RuntimeException(\"Upload of metadata failed!\"));\n                }\n            }\n\n            RemoveShareRemoteOperation operation = new RemoveShareRemoteOperation(share.getRemoteId());\n            result = operation.execute(client);\n\n            if (result.isSuccess()) {\n                // E2E: unlock folder\n                if (file.isEncrypted() && share.getShareType() != ShareType.PUBLIC_LINK) {\n                    RemoteOperationResult<Void> unlockResult = EncryptionUtils.unlockFolder(file, client, token);\n                    if (!unlockResult.isSuccess()) {\n                        return new RemoteOperationResult<>(new RuntimeException(\"Unlock failed\"));\n                    }\n                }\n\n                Log_OC.d(TAG, \"Share id = \" + share.getRemoteId() + \" deleted\");\n\n                if (ShareType.PUBLIC_LINK == share.getShareType()) {\n                    file.setSharedViaLink(false);\n                } else if (ShareType.USER == share.getShareType() || ShareType.GROUP == share.getShareType()\n                    || ShareType.FEDERATED == share.getShareType()) {\n                    // Check if it is the last share\n                    List<OCShare> sharesWith = getStorageManager().\n                        getSharesWithForAFile(remotePath,\n                                              getStorageManager().getUser().getAccountName());\n                    if (sharesWith.size() == SINGLY_SHARED) {\n                        file.setSharedWithSharee(false);\n                    }\n                }\n\n                getStorageManager().saveFile(file);\n                getStorageManager().removeShare(share);\n\n            } else if (result.getCode() != ResultCode.MAINTENANCE_MODE && !existsFile(client, file.getRemotePath())) {\n                // unshare failed because file was deleted before\n                getStorageManager().removeFile(file, true, true);\n            }\n\n        } else {\n            result = new RemoteOperationResult(ResultCode.SHARE_NOT_FOUND);\n        }\n\n        return result;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func run(client: OwnCloudClient) -> RemoteOperationResult {\n    var result: RemoteOperationResult\n    var token: String? = nil\n\n    // Get Share for a file\n    if let share = getStorageManager().getShareById(shareId) {\n        if let file = getStorageManager().getFileByEncryptedRemotePath(remotePath) {\n            if file.isEncrypted() && share.shareType != .publicLink {\n                // E2E: lock folder\n                do {\n                    token = try EncryptionUtils.lockFolder(file: file, client: client, counter: file.e2eCounter + 1)\n                } catch let e as UploadException {\n                    return RemoteOperationResult(e)\n                } catch {\n                    return RemoteOperationResult(error)\n                }\n\n                // download metadata\n                let object = EncryptionUtils.downloadFolderMetadata(file: file, client: client, context: context, user: user)\n\n                guard let metadataObject = object else {\n                    return RemoteOperationResult(RuntimeException(\"No metadata!\"))\n                }\n\n                if metadataObject is DecryptedFolderMetadataFileV1 {\n                    fatalError(\"Trying to unshare on e2e v1!\")\n                }\n\n                guard let metadata = metadataObject as? DecryptedFolderMetadataFile else {\n                    return RemoteOperationResult(RuntimeException(\"Invalid metadata type!\"))\n                }\n\n                // remove sharee from metadata\n                let encryptionUtilsV2 = EncryptionUtilsV2()\n                let newMetadata = encryptionUtilsV2.removeShareeFromMetadata(metadata: metadata, sharee: share.shareWith)\n\n                // upload metadata\n                do {\n                    try encryptionUtilsV2.serializeAndUploadMetadata(file: file, metadata: newMetadata, token: token, client: client, overwrite: true, context: context, user: user, storageManager: getStorageManager())\n                } catch let e as UploadException {\n                    return RemoteOperationResult(RuntimeException(\"Upload of metadata failed!\"))\n                } catch {\n                    return RemoteOperationResult(error)\n                }\n            }\n\n            let operation = RemoveShareRemoteOperation(remoteId: share.remoteId)\n            result = operation.execute(client: client)\n\n            if result.isSuccess {\n                // E2E: unlock folder\n                if file.isEncrypted() && share.shareType != .publicLink {\n                    let unlockResult = EncryptionUtils.unlockFolder(file: file, client: client, token: token)\n                    if !unlockResult.isSuccess {\n                        return RemoteOperationResult(RuntimeException(\"Unlock failed\"))\n                    }\n                }\n\n                Log_OC.d(TAG, \"Share id = \\(share.remoteId) deleted\")\n\n                if share.shareType == .publicLink {\n                    file.setSharedViaLink(false)\n                } else if share.shareType == .user || share.shareType == .group || share.shareType == .federated {\n                    // Check if it is the last share\n                    let sharesWith = getStorageManager().getSharesWithForAFile(remotePath: remotePath, accountName: getStorageManager().getUser().accountName)\n                    if sharesWith.count == SINGLY_SHARED {\n                        file.setSharedWithSharee(false)\n                    }\n                }\n\n                getStorageManager().saveFile(file)\n                getStorageManager().removeShare(share)\n\n            } else if result.code != .maintenanceMode && !existsFile(client: client, remotePath: file.remotePath) {\n                // unshare failed because file was deleted before\n                getStorageManager().removeFile(file, removeLocal: true, removeRemote: true)\n            }\n\n        } else {\n            result = RemoteOperationResult(ResultCode.shareNotFound)\n        }\n    } else {\n        result = RemoteOperationResult(ResultCode.shareNotFound)\n    }\n\n    return result\n}\n```"
    },
    {
        "method_name": "existsFile",
        "method_code": "rivate boolean existsFile(OwnCloudClient client, String remotePath) {\n        return new ExistenceCheckRemoteOperation(remotePath, false).execute(client).isSuccess();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled existsFile from UnshareOperation.java into Swift.\n\n        Input:\n\n        Method Name: existsFile\n\n        Method Code: rivate boolean existsFile(OwnCloudClient client, String remotePath) {\n        return new ExistenceCheckRemoteOperation(remotePath, false).execute(client).isSuccess();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func existsFile(client: OwnCloudClient, remotePath: String) -> Bool {\n    return ExistenceCheckRemoteOperation(remotePath: remotePath, isFolder: false).execute(client: client).isSuccess()\n}\n```"
    }
]