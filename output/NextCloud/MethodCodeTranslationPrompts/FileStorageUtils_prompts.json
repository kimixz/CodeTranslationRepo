[
    {
        "method_name": "getSavePath",
        "method_code": "ublic static String getSavePath(String accountName) {\n        return MainApp.getStoragePath()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getSavePath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getSavePath\n\n        Method Code: ublic static String getSavePath(String accountName) {\n        return MainApp.getStoragePath()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSavePath(accountName: String) -> String {\n    let storagePath = MainApp.getStoragePath()\n    let dataFolder = MainApp.getDataFolder()\n    let encodedAccountName = accountName.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? accountName\n    return \"\\(storagePath)/\\(dataFolder)/\\(encodedAccountName)\"\n}\n```"
    },
    {
        "method_name": "getDefaultSavePathFor",
        "method_code": "ublic static String getDefaultSavePathFor(String accountName, OCFile file) {\n        return getSavePath(accountName) + file.getDecryptedRemotePath();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDefaultSavePathFor from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getDefaultSavePathFor\n\n        Method Code: ublic static String getDefaultSavePathFor(String accountName, OCFile file) {\n        return getSavePath(accountName) + file.getDecryptedRemotePath();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func getDefaultSavePathFor(accountName: String, file: OCFile) -> String {\n    return getSavePath(accountName: accountName) + file.getDecryptedRemotePath()\n}\n```"
    },
    {
        "method_name": "getTemporalPath",
        "method_code": "ublic static String getTemporalPath(String accountName) {\n        // FIXME broken in SDK 30\n        return MainApp.getStoragePath()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + \"tmp\"\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getTemporalPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getTemporalPath\n\n        Method Code: ublic static String getTemporalPath(String accountName) {\n        // FIXME broken in SDK 30\n        return MainApp.getStoragePath()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + \"tmp\"\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getTemporalPath(accountName: String) -> String {\n    // FIXME broken in SDK 30\n    return MainApp.getStoragePath()\n        + \"/\" \n        + MainApp.getDataFolder()\n        + \"/\"\n        + \"tmp\"\n        + \"/\"\n        + accountName.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!\n    // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n    // that can be in the accountName since 0.1.190B\n}\n```"
    },
    {
        "method_name": "getTemporalEncryptedFolderPath",
        "method_code": "ublic static String getTemporalEncryptedFolderPath(String accountName) {\n        return MainApp\n            .getAppContext()\n            .getFilesDir()\n            .getAbsolutePath()\n            + File.separator\n            + accountName\n            + File.separator\n            + \"temp_encrypted_folder\";\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getTemporalEncryptedFolderPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getTemporalEncryptedFolderPath\n\n        Method Code: ublic static String getTemporalEncryptedFolderPath(String accountName) {\n        return MainApp\n            .getAppContext()\n            .getFilesDir()\n            .getAbsolutePath()\n            + File.separator\n            + accountName\n            + File.separator\n            + \"temp_encrypted_folder\";\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getTemporalEncryptedFolderPath(accountName: String) -> String {\n    let appContext = MainApp.getAppContext()\n    let filesDir = appContext.filesDir\n    let path = filesDir.appendingPathComponent(accountName).appendingPathComponent(\"temp_encrypted_folder\")\n    return path.path\n}\n```"
    },
    {
        "method_name": "getInternalTemporalPath",
        "method_code": "ublic static String getInternalTemporalPath(String accountName, Context context) {\n        return context.getFilesDir()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + \"tmp\"\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getInternalTemporalPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getInternalTemporalPath\n\n        Method Code: ublic static String getInternalTemporalPath(String accountName, Context context) {\n        return context.getFilesDir()\n                + File.separator\n                + MainApp.getDataFolder()\n                + File.separator\n                + \"tmp\"\n                + File.separator\n                + Uri.encode(accountName, \"@\");\n        // URL encoding is an 'easy fix' to overcome that NTFS and FAT32 don't allow \":\" in file names,\n        // that can be in the accountName since 0.1.190B\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getInternalTemporalPath(accountName: String, context: Context) -> String {\n    let filesDir = context.filesDir\n    let dataFolder = MainApp.getDataFolder()\n    let encodedAccountName = accountName.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? accountName\n    return \"\\(filesDir)/\\(dataFolder)/tmp/\\(encodedAccountName)\"\n}\n```"
    },
    {
        "method_name": "getUsableSpace",
        "method_code": "ublic static long getUsableSpace() {\n        File savePath = new File(MainApp.getStoragePath());\n        return savePath.getUsableSpace();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getUsableSpace from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getUsableSpace\n\n        Method Code: ublic static long getUsableSpace() {\n        File savePath = new File(MainApp.getStoragePath());\n        return savePath.getUsableSpace();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func getUsableSpace() -> Int64 {\n    let savePath = URL(fileURLWithPath: MainApp.getStoragePath())\n    do {\n        let values = try savePath.resourceValues(forKeys: [.volumeAvailableCapacityForImportantUsageKey])\n        return values.volumeAvailableCapacityForImportantUsage ?? 0\n    } catch {\n        return 0\n    }\n}\n```"
    },
    {
        "method_name": "getSubPathFromDate",
        "method_code": "rivate static String getSubPathFromDate(long date, Locale currentLocale, SubFolderRule subFolderRule) {\n        if (date == 0) {\n            return \"\";\n        }\n        String datePattern = \"\";\n        if (subFolderRule == SubFolderRule.YEAR) {\n            datePattern = PATTERN_YYYY;\n        } else if (subFolderRule == SubFolderRule.YEAR_MONTH) {\n            datePattern = PATTERN_YYYY_MM;\n        } else if (subFolderRule == SubFolderRule.YEAR_MONTH_DAY) {\n            datePattern = PATTERN_YYYY_MM_DD;\n        }\n\n        Date d = new Date(date);\n\n        DateFormat df = new SimpleDateFormat(datePattern, currentLocale);\n        df.setTimeZone(TimeZone.getTimeZone(TimeZone.getDefault().getID()));\n\n        return df.format(d);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getSubPathFromDate from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getSubPathFromDate\n\n        Method Code: rivate static String getSubPathFromDate(long date, Locale currentLocale, SubFolderRule subFolderRule) {\n        if (date == 0) {\n            return \"\";\n        }\n        String datePattern = \"\";\n        if (subFolderRule == SubFolderRule.YEAR) {\n            datePattern = PATTERN_YYYY;\n        } else if (subFolderRule == SubFolderRule.YEAR_MONTH) {\n            datePattern = PATTERN_YYYY_MM;\n        } else if (subFolderRule == SubFolderRule.YEAR_MONTH_DAY) {\n            datePattern = PATTERN_YYYY_MM_DD;\n        }\n\n        Date d = new Date(date);\n\n        DateFormat df = new SimpleDateFormat(datePattern, currentLocale);\n        df.setTimeZone(TimeZone.getTimeZone(TimeZone.getDefault().getID()));\n\n        return df.format(d);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func getSubPathFromDate(date: Int64, currentLocale: Locale, subFolderRule: SubFolderRule) -> String {\n    if date == 0 {\n        return \"\"\n    }\n    var datePattern = \"\"\n    switch subFolderRule {\n    case .YEAR:\n        datePattern = PATTERN_YYYY\n    case .YEAR_MONTH:\n        datePattern = PATTERN_YYYY_MM\n    case .YEAR_MONTH_DAY:\n        datePattern = PATTERN_YYYY_MM_DD\n    }\n\n    let d = Date(timeIntervalSince1970: TimeInterval(date) / 1000)\n    let df = DateFormatter()\n    df.dateFormat = datePattern\n    df.locale = currentLocale\n    df.timeZone = TimeZone.current\n\n    return df.string(from: d)\n}\n```"
    },
    {
        "method_name": "getInstantUploadFilePath",
        "method_code": "ublic static String getInstantUploadFilePath(File file,\n                                                  Locale current,\n                                                  String remotePath,\n                                                  String syncedFolderLocalPath,\n                                                  long dateTaken,\n                                                  Boolean subfolderByDate,\n                                                  SubFolderRule subFolderRule) {\n        String subfolderByDatePath = \"\";\n        if (subfolderByDate) {\n            subfolderByDatePath = getSubPathFromDate(dateTaken, current, subFolderRule);\n        }\n\n        File parentFile = new File(file.getAbsolutePath().replace(syncedFolderLocalPath, \"\")).getParentFile();\n\n        String relativeSubfolderPath = \"\";\n        if (parentFile == null) {\n            Log_OC.e(\"AutoUpload\", \"Parent folder does not exist!\");\n        } else {\n            relativeSubfolderPath = parentFile.getAbsolutePath();\n        }\n\n        // Path must be normalized; otherwise the next RefreshFolderOperation has a mismatch and deletes the local file.\n        return (remotePath +\n            OCFile.PATH_SEPARATOR +\n            subfolderByDatePath +\n            OCFile.PATH_SEPARATOR +\n            relativeSubfolderPath +\n            OCFile.PATH_SEPARATOR +\n            file.getName())\n            .replaceAll(OCFile.PATH_SEPARATOR + \"+\", OCFile.PATH_SEPARATOR);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getInstantUploadFilePath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getInstantUploadFilePath\n\n        Method Code: ublic static String getInstantUploadFilePath(File file,\n                                                  Locale current,\n                                                  String remotePath,\n                                                  String syncedFolderLocalPath,\n                                                  long dateTaken,\n                                                  Boolean subfolderByDate,\n                                                  SubFolderRule subFolderRule) {\n        String subfolderByDatePath = \"\";\n        if (subfolderByDate) {\n            subfolderByDatePath = getSubPathFromDate(dateTaken, current, subFolderRule);\n        }\n\n        File parentFile = new File(file.getAbsolutePath().replace(syncedFolderLocalPath, \"\")).getParentFile();\n\n        String relativeSubfolderPath = \"\";\n        if (parentFile == null) {\n            Log_OC.e(\"AutoUpload\", \"Parent folder does not exist!\");\n        } else {\n            relativeSubfolderPath = parentFile.getAbsolutePath();\n        }\n\n        // Path must be normalized; otherwise the next RefreshFolderOperation has a mismatch and deletes the local file.\n        return (remotePath +\n            OCFile.PATH_SEPARATOR +\n            subfolderByDatePath +\n            OCFile.PATH_SEPARATOR +\n            relativeSubfolderPath +\n            OCFile.PATH_SEPARATOR +\n            file.getName())\n            .replaceAll(OCFile.PATH_SEPARATOR + \"+\", OCFile.PATH_SEPARATOR);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getInstantUploadFilePath(file: URL, current: Locale, remotePath: String, syncedFolderLocalPath: String, dateTaken: TimeInterval, subfolderByDate: Bool, subFolderRule: SubFolderRule) -> String {\n    var subfolderByDatePath = \"\"\n    if subfolderByDate {\n        subfolderByDatePath = getSubPathFromDate(dateTaken: dateTaken, current: current, subFolderRule: subFolderRule)\n    }\n\n    let parentFile = URL(fileURLWithPath: file.path.replacingOccurrences(of: syncedFolderLocalPath, with: \"\")).deletingLastPathComponent()\n\n    var relativeSubfolderPath = \"\"\n    if parentFile.path.isEmpty {\n        print(\"AutoUpload: Parent folder does not exist!\")\n    } else {\n        relativeSubfolderPath = parentFile.path\n    }\n\n    let pathSeparator = \"/\"\n    let fullPath = remotePath + pathSeparator + subfolderByDatePath + pathSeparator + relativeSubfolderPath + pathSeparator + file.lastPathComponent\n    return fullPath.replacingOccurrences(of: pathSeparator + \"+\", with: pathSeparator, options: .regularExpression)\n}\n```"
    },
    {
        "method_name": "getParentPath",
        "method_code": "ublic static String getParentPath(String remotePath) {\n        String parentPath = new File(remotePath).getParent();\n        if (parentPath != null) {\n            parentPath = parentPath.endsWith(OCFile.PATH_SEPARATOR) ? parentPath : parentPath + OCFile.PATH_SEPARATOR;\n        }\n        return parentPath;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getParentPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getParentPath\n\n        Method Code: ublic static String getParentPath(String remotePath) {\n        String parentPath = new File(remotePath).getParent();\n        if (parentPath != null) {\n            parentPath = parentPath.endsWith(OCFile.PATH_SEPARATOR) ? parentPath : parentPath + OCFile.PATH_SEPARATOR;\n        }\n        return parentPath;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getParentPath(remotePath: String) -> String? {\n    let parentPath = URL(fileURLWithPath: remotePath).deletingLastPathComponent().path\n    if !parentPath.isEmpty {\n        return parentPath.hasSuffix(OCFile.PATH_SEPARATOR) ? parentPath : parentPath + OCFile.PATH_SEPARATOR\n    }\n    return nil\n}\n```"
    },
    {
        "method_name": "fillOCFile",
        "method_code": "ublic static OCFile fillOCFile(RemoteFile remote) {\n        OCFile file = new OCFile(remote.getRemotePath());\n        file.setDecryptedRemotePath(remote.getRemotePath());\n        file.setCreationTimestamp(remote.getCreationTimestamp());\n        if (MimeType.DIRECTORY.equalsIgnoreCase(remote.getMimeType())) {\n            file.setFileLength(remote.getSize());\n        } else {\n            file.setFileLength(remote.getLength());\n        }\n        file.setMimeType(remote.getMimeType());\n        file.setModificationTimestamp(remote.getModifiedTimestamp());\n        file.setEtag(remote.getEtag());\n        file.setPermissions(remote.getPermissions());\n        file.setRemoteId(remote.getRemoteId());\n        file.setLocalId(remote.getLocalId());\n        file.setFavorite(remote.isFavorite());\n        if (file.isFolder()) {\n            file.setEncrypted(remote.isEncrypted());\n        }\n        file.setMountType(remote.getMountType());\n        file.setPreviewAvailable(remote.isHasPreview());\n        file.setUnreadCommentsCount(remote.getUnreadCommentsCount());\n        file.setOwnerId(remote.getOwnerId());\n        file.setOwnerDisplayName(remote.getOwnerDisplayName());\n        file.setNote(remote.getNote());\n        file.setSharees(new ArrayList<ShareeUser>(Arrays.asList(remote.getSharees())));\n        file.setRichWorkspace(remote.getRichWorkspace());\n        file.setLocked(remote.isLocked());\n        file.setLockType(remote.getLockType());\n        file.setLockOwnerId(remote.getLockOwner());\n        file.setLockOwnerDisplayName(remote.getLockOwnerDisplayName());\n        file.setLockOwnerEditor(remote.getLockOwnerEditor());\n        file.setLockTimestamp(remote.getLockTimestamp());\n        file.setLockTimeout(remote.getLockTimeout());\n        file.setLockToken(remote.getLockToken());\n        file.setTags(new ArrayList<>(Arrays.asList(remote.getTags())));\n        file.setImageDimension(remote.getImageDimension());\n        file.setGeoLocation(remote.getGeoLocation());\n        file.setLivePhoto(remote.getLivePhoto());\n        file.setHidden(remote.getHidden());\n\n        return file;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled fillOCFile from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: fillOCFile\n\n        Method Code: ublic static OCFile fillOCFile(RemoteFile remote) {\n        OCFile file = new OCFile(remote.getRemotePath());\n        file.setDecryptedRemotePath(remote.getRemotePath());\n        file.setCreationTimestamp(remote.getCreationTimestamp());\n        if (MimeType.DIRECTORY.equalsIgnoreCase(remote.getMimeType())) {\n            file.setFileLength(remote.getSize());\n        } else {\n            file.setFileLength(remote.getLength());\n        }\n        file.setMimeType(remote.getMimeType());\n        file.setModificationTimestamp(remote.getModifiedTimestamp());\n        file.setEtag(remote.getEtag());\n        file.setPermissions(remote.getPermissions());\n        file.setRemoteId(remote.getRemoteId());\n        file.setLocalId(remote.getLocalId());\n        file.setFavorite(remote.isFavorite());\n        if (file.isFolder()) {\n            file.setEncrypted(remote.isEncrypted());\n        }\n        file.setMountType(remote.getMountType());\n        file.setPreviewAvailable(remote.isHasPreview());\n        file.setUnreadCommentsCount(remote.getUnreadCommentsCount());\n        file.setOwnerId(remote.getOwnerId());\n        file.setOwnerDisplayName(remote.getOwnerDisplayName());\n        file.setNote(remote.getNote());\n        file.setSharees(new ArrayList<ShareeUser>(Arrays.asList(remote.getSharees())));\n        file.setRichWorkspace(remote.getRichWorkspace());\n        file.setLocked(remote.isLocked());\n        file.setLockType(remote.getLockType());\n        file.setLockOwnerId(remote.getLockOwner());\n        file.setLockOwnerDisplayName(remote.getLockOwnerDisplayName());\n        file.setLockOwnerEditor(remote.getLockOwnerEditor());\n        file.setLockTimestamp(remote.getLockTimestamp());\n        file.setLockTimeout(remote.getLockTimeout());\n        file.setLockToken(remote.getLockToken());\n        file.setTags(new ArrayList<>(Arrays.asList(remote.getTags())));\n        file.setImageDimension(remote.getImageDimension());\n        file.setGeoLocation(remote.getGeoLocation());\n        file.setLivePhoto(remote.getLivePhoto());\n        file.setHidden(remote.getHidden());\n\n        return file;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc fillOCFile(remote: RemoteFile) -> OCFile {\n    let file = OCFile(remotePath: remote.getRemotePath())\n    file.setDecryptedRemotePath(remote.getRemotePath())\n    file.setCreationTimestamp(remote.getCreationTimestamp())\n    if MimeType.DIRECTORY.caseInsensitiveCompare(remote.getMimeType()) == .orderedSame {\n        file.setFileLength(remote.getSize())\n    } else {\n        file.setFileLength(remote.getLength())\n    }\n    file.setMimeType(remote.getMimeType())\n    file.setModificationTimestamp(remote.getModifiedTimestamp())\n    file.setEtag(remote.getEtag())\n    file.setPermissions(remote.getPermissions())\n    file.setRemoteId(remote.getRemoteId())\n    file.setLocalId(remote.getLocalId())\n    file.setFavorite(remote.isFavorite())\n    if file.isFolder() {\n        file.setEncrypted(remote.isEncrypted())\n    }\n    file.setMountType(remote.getMountType())\n    file.setPreviewAvailable(remote.isHasPreview())\n    file.setUnreadCommentsCount(remote.getUnreadCommentsCount())\n    file.setOwnerId(remote.getOwnerId())\n    file.setOwnerDisplayName(remote.getOwnerDisplayName())\n    file.setNote(remote.getNote())\n    file.setSharees(Array(remote.getSharees()))\n    file.setRichWorkspace(remote.getRichWorkspace())\n    file.setLocked(remote.isLocked())\n    file.setLockType(remote.getLockType())\n    file.setLockOwnerId(remote.getLockOwner())\n    file.setLockOwnerDisplayName(remote.getLockOwnerDisplayName())\n    file.setLockOwnerEditor(remote.getLockOwnerEditor())\n    file.setLockTimestamp(remote.getLockTimestamp())\n    file.setLockTimeout(remote.getLockTimeout())\n    file.setLockToken(remote.getLockToken())\n    file.setTags(Array(remote.getTags()))\n    file.setImageDimension(remote.getImageDimension())\n    file.setGeoLocation(remote.getGeoLocation())\n    file.setLivePhoto(remote.getLivePhoto())\n    file.setHidden(remote.getHidden())\n\n    return file\n}\n```"
    },
    {
        "method_name": "fillRemoteFile",
        "method_code": "ublic static RemoteFile fillRemoteFile(OCFile ocFile) {\n        RemoteFile file = new RemoteFile(ocFile.getRemotePath());\n        file.setCreationTimestamp(ocFile.getCreationTimestamp());\n        file.setLength(ocFile.getFileLength());\n        file.setMimeType(ocFile.getMimeType());\n        file.setModifiedTimestamp(ocFile.getModificationTimestamp());\n        file.setEtag(ocFile.getEtag());\n        file.setPermissions(ocFile.getPermissions());\n        file.setRemoteId(ocFile.getRemoteId());\n        file.setFavorite(ocFile.isFavorite());\n        return file;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled fillRemoteFile from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: fillRemoteFile\n\n        Method Code: ublic static RemoteFile fillRemoteFile(OCFile ocFile) {\n        RemoteFile file = new RemoteFile(ocFile.getRemotePath());\n        file.setCreationTimestamp(ocFile.getCreationTimestamp());\n        file.setLength(ocFile.getFileLength());\n        file.setMimeType(ocFile.getMimeType());\n        file.setModifiedTimestamp(ocFile.getModificationTimestamp());\n        file.setEtag(ocFile.getEtag());\n        file.setPermissions(ocFile.getPermissions());\n        file.setRemoteId(ocFile.getRemoteId());\n        file.setFavorite(ocFile.isFavorite());\n        return file;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc fillRemoteFile(ocFile: OCFile) -> RemoteFile {\n    let file = RemoteFile(remotePath: ocFile.getRemotePath())\n    file.setCreationTimestamp(ocFile.getCreationTimestamp())\n    file.setLength(ocFile.getFileLength())\n    file.setMimeType(ocFile.getMimeType())\n    file.setModifiedTimestamp(ocFile.getModificationTimestamp())\n    file.setEtag(ocFile.getEtag())\n    file.setPermissions(ocFile.getPermissions())\n    file.setRemoteId(ocFile.getRemoteId())\n    file.setFavorite(ocFile.isFavorite())\n    return file\n}\n```"
    },
    {
        "method_name": "sortOcFolderDescDateModifiedWithoutFavoritesFirst",
        "method_code": "ublic static List<OCFile> sortOcFolderDescDateModifiedWithoutFavoritesFirst(List<OCFile> files) {\n        final int multiplier = -1;\n        Collections.sort(files, (o1, o2) -> {\n            return multiplier * Long.compare(o1.getModificationTimestamp(),o2.getModificationTimestamp());\n        });\n\n        return files;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled sortOcFolderDescDateModifiedWithoutFavoritesFirst from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: sortOcFolderDescDateModifiedWithoutFavoritesFirst\n\n        Method Code: ublic static List<OCFile> sortOcFolderDescDateModifiedWithoutFavoritesFirst(List<OCFile> files) {\n        final int multiplier = -1;\n        Collections.sort(files, (o1, o2) -> {\n            return multiplier * Long.compare(o1.getModificationTimestamp(),o2.getModificationTimestamp());\n        });\n\n        return files;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc sortOcFolderDescDateModifiedWithoutFavoritesFirst(files: [OCFile]) -> [OCFile] {\n    let sortedFiles = files.sorted {\n        return $0.modificationTimestamp > $1.modificationTimestamp\n    }\n    return sortedFiles\n}\n```"
    },
    {
        "method_name": "sortOcFolderDescDateModified",
        "method_code": "ublic static List<OCFile> sortOcFolderDescDateModified(List<OCFile> files) {\n        files = sortOcFolderDescDateModifiedWithoutFavoritesFirst(files);\n\n        return FileSortOrder.sortCloudFilesByFavourite(files);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled sortOcFolderDescDateModified from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: sortOcFolderDescDateModified\n\n        Method Code: ublic static List<OCFile> sortOcFolderDescDateModified(List<OCFile> files) {\n        files = sortOcFolderDescDateModifiedWithoutFavoritesFirst(files);\n\n        return FileSortOrder.sortCloudFilesByFavourite(files);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func sortOcFolderDescDateModified(_ files: [OCFile]) -> [OCFile] {\n    var sortedFiles = sortOcFolderDescDateModifiedWithoutFavoritesFirst(files)\n    return FileSortOrder.sortCloudFilesByFavourite(sortedFiles)\n}\n```"
    },
    {
        "method_name": "getFolderSize",
        "method_code": "ublic static long getFolderSize(File dir) {\n        if (dir.exists() && dir.isDirectory()) {\n            File[] files = dir.listFiles();\n\n            if (files != null) {\n                long result = 0;\n                for (File f : files) {\n                    if (f.isDirectory()) {\n                        result += getFolderSize(f);\n                    } else {\n                        result += f.length();\n                    }\n                }\n                return result;\n            }\n        }\n        return 0;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getFolderSize from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getFolderSize\n\n        Method Code: ublic static long getFolderSize(File dir) {\n        if (dir.exists() && dir.isDirectory()) {\n            File[] files = dir.listFiles();\n\n            if (files != null) {\n                long result = 0;\n                for (File f : files) {\n                    if (f.isDirectory()) {\n                        result += getFolderSize(f);\n                    } else {\n                        result += f.length();\n                    }\n                }\n                return result;\n            }\n        }\n        return 0;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getFolderSize(_ dir: URL) -> Int64 {\n    var result: Int64 = 0\n    if let files = try? FileManager.default.contentsOfDirectory(at: dir, includingPropertiesForKeys: nil, options: []) {\n        for file in files {\n            var isDirectory: ObjCBool = false\n            if FileManager.default.fileExists(atPath: file.path, isDirectory: &isDirectory) {\n                if isDirectory.boolValue {\n                    result += getFolderSize(file)\n                } else {\n                    if let fileSize = try? FileManager.default.attributesOfItem(atPath: file.path)[.size] as? Int64 {\n                        result += fileSize\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n```"
    },
    {
        "method_name": "getMimeTypeFromName",
        "method_code": "ublic static String getMimeTypeFromName(String path) {\n        String extension = \"\";\n        int pos = path.lastIndexOf('.');\n        if (pos >= 0) {\n            extension = path.substring(pos + 1);\n        }\n        String result = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension.toLowerCase(Locale.ROOT));\n        return (result != null) ? result : \"\";\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getMimeTypeFromName from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getMimeTypeFromName\n\n        Method Code: ublic static String getMimeTypeFromName(String path) {\n        String extension = \"\";\n        int pos = path.lastIndexOf('.');\n        if (pos >= 0) {\n            extension = path.substring(pos + 1);\n        }\n        String result = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension.toLowerCase(Locale.ROOT));\n        return (result != null) ? result : \"\";\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport MobileCoreServices\n\nfunc getMimeTypeFromName(_ path: String) -> String {\n    let extensionStartIndex = path.lastIndex(of: \".\") ?? path.endIndex\n    let fileExtension = String(path[path.index(after: extensionStartIndex)...])\n    if let uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, fileExtension as CFString, nil)?.takeRetainedValue(),\n       let mimeType = UTTypeCopyPreferredTagWithClass(uti, kUTTagClassMIMEType)?.takeRetainedValue() {\n        return mimeType as String\n    }\n    return \"\"\n}\n```"
    },
    {
        "method_name": "searchForLocalFileInDefaultPath",
        "method_code": "ublic static void searchForLocalFileInDefaultPath(OCFile file, String accountName) {\n        if ((file.getStoragePath() == null || !new File(file.getStoragePath()).exists()) && !file.isFolder()) {\n            File f = new File(FileStorageUtils.getDefaultSavePathFor(accountName, file));\n            if (f.exists()) {\n                file.setStoragePath(f.getAbsolutePath());\n                file.setLastSyncDateForData(f.lastModified());\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled searchForLocalFileInDefaultPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: searchForLocalFileInDefaultPath\n\n        Method Code: ublic static void searchForLocalFileInDefaultPath(OCFile file, String accountName) {\n        if ((file.getStoragePath() == null || !new File(file.getStoragePath()).exists()) && !file.isFolder()) {\n            File f = new File(FileStorageUtils.getDefaultSavePathFor(accountName, file));\n            if (f.exists()) {\n                file.setStoragePath(f.getAbsolutePath());\n                file.setLastSyncDateForData(f.lastModified());\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func searchForLocalFileInDefaultPath(file: OCFile, accountName: String) {\n    if (file.storagePath == nil || !FileManager.default.fileExists(atPath: file.storagePath!)) && !file.isFolder {\n        let filePath = FileStorageUtils.getDefaultSavePathFor(accountName: accountName, file: file)\n        let fileURL = URL(fileURLWithPath: filePath)\n        if FileManager.default.fileExists(atPath: fileURL.path) {\n            file.storagePath = fileURL.path\n            if let attributes = try? FileManager.default.attributesOfItem(atPath: fileURL.path),\n               let modificationDate = attributes[.modificationDate] as? Date {\n                file.setLastSyncDateForData(modificationDate)\n            }\n        }\n    }\n}\n```"
    },
    {
        "method_name": "copyFile",
        "method_code": "SuppressFBWarnings(value = \"OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE\",\n        justification = \"False-positive on the output stream\")\n    public static boolean copyFile(File src, File target) {\n        boolean ret = true;\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(target)) {\n            byte[] buf = new byte[1024];\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n        } catch (IOException ex) {\n            ret = false;\n        }\n\n        return ret;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyFile from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: copyFile\n\n        Method Code: SuppressFBWarnings(value = \"OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE\",\n        justification = \"False-positive on the output stream\")\n    public static boolean copyFile(File src, File target) {\n        boolean ret = true;\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(target)) {\n            byte[] buf = new byte[1024];\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n        } catch (IOException ex) {\n            ret = false;\n        }\n\n        return ret;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc copyFile(src: URL, target: URL) -> Bool {\n    var ret = true\n\n    do {\n        let inStream = InputStream(url: src)!\n        let outStream = OutputStream(url: target, append: false)!\n        inStream.open()\n        outStream.open()\n        \n        defer {\n            inStream.close()\n            outStream.close()\n        }\n        \n        let bufferSize = 1024\n        var buffer = [UInt8](repeating: 0, count: bufferSize)\n        \n        while inStream.hasBytesAvailable {\n            let bytesRead = inStream.read(&buffer, maxLength: bufferSize)\n            if bytesRead > 0 {\n                outStream.write(buffer, maxLength: bytesRead)\n            } else {\n                break\n            }\n        }\n    } catch {\n        ret = false\n    }\n\n    return ret\n}\n```"
    },
    {
        "method_name": "moveFile",
        "method_code": "ublic static boolean moveFile(File sourceFile, File targetFile) {\n        if (copyFile(sourceFile, targetFile)) {\n            return sourceFile.delete();\n        } else {\n            return false;\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled moveFile from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: moveFile\n\n        Method Code: ublic static boolean moveFile(File sourceFile, File targetFile) {\n        if (copyFile(sourceFile, targetFile)) {\n            return sourceFile.delete();\n        } else {\n            return false;\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc moveFile(sourceFile: URL, targetFile: URL) -> Bool {\n    do {\n        try FileManager.default.copyItem(at: sourceFile, to: targetFile)\n        try FileManager.default.removeItem(at: sourceFile)\n        return true\n    } catch {\n        return false\n    }\n}\n```"
    },
    {
        "method_name": "copyDirs",
        "method_code": "ublic static boolean copyDirs(File sourceFolder, File targetFolder) {\n        if (!targetFolder.mkdirs()) {\n            return false;\n        }\n\n        File[] listFiles = sourceFolder.listFiles();\n\n        if (listFiles == null) {\n            return false;\n        }\n\n        for (File f : listFiles) {\n            if (f.isDirectory()) {\n                if (!copyDirs(f, new File(targetFolder, f.getName()))) {\n                    return false;\n                }\n            } else if (!FileStorageUtils.copyFile(f, new File(targetFolder, f.getName()))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyDirs from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: copyDirs\n\n        Method Code: ublic static boolean copyDirs(File sourceFolder, File targetFolder) {\n        if (!targetFolder.mkdirs()) {\n            return false;\n        }\n\n        File[] listFiles = sourceFolder.listFiles();\n\n        if (listFiles == null) {\n            return false;\n        }\n\n        for (File f : listFiles) {\n            if (f.isDirectory()) {\n                if (!copyDirs(f, new File(targetFolder, f.getName()))) {\n                    return false;\n                }\n            } else if (!FileStorageUtils.copyFile(f, new File(targetFolder, f.getName()))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc copyDirs(sourceFolder: URL, targetFolder: URL) -> Bool {\n    do {\n        try FileManager.default.createDirectory(at: targetFolder, withIntermediateDirectories: true, attributes: nil)\n    } catch {\n        return false\n    }\n\n    guard let listFiles = try? FileManager.default.contentsOfDirectory(at: sourceFolder, includingPropertiesForKeys: nil, options: []) else {\n        return false\n    }\n\n    for file in listFiles {\n        let targetFile = targetFolder.appendingPathComponent(file.lastPathComponent)\n        if file.hasDirectoryPath {\n            if !copyDirs(sourceFolder: file, targetFolder: targetFile) {\n                return false\n            }\n        } else {\n            if !copyFile(sourceFile: file, targetFile: targetFile) {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n\nfunc copyFile(sourceFile: URL, targetFile: URL) -> Bool {\n    do {\n        try FileManager.default.copyItem(at: sourceFile, to: targetFile)\n        return true\n    } catch {\n        return false\n    }\n}\n```"
    },
    {
        "method_name": "deleteRecursively",
        "method_code": "ublic static void deleteRecursively(File file, FileDataStorageManager storageManager) {\n        if (file.isDirectory()) {\n            File[] listFiles = file.listFiles();\n\n            if (listFiles == null) {\n                return;\n            }\n\n            for (File child : listFiles) {\n                deleteRecursively(child, storageManager);\n            }\n        }\n\n        storageManager.deleteFileInMediaScan(file.getAbsolutePath());\n        file.delete();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteRecursively from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: deleteRecursively\n\n        Method Code: ublic static void deleteRecursively(File file, FileDataStorageManager storageManager) {\n        if (file.isDirectory()) {\n            File[] listFiles = file.listFiles();\n\n            if (listFiles == null) {\n                return;\n            }\n\n            for (File child : listFiles) {\n                deleteRecursively(child, storageManager);\n            }\n        }\n\n        storageManager.deleteFileInMediaScan(file.getAbsolutePath());\n        file.delete();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc deleteRecursively(file: URL, storageManager: FileDataStorageManager) {\n    if let isDirectory = try? file.resourceValues(forKeys: [.isDirectoryKey]).isDirectory, isDirectory {\n        if let listFiles = try? FileManager.default.contentsOfDirectory(at: file, includingPropertiesForKeys: nil, options: []) {\n            for child in listFiles {\n                deleteRecursively(file: child, storageManager: storageManager)\n            }\n        }\n    }\n    \n    storageManager.deleteFileInMediaScan(file.path)\n    try? FileManager.default.removeItem(at: file)\n}\n```"
    },
    {
        "method_name": "deleteRecursive",
        "method_code": "ublic static boolean deleteRecursive(File file) {\n        boolean res = true;\n\n        if (file.isDirectory()) {\n            File[] listFiles = file.listFiles();\n\n            if (listFiles == null) {\n                return true;\n            }\n\n            for (File c : listFiles) {\n                res = deleteRecursive(c) && res;\n            }\n        }\n\n        return file.delete() && res;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteRecursive from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: deleteRecursive\n\n        Method Code: ublic static boolean deleteRecursive(File file) {\n        boolean res = true;\n\n        if (file.isDirectory()) {\n            File[] listFiles = file.listFiles();\n\n            if (listFiles == null) {\n                return true;\n            }\n\n            for (File c : listFiles) {\n                res = deleteRecursive(c) && res;\n            }\n        }\n\n        return file.delete() && res;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc deleteRecursive(file: URL) -> Bool {\n    var res = true\n\n    if let isDirectory = try? file.resourceValues(forKeys: [.isDirectoryKey]).isDirectory, isDirectory {\n        if let listFiles = try? FileManager.default.contentsOfDirectory(at: file, includingPropertiesForKeys: nil, options: []) {\n            for c in listFiles {\n                res = deleteRecursive(file: c) && res\n            }\n        } else {\n            return true\n        }\n    }\n\n    do {\n        try FileManager.default.removeItem(at: file)\n        return res\n    } catch {\n        return false\n    }\n}\n```"
    },
    {
        "method_name": "checkIfFileFinishedSaving",
        "method_code": "ublic static void checkIfFileFinishedSaving(OCFile file) {\n        long lastModified = 0;\n        long lastSize = 0;\n        File realFile = new File(file.getStoragePath());\n\n        if (realFile.lastModified() != file.getModificationTimestamp() && realFile.length() != file.getFileLength()) {\n            while (realFile.lastModified() != lastModified && realFile.length() != lastSize) {\n                lastModified = realFile.lastModified();\n                lastSize = realFile.length();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    Log_OC.d(TAG, \"Failed to sleep for a bit\");\n                }\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkIfFileFinishedSaving from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: checkIfFileFinishedSaving\n\n        Method Code: ublic static void checkIfFileFinishedSaving(OCFile file) {\n        long lastModified = 0;\n        long lastSize = 0;\n        File realFile = new File(file.getStoragePath());\n\n        if (realFile.lastModified() != file.getModificationTimestamp() && realFile.length() != file.getFileLength()) {\n            while (realFile.lastModified() != lastModified && realFile.length() != lastSize) {\n                lastModified = realFile.lastModified();\n                lastSize = realFile.length();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    Log_OC.d(TAG, \"Failed to sleep for a bit\");\n                }\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc checkIfFileFinishedSaving(file: OCFile) {\n    var lastModified: TimeInterval = 0\n    var lastSize: UInt64 = 0\n    let realFile = URL(fileURLWithPath: file.getStoragePath())\n\n    if let attributes = try? FileManager.default.attributesOfItem(atPath: realFile.path),\n       let modificationDate = attributes[.modificationDate] as? Date,\n       let fileSize = attributes[.size] as? UInt64,\n       modificationDate.timeIntervalSince1970 != file.getModificationTimestamp() && fileSize != file.getFileLength() {\n\n        while let currentAttributes = try? FileManager.default.attributesOfItem(atPath: realFile.path),\n              let currentModificationDate = currentAttributes[.modificationDate] as? Date,\n              let currentFileSize = currentAttributes[.size] as? UInt64,\n              currentModificationDate.timeIntervalSince1970 != lastModified && currentFileSize != lastSize {\n\n            lastModified = currentModificationDate.timeIntervalSince1970\n            lastSize = currentFileSize\n            Thread.sleep(forTimeInterval: 1.0)\n        }\n    }\n}\n```"
    },
    {
        "method_name": "checkEncryptionStatus",
        "method_code": "ublic static boolean checkEncryptionStatus(OCFile file, FileDataStorageManager storageManager) {\n        if (file.isEncrypted()) {\n            return true;\n        }\n\n        while (file != null && !OCFile.ROOT_PATH.equals(file.getDecryptedRemotePath())) {\n            if (file.isEncrypted()) {\n                return true;\n            }\n            file = storageManager.getFileById(file.getParentId());\n        }\n        return false;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkEncryptionStatus from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: checkEncryptionStatus\n\n        Method Code: ublic static boolean checkEncryptionStatus(OCFile file, FileDataStorageManager storageManager) {\n        if (file.isEncrypted()) {\n            return true;\n        }\n\n        while (file != null && !OCFile.ROOT_PATH.equals(file.getDecryptedRemotePath())) {\n            if (file.isEncrypted()) {\n                return true;\n            }\n            file = storageManager.getFileById(file.getParentId());\n        }\n        return false;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func checkEncryptionStatus(file: OCFile, storageManager: FileDataStorageManager) -> Bool {\n    if file.isEncrypted() {\n        return true\n    }\n    \n    var currentFile: OCFile? = file\n    while currentFile != nil && currentFile?.decryptedRemotePath != OCFile.ROOT_PATH {\n        if currentFile!.isEncrypted() {\n            return true\n        }\n        currentFile = storageManager.getFileById(currentFile!.parentId)\n    }\n    return false\n}\n```"
    },
    {
        "method_name": "getStorageDirectories",
        "method_code": "SuppressFBWarnings(value = \"DMI_HARDCODED_ABSOLUTE_FILENAME\",\n        justification = \"Default Android fallback storage path\")\n    public static List<String> getStorageDirectories(Context context) {\n        // Final set of paths\n        final List<String> rv = new ArrayList<>();\n        // Primary physical SD-CARD (not emulated)\n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n        // All Secondary SD-CARDs (all exclude primary) separated by \":\"\n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n        // Primary emulated SD-CARD\n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n            // Device has physical external storage; use plain paths.\n            if (TextUtils.isEmpty(rawExternalStorage)) {\n                // EXTERNAL_STORAGE undefined; falling back to default.\n                // Check for actual existence of the directory before adding to list\n                if (new File(DEFAULT_FALLBACK_STORAGE_PATH).exists()) {\n                    rv.add(DEFAULT_FALLBACK_STORAGE_PATH);\n                } else {\n                    //We know nothing else, use Environment's fallback\n                    rv.add(Environment.getExternalStorageDirectory().getAbsolutePath());\n                }\n            } else {\n                rv.add(rawExternalStorage);\n            }\n        } else {\n            // Device has emulated storage; external storage paths should have\n            // userId burned into them.\n            final String rawUserId;\n            final String path = Environment.getExternalStorageDirectory().getAbsolutePath();\n            final String[] folders = OCFile.PATH_SEPARATOR.split(path);\n            final String lastFolder = folders[folders.length - 1];\n            boolean isDigit = false;\n            try {\n                Integer.valueOf(lastFolder);\n                isDigit = true;\n            } catch (NumberFormatException ignored) {\n            }\n            rawUserId = isDigit ? lastFolder : \"\";\n\n            // /storage/emulated/0[1,2,...]\n            if (TextUtils.isEmpty(rawUserId)) {\n                rv.add(rawEmulatedStorageTarget);\n            } else {\n                rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n            }\n        }\n        // Add all secondary storages\n        if (!TextUtils.isEmpty(rawSecondaryStoragesStr)) {\n            // All Secondary SD-CARDs splited into array\n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        if (checkStoragePermission(context)) {\n            rv.clear();\n        }\n\n        String[] extSdCardPaths = getExtSdCardPathsForActivity(context);\n        File f;\n        for (String extSdCardPath : extSdCardPaths) {\n            f = new File(extSdCardPath);\n            if (!rv.contains(extSdCardPath) && canListFiles(f)) {\n                rv.add(extSdCardPath);\n            }\n        }\n\n        return rv;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getStorageDirectories from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getStorageDirectories\n\n        Method Code: SuppressFBWarnings(value = \"DMI_HARDCODED_ABSOLUTE_FILENAME\",\n        justification = \"Default Android fallback storage path\")\n    public static List<String> getStorageDirectories(Context context) {\n        // Final set of paths\n        final List<String> rv = new ArrayList<>();\n        // Primary physical SD-CARD (not emulated)\n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n        // All Secondary SD-CARDs (all exclude primary) separated by \":\"\n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n        // Primary emulated SD-CARD\n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n            // Device has physical external storage; use plain paths.\n            if (TextUtils.isEmpty(rawExternalStorage)) {\n                // EXTERNAL_STORAGE undefined; falling back to default.\n                // Check for actual existence of the directory before adding to list\n                if (new File(DEFAULT_FALLBACK_STORAGE_PATH).exists()) {\n                    rv.add(DEFAULT_FALLBACK_STORAGE_PATH);\n                } else {\n                    //We know nothing else, use Environment's fallback\n                    rv.add(Environment.getExternalStorageDirectory().getAbsolutePath());\n                }\n            } else {\n                rv.add(rawExternalStorage);\n            }\n        } else {\n            // Device has emulated storage; external storage paths should have\n            // userId burned into them.\n            final String rawUserId;\n            final String path = Environment.getExternalStorageDirectory().getAbsolutePath();\n            final String[] folders = OCFile.PATH_SEPARATOR.split(path);\n            final String lastFolder = folders[folders.length - 1];\n            boolean isDigit = false;\n            try {\n                Integer.valueOf(lastFolder);\n                isDigit = true;\n            } catch (NumberFormatException ignored) {\n            }\n            rawUserId = isDigit ? lastFolder : \"\";\n\n            // /storage/emulated/0[1,2,...]\n            if (TextUtils.isEmpty(rawUserId)) {\n                rv.add(rawEmulatedStorageTarget);\n            } else {\n                rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n            }\n        }\n        // Add all secondary storages\n        if (!TextUtils.isEmpty(rawSecondaryStoragesStr)) {\n            // All Secondary SD-CARDs splited into array\n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        if (checkStoragePermission(context)) {\n            rv.clear();\n        }\n\n        String[] extSdCardPaths = getExtSdCardPathsForActivity(context);\n        File f;\n        for (String extSdCardPath : extSdCardPaths) {\n            f = new File(extSdCardPath);\n            if (!rv.contains(extSdCardPath) && canListFiles(f)) {\n                rv.add(extSdCardPath);\n            }\n        }\n\n        return rv;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getStorageDirectories(context: AnyObject) -> [String] {\n    var rv: [String] = []\n    let rawExternalStorage = ProcessInfo.processInfo.environment[\"EXTERNAL_STORAGE\"]\n    let rawSecondaryStoragesStr = ProcessInfo.processInfo.environment[\"SECONDARY_STORAGE\"]\n    let rawEmulatedStorageTarget = ProcessInfo.processInfo.environment[\"EMULATED_STORAGE_TARGET\"]\n    \n    if rawEmulatedStorageTarget?.isEmpty ?? true {\n        if rawExternalStorage?.isEmpty ?? true {\n            let defaultFallbackStoragePath = \"/storage/sdcard0\"\n            if FileManager.default.fileExists(atPath: defaultFallbackStoragePath) {\n                rv.append(defaultFallbackStoragePath)\n            } else {\n                rv.append(NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first ?? \"\")\n            }\n        } else {\n            rv.append(rawExternalStorage!)\n        }\n    } else {\n        let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first ?? \"\"\n        let folders = path.split(separator: \"/\")\n        let lastFolder = folders.last ?? \"\"\n        let isDigit = Int(lastFolder) != nil\n        let rawUserId = isDigit ? String(lastFolder) : \"\"\n        \n        if rawUserId.isEmpty {\n            rv.append(rawEmulatedStorageTarget!)\n        } else {\n            rv.append(rawEmulatedStorageTarget! + \"/\" + rawUserId)\n        }\n    }\n    \n    if let rawSecondaryStoragesStr = rawSecondaryStoragesStr, !rawSecondaryStoragesStr.isEmpty {\n        let rawSecondaryStorages = rawSecondaryStoragesStr.split(separator: \":\")\n        rv.append(contentsOf: rawSecondaryStorages.map { String($0) })\n    }\n    \n    if checkStoragePermission(context: context) {\n        rv.removeAll()\n    }\n    \n    let extSdCardPaths = getExtSdCardPathsForActivity(context: context)\n    for extSdCardPath in extSdCardPaths {\n        let f = URL(fileURLWithPath: extSdCardPath)\n        if !rv.contains(extSdCardPath) && canListFiles(file: f) {\n            rv.append(extSdCardPath)\n        }\n    }\n    \n    return rv\n}\n\nfunc checkStoragePermission(context: AnyObject) -> Bool {\n    // Placeholder for actual permission check\n    return false\n}\n\nfunc getExtSdCardPathsForActivity(context: AnyObject) -> [String] {\n    // Placeholder for actual external SD card path retrieval\n    return []\n}\n\nfunc canListFiles(file: URL) -> Bool {\n    // Placeholder for actual file listing capability check\n    return true\n}\n```"
    },
    {
        "method_name": "pathToUserFriendlyDisplay",
        "method_code": "ublic static String pathToUserFriendlyDisplay(String path, Context context, Resources resources) {\n        // Determine storage device (external, sdcard...)\n        String storageDevice = null;\n        for (String storageDirectory : FileStorageUtils.getStorageDirectories(context)) {\n            if (path.startsWith(storageDirectory)) {\n                storageDevice = storageDirectory;\n                break;\n            }\n        }\n\n        // If storage device was not found, display full path\n        if (storageDevice == null) {\n            return path;\n        }\n\n        // Default to full path without storage device path\n        String storageFolder;\n        try {\n            storageFolder = path.substring(storageDevice.length() + 1);\n        } catch (StringIndexOutOfBoundsException e) {\n            storageFolder = \"\";\n        }\n\n        FileStorageUtils.StandardDirectory standardDirectory = FileStorageUtils.StandardDirectory.fromPath(storageFolder);\n        if (standardDirectory != null) {\n            // Friendly name of standard directory\n            storageFolder = \" \" + resources.getString(standardDirectory.getDisplayName());\n        }\n\n        // Shorten the storage device to a friendlier display name\n        if (storageDevice.startsWith(Environment.getExternalStorageDirectory().getAbsolutePath())) {\n            storageDevice = resources.getString(R.string.storage_internal_storage);\n        } else {\n            storageDevice = new File(storageDevice).getName();\n        }\n\n        return resources.getString(R.string.local_folder_friendly_path, storageDevice, storageFolder);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled pathToUserFriendlyDisplay from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: pathToUserFriendlyDisplay\n\n        Method Code: ublic static String pathToUserFriendlyDisplay(String path, Context context, Resources resources) {\n        // Determine storage device (external, sdcard...)\n        String storageDevice = null;\n        for (String storageDirectory : FileStorageUtils.getStorageDirectories(context)) {\n            if (path.startsWith(storageDirectory)) {\n                storageDevice = storageDirectory;\n                break;\n            }\n        }\n\n        // If storage device was not found, display full path\n        if (storageDevice == null) {\n            return path;\n        }\n\n        // Default to full path without storage device path\n        String storageFolder;\n        try {\n            storageFolder = path.substring(storageDevice.length() + 1);\n        } catch (StringIndexOutOfBoundsException e) {\n            storageFolder = \"\";\n        }\n\n        FileStorageUtils.StandardDirectory standardDirectory = FileStorageUtils.StandardDirectory.fromPath(storageFolder);\n        if (standardDirectory != null) {\n            // Friendly name of standard directory\n            storageFolder = \" \" + resources.getString(standardDirectory.getDisplayName());\n        }\n\n        // Shorten the storage device to a friendlier display name\n        if (storageDevice.startsWith(Environment.getExternalStorageDirectory().getAbsolutePath())) {\n            storageDevice = resources.getString(R.string.storage_internal_storage);\n        } else {\n            storageDevice = new File(storageDevice).getName();\n        }\n\n        return resources.getString(R.string.local_folder_friendly_path, storageDevice, storageFolder);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc pathToUserFriendlyDisplay(path: String, context: Context, resources: Resources) -> String {\n    // Determine storage device (external, sdcard...)\n    var storageDevice: String? = nil\n    for storageDirectory in FileStorageUtils.getStorageDirectories(context: context) {\n        if path.hasPrefix(storageDirectory) {\n            storageDevice = storageDirectory\n            break\n        }\n    }\n\n    // If storage device was not found, display full path\n    if storageDevice == nil {\n        return path\n    }\n\n    // Default to full path without storage device path\n    var storageFolder: String\n    do {\n        let startIndex = path.index(path.startIndex, offsetBy: storageDevice!.count + 1)\n        storageFolder = String(path[startIndex...])\n    } catch {\n        storageFolder = \"\"\n    }\n\n    if let standardDirectory = FileStorageUtils.StandardDirectory.fromPath(storageFolder) {\n        // Friendly name of standard directory\n        storageFolder = \" \" + resources.getString(standardDirectory.getDisplayName())\n    }\n\n    // Shorten the storage device to a friendlier display name\n    if storageDevice!.hasPrefix(Environment.getExternalStorageDirectory().absolutePath) {\n        storageDevice = resources.getString(R.string.storage_internal_storage)\n    } else {\n        storageDevice = URL(fileURLWithPath: storageDevice!).lastPathComponent\n    }\n\n    return resources.getString(R.string.local_folder_friendly_path, storageDevice!, storageFolder)\n}\n```"
    },
    {
        "method_name": "checkStoragePermission",
        "method_code": "rivate static boolean checkStoragePermission(Context context) {\n        // Verify that all required contact permissions have been granted.\n        return ActivityCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n            == PackageManager.PERMISSION_GRANTED;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkStoragePermission from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: checkStoragePermission\n\n        Method Code: rivate static boolean checkStoragePermission(Context context) {\n        // Verify that all required contact permissions have been granted.\n        return ActivityCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n            == PackageManager.PERMISSION_GRANTED;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func checkStoragePermission(context: Context) -> Bool {\n    return context.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED\n}\n```"
    },
    {
        "method_name": "getExtSdCardPathsForActivity",
        "method_code": "rivate static String[] getExtSdCardPathsForActivity(Context context) {\n        List<String> paths = new ArrayList<>();\n        for (File file : context.getExternalFilesDirs(\"external\")) {\n            if (file != null) {\n                int index = file.getAbsolutePath().lastIndexOf(\"/Android/data\");\n                if (index < 0) {\n                    Log_OC.w(TAG, \"Unexpected external file dir: \" + file.getAbsolutePath());\n                } else {\n                    String path = file.getAbsolutePath().substring(0, index);\n                    try {\n                        path = new File(path).getCanonicalPath();\n                    } catch (IOException e) {\n                        // Keep non-canonical path.\n                    }\n                    paths.add(path);\n                }\n            }\n        }\n        if (paths.isEmpty()) {\n            paths.add(\"/storage/sdcard1\");\n        }\n        return paths.toArray(new String[0]);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getExtSdCardPathsForActivity from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getExtSdCardPathsForActivity\n\n        Method Code: rivate static String[] getExtSdCardPathsForActivity(Context context) {\n        List<String> paths = new ArrayList<>();\n        for (File file : context.getExternalFilesDirs(\"external\")) {\n            if (file != null) {\n                int index = file.getAbsolutePath().lastIndexOf(\"/Android/data\");\n                if (index < 0) {\n                    Log_OC.w(TAG, \"Unexpected external file dir: \" + file.getAbsolutePath());\n                } else {\n                    String path = file.getAbsolutePath().substring(0, index);\n                    try {\n                        path = new File(path).getCanonicalPath();\n                    } catch (IOException e) {\n                        // Keep non-canonical path.\n                    }\n                    paths.add(path);\n                }\n            }\n        }\n        if (paths.isEmpty()) {\n            paths.add(\"/storage/sdcard1\");\n        }\n        return paths.toArray(new String[0]);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nfunc getExtSdCardPathsForActivity(context: Context) -> [String] {\n    var paths: [String] = []\n    if let externalFilesDirs = context.getExternalFilesDirs(type: \"external\") {\n        for file in externalFilesDirs {\n            if let file = file {\n                let pathString = file.absolutePath\n                if let index = pathString.range(of: \"/Android/data\")?.lowerBound {\n                    var path = String(pathString[..<index])\n                    do {\n                        path = try FileManager.default.destinationOfSymbolicLink(atPath: path)\n                    } catch {\n                        // Keep non-canonical path.\n                    }\n                    paths.append(path)\n                } else {\n                    print(\"Unexpected external file dir: \\(pathString)\")\n                }\n            }\n        }\n    }\n    if paths.isEmpty {\n        paths.append(\"/storage/sdcard1\")\n    }\n    return paths\n}\n```"
    },
    {
        "method_name": "canListFiles",
        "method_code": "rivate static boolean canListFiles(File f) {\n        return f.canRead() && f.isDirectory();\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled canListFiles from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: canListFiles\n\n        Method Code: rivate static boolean canListFiles(File f) {\n        return f.canRead() && f.isDirectory();\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func canListFiles(_ f: File) -> Bool {\n    return f.canRead() && f.isDirectory()\n}\n```"
    },
    {
        "method_name": "checkIfEnoughSpace",
        "method_code": "ublic static boolean checkIfEnoughSpace(OCFile file) {\n        // Get the remaining space on device\n        long availableSpaceOnDevice = FileOperationsHelper.getAvailableSpaceOnDevice();\n\n        if (availableSpaceOnDevice == -1) {\n            throw new RuntimeException(\"Error while computing available space\");\n        }\n\n        return checkIfEnoughSpace(availableSpaceOnDevice, file);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkIfEnoughSpace from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: checkIfEnoughSpace\n\n        Method Code: ublic static boolean checkIfEnoughSpace(OCFile file) {\n        // Get the remaining space on device\n        long availableSpaceOnDevice = FileOperationsHelper.getAvailableSpaceOnDevice();\n\n        if (availableSpaceOnDevice == -1) {\n            throw new RuntimeException(\"Error while computing available space\");\n        }\n\n        return checkIfEnoughSpace(availableSpaceOnDevice, file);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func checkIfEnoughSpace(file: OCFile) -> Bool {\n    let availableSpaceOnDevice = FileOperationsHelper.getAvailableSpaceOnDevice()\n\n    if availableSpaceOnDevice == -1 {\n        fatalError(\"Error while computing available space\")\n    }\n\n    return checkIfEnoughSpace(availableSpaceOnDevice, file)\n}\n```"
    },
    {
        "method_name": "checkIfEnoughSpace",
        "method_code": "VisibleForTesting\n    public static boolean checkIfEnoughSpace(long availableSpaceOnDevice, OCFile file) {\n        if (file.isFolder()) {\n            // on folders we assume that we only need difference\n            return availableSpaceOnDevice > (file.getFileLength() - localFolderSize(file));\n        } else {\n            // on files complete file must first be stored, then target gets overwritten\n            return availableSpaceOnDevice > file.getFileLength();\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkIfEnoughSpace from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: checkIfEnoughSpace\n\n        Method Code: VisibleForTesting\n    public static boolean checkIfEnoughSpace(long availableSpaceOnDevice, OCFile file) {\n        if (file.isFolder()) {\n            // on folders we assume that we only need difference\n            return availableSpaceOnDevice > (file.getFileLength() - localFolderSize(file));\n        } else {\n            // on files complete file must first be stored, then target gets overwritten\n            return availableSpaceOnDevice > file.getFileLength();\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc checkIfEnoughSpace(availableSpaceOnDevice: Int64, file: OCFile) -> Bool {\n    if file.isFolder() {\n        // on folders we assume that we only need difference\n        return availableSpaceOnDevice > (file.getFileLength() - localFolderSize(file))\n    } else {\n        // on files complete file must first be stored, then target gets overwritten\n        return availableSpaceOnDevice > file.getFileLength()\n    }\n}\n```"
    },
    {
        "method_name": "localFolderSize",
        "method_code": "rivate static long localFolderSize(OCFile file) {\n        if (file.getStoragePath() == null) {\n            // not yet downloaded anything\n            return 0;\n        } else {\n            return FileStorageUtils.getFolderSize(new File(file.getStoragePath()));\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled localFolderSize from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: localFolderSize\n\n        Method Code: rivate static long localFolderSize(OCFile file) {\n        if (file.getStoragePath() == null) {\n            // not yet downloaded anything\n            return 0;\n        } else {\n            return FileStorageUtils.getFolderSize(new File(file.getStoragePath()));\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func localFolderSize(file: OCFile) -> Int64 {\n    if file.getStoragePath() == nil {\n        return 0\n    } else {\n        return FileStorageUtils.getFolderSize(URL(fileURLWithPath: file.getStoragePath()!))\n    }\n}\n```"
    },
    {
        "method_name": "getName",
        "method_code": "ublic String getName() {\n            return this.name;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getName from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getName\n\n        Method Code: ublic String getName() {\n            return this.name;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getName() -> String {\n    return self.name\n}\n```"
    },
    {
        "method_name": "getDisplayName",
        "method_code": "ublic int getDisplayName() {\n            return this.displayNameResource;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDisplayName from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getDisplayName\n\n        Method Code: ublic int getDisplayName() {\n            return this.displayNameResource;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getDisplayName() -> Int {\n    return self.displayNameResource\n}\n```"
    },
    {
        "method_name": "getIcon",
        "method_code": "ublic int getIcon() {\n            return this.iconResource;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getIcon from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getIcon\n\n        Method Code: ublic int getIcon() {\n            return this.iconResource;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getIcon() -> Int {\n    return self.iconResource\n}\n```"
    },
    {
        "method_name": "getStandardDirectories",
        "method_code": "ublic static Collection<StandardDirectory> getStandardDirectories() {\n            Collection<StandardDirectory> standardDirectories = new HashSet<>();\n            standardDirectories.add(PICTURES);\n            standardDirectories.add(CAMERA);\n            if (DOCUMENTS != null) {\n                standardDirectories.add(DOCUMENTS);\n            }\n            standardDirectories.add(DOWNLOADS);\n            standardDirectories.add(MOVIES);\n            standardDirectories.add(MUSIC);\n            return standardDirectories;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getStandardDirectories from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: getStandardDirectories\n\n        Method Code: ublic static Collection<StandardDirectory> getStandardDirectories() {\n            Collection<StandardDirectory> standardDirectories = new HashSet<>();\n            standardDirectories.add(PICTURES);\n            standardDirectories.add(CAMERA);\n            if (DOCUMENTS != null) {\n                standardDirectories.add(DOCUMENTS);\n            }\n            standardDirectories.add(DOWNLOADS);\n            standardDirectories.add(MOVIES);\n            standardDirectories.add(MUSIC);\n            return standardDirectories;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func getStandardDirectories() -> Set<StandardDirectory> {\n    var standardDirectories: Set<StandardDirectory> = []\n    standardDirectories.insert(PICTURES)\n    standardDirectories.insert(CAMERA)\n    if let documents = DOCUMENTS {\n        standardDirectories.insert(documents)\n    }\n    standardDirectories.insert(DOWNLOADS)\n    standardDirectories.insert(MOVIES)\n    standardDirectories.insert(MUSIC)\n    return standardDirectories\n}\n```"
    },
    {
        "method_name": "fromPath",
        "method_code": "Nullable\n        public static StandardDirectory fromPath(String path) {\n            for (StandardDirectory directory : getStandardDirectories()) {\n                if (directory.getName().equals(path)) {\n                    return directory;\n                }\n            }\n            return null;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled fromPath from FileStorageUtils.java into Swift.\n\n        Input:\n\n        Method Name: fromPath\n\n        Method Code: Nullable\n        public static StandardDirectory fromPath(String path) {\n            for (StandardDirectory directory : getStandardDirectories()) {\n                if (directory.getName().equals(path)) {\n                    return directory;\n                }\n            }\n            return null;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\npublic static func fromPath(_ path: String) -> StandardDirectory? {\n    for directory in getStandardDirectories() {\n        if directory.getName() == path {\n            return directory\n        }\n    }\n    return nil\n}\n```"
    }
]