[
    {
        "method_name": "run",
        "method_code": "Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        RemoteOperationResult result = null;\n        String newRemotePath = null;\n\n        file = getStorageManager().getFileByPath(remotePath);\n\n        // check if the new name is valid in the local file system\n        try {\n            if (!isValidNewName()) {\n                return new RemoteOperationResult(ResultCode.INVALID_LOCAL_FILE_NAME);\n            }\n            String parent = new File(file.getRemotePath()).getParent();\n            parent = parent.endsWith(OCFile.PATH_SEPARATOR) ? parent : parent + OCFile.PATH_SEPARATOR;\n            newRemotePath =  parent + newName;\n            if (file.isFolder()) {\n                newRemotePath += OCFile.PATH_SEPARATOR;\n            }\n\n            // check local overwrite\n            if (getStorageManager().getFileByPath(newRemotePath) != null) {\n                return new RemoteOperationResult(ResultCode.INVALID_OVERWRITE);\n            }\n\n            result = new RenameFileRemoteOperation(file.getFileName(),\n                                                   file.getRemotePath(),\n                                                   newName,\n                                                   file.isFolder())\n                .execute(client);\n\n            if (result.isSuccess()) {\n                if (file.isFolder()) {\n                    getStorageManager().moveLocalFile(file, newRemotePath, parent);\n                    //saveLocalDirectory();\n\n                } else {\n                    saveLocalFile(newRemotePath);\n                }\n            }\n\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Rename \" + file.getRemotePath() + \" to \" + ((newRemotePath == null) ?\n                newName : newRemotePath) + \": \" +\n                    (result!= null ? result.getLogMessage() : \"\"), e);\n        }\n\n        return result;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled run from RenameFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: run\n\n        Method Code: Override\n    protected RemoteOperationResult run(OwnCloudClient client) {\n        RemoteOperationResult result = null;\n        String newRemotePath = null;\n\n        file = getStorageManager().getFileByPath(remotePath);\n\n        // check if the new name is valid in the local file system\n        try {\n            if (!isValidNewName()) {\n                return new RemoteOperationResult(ResultCode.INVALID_LOCAL_FILE_NAME);\n            }\n            String parent = new File(file.getRemotePath()).getParent();\n            parent = parent.endsWith(OCFile.PATH_SEPARATOR) ? parent : parent + OCFile.PATH_SEPARATOR;\n            newRemotePath =  parent + newName;\n            if (file.isFolder()) {\n                newRemotePath += OCFile.PATH_SEPARATOR;\n            }\n\n            // check local overwrite\n            if (getStorageManager().getFileByPath(newRemotePath) != null) {\n                return new RemoteOperationResult(ResultCode.INVALID_OVERWRITE);\n            }\n\n            result = new RenameFileRemoteOperation(file.getFileName(),\n                                                   file.getRemotePath(),\n                                                   newName,\n                                                   file.isFolder())\n                .execute(client);\n\n            if (result.isSuccess()) {\n                if (file.isFolder()) {\n                    getStorageManager().moveLocalFile(file, newRemotePath, parent);\n                    //saveLocalDirectory();\n\n                } else {\n                    saveLocalFile(newRemotePath);\n                }\n            }\n\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Rename \" + file.getRemotePath() + \" to \" + ((newRemotePath == null) ?\n                newName : newRemotePath) + \": \" +\n                    (result!= null ? result.getLogMessage() : \"\"), e);\n        }\n\n        return result;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func run(client: OwnCloudClient) -> RemoteOperationResult {\n    var result: RemoteOperationResult? = nil\n    var newRemotePath: String? = nil\n\n    file = getStorageManager().getFileByPath(remotePath)\n\n    do {\n        if !isValidNewName() {\n            return RemoteOperationResult(resultCode: .invalidLocalFileName)\n        }\n        var parent = (file.remotePath as NSString).deletingLastPathComponent\n        parent = parent.hasSuffix(OCFile.pathSeparator) ? parent : parent + OCFile.pathSeparator\n        newRemotePath = parent + newName\n        if file.isFolder {\n            newRemotePath! += OCFile.pathSeparator\n        }\n\n        if getStorageManager().getFileByPath(newRemotePath!) != nil {\n            return RemoteOperationResult(resultCode: .invalidOverwrite)\n        }\n\n        result = RenameFileRemoteOperation(fileName: file.fileName,\n                                           remotePath: file.remotePath,\n                                           newName: newName,\n                                           isFolder: file.isFolder)\n            .execute(client: client)\n\n        if result!.isSuccess {\n            if file.isFolder {\n                getStorageManager().moveLocalFile(file: file, toPath: newRemotePath!, parentPath: parent)\n            } else {\n                saveLocalFile(newRemotePath: newRemotePath!)\n            }\n        }\n\n    } catch let e as NSError {\n        Log_OC.e(TAG, \"Rename \\(file.remotePath) to \\((newRemotePath == nil) ? newName : newRemotePath!): \\(result != nil ? result!.logMessage : \"\")\", e)\n    }\n\n    return result!\n}\n```"
    },
    {
        "method_name": "saveLocalFile",
        "method_code": "rivate void saveLocalFile(String newRemotePath) {\n        file.setFileName(newName);\n\n        if (!file.isEncrypted()) {\n            file.setDecryptedRemotePath(newRemotePath);\n        }\n\n        // try to rename the local copy of the file\n        if (file.isDown()) {\n            String oldPath = file.getStoragePath();\n            File f = new File(oldPath);\n            String parentStoragePath = f.getParent();\n            if (!parentStoragePath.endsWith(File.separator)) {\n                parentStoragePath += File.separator;\n            }\n            if (f.renameTo(new File(parentStoragePath + newName))) {\n                String newPath = parentStoragePath + newName;\n                file.setStoragePath(newPath);\n\n                // notify MediaScanner about removed file\n                getStorageManager().deleteFileInMediaScan(oldPath);\n                // notify to scan about new file, if it is a media file\n                if (MimeTypeUtil.isMedia(file.getMimeType())) {\n                    FileDataStorageManager.triggerMediaScan(newPath, file);\n                }\n            }\n            // else - NOTHING: the link to the local file is kept although the local name\n            // can't be updated\n            // TODO - study conditions when this could be a problem\n        }\n\n        getStorageManager().saveFile(file);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled saveLocalFile from RenameFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: saveLocalFile\n\n        Method Code: rivate void saveLocalFile(String newRemotePath) {\n        file.setFileName(newName);\n\n        if (!file.isEncrypted()) {\n            file.setDecryptedRemotePath(newRemotePath);\n        }\n\n        // try to rename the local copy of the file\n        if (file.isDown()) {\n            String oldPath = file.getStoragePath();\n            File f = new File(oldPath);\n            String parentStoragePath = f.getParent();\n            if (!parentStoragePath.endsWith(File.separator)) {\n                parentStoragePath += File.separator;\n            }\n            if (f.renameTo(new File(parentStoragePath + newName))) {\n                String newPath = parentStoragePath + newName;\n                file.setStoragePath(newPath);\n\n                // notify MediaScanner about removed file\n                getStorageManager().deleteFileInMediaScan(oldPath);\n                // notify to scan about new file, if it is a media file\n                if (MimeTypeUtil.isMedia(file.getMimeType())) {\n                    FileDataStorageManager.triggerMediaScan(newPath, file);\n                }\n            }\n            // else - NOTHING: the link to the local file is kept although the local name\n            // can't be updated\n            // TODO - study conditions when this could be a problem\n        }\n\n        getStorageManager().saveFile(file);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func saveLocalFile(newRemotePath: String) {\n    file.setFileName(newName)\n\n    if !file.isEncrypted() {\n        file.setDecryptedRemotePath(newRemotePath)\n    }\n\n    if file.isDown() {\n        let oldPath = file.getStoragePath()\n        let f = File(oldPath)\n        var parentStoragePath = f.getParent()\n        if !parentStoragePath.hasSuffix(File.separator) {\n            parentStoragePath += File.separator\n        }\n        if f.renameTo(File(parentStoragePath + newName)) {\n            let newPath = parentStoragePath + newName\n            file.setStoragePath(newPath)\n\n            getStorageManager().deleteFileInMediaScan(oldPath)\n            if MimeTypeUtil.isMedia(file.getMimeType()) {\n                FileDataStorageManager.triggerMediaScan(newPath, file)\n            }\n        }\n    }\n\n    getStorageManager().saveFile(file)\n}\n```"
    },
    {
        "method_name": "isValidNewName",
        "method_code": "rivate boolean isValidNewName() throws IOException {\n        // check tricky names\n        if (TextUtils.isEmpty(newName) || newName.contains(File.separator)) {\n            return false;\n        }\n        // create a test file\n        String tmpFolderName = FileStorageUtils.getTemporalPath(\"\");\n        File testFile = new File(tmpFolderName + newName);\n        File tmpFolder = testFile.getParentFile();\n        if (!tmpFolder.exists() && !tmpFolder.mkdirs()) {\n            Log_OC.e(TAG, \"Unable to create parent folder \" + tmpFolder.getAbsolutePath());\n        }\n        if (!tmpFolder.isDirectory()) {\n            throw new IOException(\"Unexpected error: temporal directory could not be created\");\n        }\n        try {\n            testFile.createNewFile();   // return value is ignored; it could be 'false' because\n            // the file already existed, that doesn't invalidate the name\n        } catch (IOException e) {\n            Log_OC.i(TAG, \"Test for validity of name \" + newName + \" in the file system failed\");\n            return false;\n        }\n        boolean result = testFile.exists() && testFile.isFile();\n\n        // cleaning ; result is ignored, since there is not much we could do in case of failure,\n        // but repeat and repeat...\n        testFile.delete();\n\n        return result;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled isValidNewName from RenameFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: isValidNewName\n\n        Method Code: rivate boolean isValidNewName() throws IOException {\n        // check tricky names\n        if (TextUtils.isEmpty(newName) || newName.contains(File.separator)) {\n            return false;\n        }\n        // create a test file\n        String tmpFolderName = FileStorageUtils.getTemporalPath(\"\");\n        File testFile = new File(tmpFolderName + newName);\n        File tmpFolder = testFile.getParentFile();\n        if (!tmpFolder.exists() && !tmpFolder.mkdirs()) {\n            Log_OC.e(TAG, \"Unable to create parent folder \" + tmpFolder.getAbsolutePath());\n        }\n        if (!tmpFolder.isDirectory()) {\n            throw new IOException(\"Unexpected error: temporal directory could not be created\");\n        }\n        try {\n            testFile.createNewFile();   // return value is ignored; it could be 'false' because\n            // the file already existed, that doesn't invalidate the name\n        } catch (IOException e) {\n            Log_OC.i(TAG, \"Test for validity of name \" + newName + \" in the file system failed\");\n            return false;\n        }\n        boolean result = testFile.exists() && testFile.isFile();\n\n        // cleaning ; result is ignored, since there is not much we could do in case of failure,\n        // but repeat and repeat...\n        testFile.delete();\n\n        return result;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func isValidNewName() throws -> Bool {\n    // check tricky names\n    if newName.isEmpty || newName.contains(FileManager.default.pathSeparator) {\n        return false\n    }\n    // create a test file\n    let tmpFolderName = FileStorageUtils.getTemporalPath(\"\")\n    let testFilePath = tmpFolderName + newName\n    let tmpFolder = URL(fileURLWithPath: testFilePath).deletingLastPathComponent()\n    if !FileManager.default.fileExists(atPath: tmpFolder.path) {\n        do {\n            try FileManager.default.createDirectory(at: tmpFolder, withIntermediateDirectories: true, attributes: nil)\n        } catch {\n            print(\"Unable to create parent folder \\(tmpFolder.path)\")\n        }\n    }\n    if !FileManager.default.fileExists(atPath: tmpFolder.path, isDirectory: nil) {\n        throw NSError(domain: \"Unexpected error: temporal directory could not be created\", code: 0, userInfo: nil)\n    }\n    do {\n        FileManager.default.createFile(atPath: testFilePath, contents: nil, attributes: nil)\n    } catch {\n        print(\"Test for validity of name \\(newName) in the file system failed\")\n        return false\n    }\n    let result = FileManager.default.fileExists(atPath: testFilePath)\n    \n    // cleaning; result is ignored, since there is not much we could do in case of failure,\n    // but repeat and repeat...\n    try? FileManager.default.removeItem(atPath: testFilePath)\n    \n    return result\n}\n```"
    },
    {
        "method_name": "getFile",
        "method_code": "ublic OCFile getFile() {\n        return this.file;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getFile from RenameFileOperation.java into Swift.\n\n        Input:\n\n        Method Name: getFile\n\n        Method Code: ublic OCFile getFile() {\n        return this.file;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getFile() -> OCFile {\n    return self.file\n}\n```"
    }
]