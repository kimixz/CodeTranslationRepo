[
    {
        "method_name": "getReminders",
        "method_code": "ublic List<Integer> getReminders(List<Integer> eventReminders) {\n            if (eventReminders.size() > 0 && getImportReminders()) {\n                return eventReminders;\n            }\n            return mDefaultReminders;\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getReminders from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getReminders\n\n        Method Code: ublic List<Integer> getReminders(List<Integer> eventReminders) {\n            if (eventReminders.size() > 0 && getImportReminders()) {\n                return eventReminders;\n            }\n            return mDefaultReminders;\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getReminders(eventReminders: [Int]) -> [Int] {\n    if eventReminders.count > 0 && getImportReminders() {\n        return eventReminders\n    }\n    return mDefaultReminders\n}\n```"
    },
    {
        "method_name": "getKeepUids",
        "method_code": "ublic boolean getKeepUids() {\n            return true; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getKeepUids from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getKeepUids\n\n        Method Code: ublic boolean getKeepUids() {\n            return true; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getKeepUids() -> Bool {\n    return true // upstream this is a setting // TODO check if we need to also have this as a setting\n}\n```"
    },
    {
        "method_name": "getImportReminders",
        "method_code": "rivate boolean getImportReminders() {\n            return true; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getImportReminders from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getImportReminders\n\n        Method Code: rivate boolean getImportReminders() {\n            return true; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getImportReminders() -> Bool {\n    return true // upstream this is a setting // TODO check if we need to also have this as a setting\n}\n```"
    },
    {
        "method_name": "getGlobalUids",
        "method_code": "rivate boolean getGlobalUids() {\n            return false; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getGlobalUids from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getGlobalUids\n\n        Method Code: rivate boolean getGlobalUids() {\n            return false; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getGlobalUids() -> Bool {\n    return false // upstream this is a setting // TODO check if we need to also have this as a setting\n}\n```"
    },
    {
        "method_name": "getTestFileSupport",
        "method_code": "rivate boolean getTestFileSupport() {\n            return false; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getTestFileSupport from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getTestFileSupport\n\n        Method Code: rivate boolean getTestFileSupport() {\n            return false; // upstream this is a setting // TODO check if we need to also have this as a setting\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getTestFileSupport() -> Bool {\n    return false // upstream this is a setting // TODO check if we need to also have this as a setting\n}\n```"
    },
    {
        "method_name": "getDuplicateHandling",
        "method_code": "ublic DuplicateHandlingEnum getDuplicateHandling() {\n//            return DuplicateHandlingEnum.values()[getEnumInt(PREF_DUPLICATE_HANDLING, 0)]; \n            return DuplicateHandlingEnum.values()[0]; // TODO is option needed?\n        }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled getDuplicateHandling from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: getDuplicateHandling\n\n        Method Code: ublic DuplicateHandlingEnum getDuplicateHandling() {\n//            return DuplicateHandlingEnum.values()[getEnumInt(PREF_DUPLICATE_HANDLING, 0)]; \n            return DuplicateHandlingEnum.values()[0]; // TODO is option needed?\n        }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getDuplicateHandling() -> DuplicateHandlingEnum {\n    return DuplicateHandlingEnum.allCases[0] // TODO is option needed?\n}\n```"
    },
    {
        "method_name": "run",
        "method_code": "ublic void run() throws Exception {\n        final Options options = new Options(context);\n        List<Integer> reminders = new ArrayList<>();\n\n        ComponentList events = mICalCalendar.getComponents(VEvent.VEVENT);\n\n        ContentResolver resolver = context.getContentResolver();\n        int numDel = 0;\n        int numIns = 0;\n        int numDups = 0;\n\n        ContentValues cAlarm = new ContentValues();\n        cAlarm.put(Reminders.METHOD, Reminders.METHOD_ALERT);\n\n        final DuplicateHandlingEnum dupes = options.getDuplicateHandling();\n\n        Log_OC.i(TAG, (mIsInserter ? \"Insert\" : \"Delete\") + \" for id \" + selectedCal.mIdStr);\n        Log_OC.d(TAG, \"Duplication option is \" + dupes.ordinal());\n\n        for (Object ve : events) {\n            VEvent e = (VEvent) ve;\n            Log_OC.d(TAG, \"source event: \" + e.toString());\n\n            if (e.getRecurrenceId() != null) {\n                // FIXME: Support these edited instances\n                Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\");\n                continue;\n            }\n\n            long insertCalendarId = selectedCal.mId; // Calendar id to insert to\n\n            ContentValues c = convertToDB(e, options, reminders, selectedCal.mId);\n\n            Cursor cur = null;\n            boolean mustDelete = !mIsInserter;\n\n            // Determine if we need to delete a duplicate event in order to update it\n            if (!mustDelete && dupes != DuplicateHandlingEnum.DUP_DONT_CHECK) {\n\n                cur = query(resolver, options, c);\n                while (!mustDelete && cur != null && cur.moveToNext()) {\n                    if (dupes == DuplicateHandlingEnum.DUP_REPLACE) {\n                        mustDelete = cur.getLong(EVENT_QUERY_CALENDAR_ID_COL) == selectedCal.mId;\n                    } else {\n                        mustDelete = true; // Replacing all (or ignoring, handled just below)\n                    }\n                }\n\n                if (mustDelete) {\n                    if (dupes == DuplicateHandlingEnum.DUP_IGNORE) {\n                        Log_OC.i(TAG, \"Avoiding inserting a duplicate event\");\n                        numDups++;\n                        cur.close();\n                        continue;\n                    }\n                    cur.moveToPosition(-1); // Rewind for use below\n                }\n            }\n\n            if (mustDelete) {\n                if (cur == null) {\n                    cur = query(resolver, options, c);\n                }\n\n                while (cur != null && cur.moveToNext()) {\n                    long rowCalendarId = cur.getLong(EVENT_QUERY_CALENDAR_ID_COL);\n\n                    if (dupes == DuplicateHandlingEnum.DUP_REPLACE\n                        && rowCalendarId != selectedCal.mId) {\n                        Log_OC.i(TAG, \"Avoiding deleting duplicate event in calendar \" + rowCalendarId);\n                        continue; // Not in the destination calendar\n                    }\n\n                    String id = cur.getString(EVENT_QUERY_ID_COL);\n                    Uri eventUri = Uri.withAppendedPath(Events.CONTENT_URI, id);\n                    numDel += resolver.delete(eventUri, null, null);\n                    String where = Reminders.EVENT_ID + \"=?\";\n                    resolver.delete(Reminders.CONTENT_URI, where, new String[]{id});\n                    if (mIsInserter && rowCalendarId != selectedCal.mId\n                        && dupes == DuplicateHandlingEnum.DUP_REPLACE_ANY) {\n                        // Must update this event in the calendar this row came from\n                        Log_OC.i(TAG, \"Changing calendar: \" + rowCalendarId + \" to \" + insertCalendarId);\n                        insertCalendarId = rowCalendarId;\n                    }\n                }\n            }\n\n            if (cur != null) {\n                cur.close();\n            }\n\n            if (!mIsInserter) {\n                continue;\n            }\n\n            if (Events.UID_2445 != null && !c.containsKey(Events.UID_2445)) {\n                // Create a UID for this event to use. We create it here so if\n                // exported multiple times it will always have the same id.\n                c.put(Events.UID_2445, generateUid()); // TODO use \n            }\n\n            c.put(Events.CALENDAR_ID, insertCalendarId);\n            if (options.getTestFileSupport()) {\n                processEventTests(e, c, reminders);\n                numIns++;\n                continue;\n            }\n\n            Uri uri = insertAndLog(resolver, Events.CONTENT_URI, c, \"Event\");\n            if (uri == null) {\n                continue;\n            }\n\n            final long id = Long.parseLong(uri.getLastPathSegment());\n\n            for (int time : options.getReminders(reminders)) {\n                cAlarm.put(Reminders.EVENT_ID, id);\n                cAlarm.put(Reminders.MINUTES, time);\n                insertAndLog(resolver, Reminders.CONTENT_URI, cAlarm, \"Reminder\");\n            }\n            numIns++;\n        }\n\n        selectedCal.mNumEntries += numIns;\n        selectedCal.mNumEntries -= numDel;\n\n        Resources res = context.getResources();\n        int n = mIsInserter ? numIns : numDel;\n        String msg = res.getQuantityString(R.plurals.processed_n_entries, n, n) + \"\\n\";\n        if (mIsInserter) {\n            msg += \"\\n\";\n            if (options.getDuplicateHandling() == DuplicateHandlingEnum.DUP_DONT_CHECK) {\n                msg += res.getString(R.string.did_not_check_for_dupes);\n            } else {\n                msg += res.getQuantityString(R.plurals.found_n_duplicates, numDups, numDups);\n            }\n        }\n\n        // TODO show failure in starting context\n        // DisplayUtils.showSnackMessage(context, msg);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled run from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: run\n\n        Method Code: ublic void run() throws Exception {\n        final Options options = new Options(context);\n        List<Integer> reminders = new ArrayList<>();\n\n        ComponentList events = mICalCalendar.getComponents(VEvent.VEVENT);\n\n        ContentResolver resolver = context.getContentResolver();\n        int numDel = 0;\n        int numIns = 0;\n        int numDups = 0;\n\n        ContentValues cAlarm = new ContentValues();\n        cAlarm.put(Reminders.METHOD, Reminders.METHOD_ALERT);\n\n        final DuplicateHandlingEnum dupes = options.getDuplicateHandling();\n\n        Log_OC.i(TAG, (mIsInserter ? \"Insert\" : \"Delete\") + \" for id \" + selectedCal.mIdStr);\n        Log_OC.d(TAG, \"Duplication option is \" + dupes.ordinal());\n\n        for (Object ve : events) {\n            VEvent e = (VEvent) ve;\n            Log_OC.d(TAG, \"source event: \" + e.toString());\n\n            if (e.getRecurrenceId() != null) {\n                // FIXME: Support these edited instances\n                Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\");\n                continue;\n            }\n\n            long insertCalendarId = selectedCal.mId; // Calendar id to insert to\n\n            ContentValues c = convertToDB(e, options, reminders, selectedCal.mId);\n\n            Cursor cur = null;\n            boolean mustDelete = !mIsInserter;\n\n            // Determine if we need to delete a duplicate event in order to update it\n            if (!mustDelete && dupes != DuplicateHandlingEnum.DUP_DONT_CHECK) {\n\n                cur = query(resolver, options, c);\n                while (!mustDelete && cur != null && cur.moveToNext()) {\n                    if (dupes == DuplicateHandlingEnum.DUP_REPLACE) {\n                        mustDelete = cur.getLong(EVENT_QUERY_CALENDAR_ID_COL) == selectedCal.mId;\n                    } else {\n                        mustDelete = true; // Replacing all (or ignoring, handled just below)\n                    }\n                }\n\n                if (mustDelete) {\n                    if (dupes == DuplicateHandlingEnum.DUP_IGNORE) {\n                        Log_OC.i(TAG, \"Avoiding inserting a duplicate event\");\n                        numDups++;\n                        cur.close();\n                        continue;\n                    }\n                    cur.moveToPosition(-1); // Rewind for use below\n                }\n            }\n\n            if (mustDelete) {\n                if (cur == null) {\n                    cur = query(resolver, options, c);\n                }\n\n                while (cur != null && cur.moveToNext()) {\n                    long rowCalendarId = cur.getLong(EVENT_QUERY_CALENDAR_ID_COL);\n\n                    if (dupes == DuplicateHandlingEnum.DUP_REPLACE\n                        && rowCalendarId != selectedCal.mId) {\n                        Log_OC.i(TAG, \"Avoiding deleting duplicate event in calendar \" + rowCalendarId);\n                        continue; // Not in the destination calendar\n                    }\n\n                    String id = cur.getString(EVENT_QUERY_ID_COL);\n                    Uri eventUri = Uri.withAppendedPath(Events.CONTENT_URI, id);\n                    numDel += resolver.delete(eventUri, null, null);\n                    String where = Reminders.EVENT_ID + \"=?\";\n                    resolver.delete(Reminders.CONTENT_URI, where, new String[]{id});\n                    if (mIsInserter && rowCalendarId != selectedCal.mId\n                        && dupes == DuplicateHandlingEnum.DUP_REPLACE_ANY) {\n                        // Must update this event in the calendar this row came from\n                        Log_OC.i(TAG, \"Changing calendar: \" + rowCalendarId + \" to \" + insertCalendarId);\n                        insertCalendarId = rowCalendarId;\n                    }\n                }\n            }\n\n            if (cur != null) {\n                cur.close();\n            }\n\n            if (!mIsInserter) {\n                continue;\n            }\n\n            if (Events.UID_2445 != null && !c.containsKey(Events.UID_2445)) {\n                // Create a UID for this event to use. We create it here so if\n                // exported multiple times it will always have the same id.\n                c.put(Events.UID_2445, generateUid()); // TODO use \n            }\n\n            c.put(Events.CALENDAR_ID, insertCalendarId);\n            if (options.getTestFileSupport()) {\n                processEventTests(e, c, reminders);\n                numIns++;\n                continue;\n            }\n\n            Uri uri = insertAndLog(resolver, Events.CONTENT_URI, c, \"Event\");\n            if (uri == null) {\n                continue;\n            }\n\n            final long id = Long.parseLong(uri.getLastPathSegment());\n\n            for (int time : options.getReminders(reminders)) {\n                cAlarm.put(Reminders.EVENT_ID, id);\n                cAlarm.put(Reminders.MINUTES, time);\n                insertAndLog(resolver, Reminders.CONTENT_URI, cAlarm, \"Reminder\");\n            }\n            numIns++;\n        }\n\n        selectedCal.mNumEntries += numIns;\n        selectedCal.mNumEntries -= numDel;\n\n        Resources res = context.getResources();\n        int n = mIsInserter ? numIns : numDel;\n        String msg = res.getQuantityString(R.plurals.processed_n_entries, n, n) + \"\\n\";\n        if (mIsInserter) {\n            msg += \"\\n\";\n            if (options.getDuplicateHandling() == DuplicateHandlingEnum.DUP_DONT_CHECK) {\n                msg += res.getString(R.string.did_not_check_for_dupes);\n            } else {\n                msg += res.getQuantityString(R.plurals.found_n_duplicates, numDups, numDups);\n            }\n        }\n\n        // TODO show failure in starting context\n        // DisplayUtils.showSnackMessage(context, msg);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc run() throws {\n    let options = Options(context: context)\n    var reminders: [Int] = []\n\n    let events = mICalCalendar.getComponents(VEvent.VEVENT)\n\n    let resolver = context.contentResolver\n    var numDel = 0\n    var numIns = 0\n    var numDups = 0\n\n    var cAlarm = ContentValues()\n    cAlarm.put(Reminders.METHOD, Reminders.METHOD_ALERT)\n\n    let dupes = options.getDuplicateHandling()\n\n    Log_OC.i(TAG, \"\\(mIsInserter ? \"Insert\" : \"Delete\") for id \\(selectedCal.mIdStr)\")\n    Log_OC.d(TAG, \"Duplication option is \\(dupes.rawValue)\")\n\n    for ve in events {\n        guard let e = ve as? VEvent else { continue }\n        Log_OC.d(TAG, \"source event: \\(e)\")\n\n        if e.getRecurrenceId() != nil {\n            Log_OC.w(TAG, \"Ignoring edited instance of a recurring event\")\n            continue\n        }\n\n        var insertCalendarId = selectedCal.mId\n\n        let c = convertToDB(e, options: options, reminders: reminders, calendarId: selectedCal.mId)\n\n        var cur: Cursor? = nil\n        var mustDelete = !mIsInserter\n\n        if !mustDelete && dupes != .DUP_DONT_CHECK {\n            cur = query(resolver: resolver, options: options, c: c)\n            while !mustDelete && cur != nil && cur!.moveToNext() {\n                if dupes == .DUP_REPLACE {\n                    mustDelete = cur!.getLong(EVENT_QUERY_CALENDAR_ID_COL) == selectedCal.mId\n                } else {\n                    mustDelete = true\n                }\n            }\n\n            if mustDelete {\n                if dupes == .DUP_IGNORE {\n                    Log_OC.i(TAG, \"Avoiding inserting a duplicate event\")\n                    numDups += 1\n                    cur?.close()\n                    continue\n                }\n                cur?.moveToPosition(-1)\n            }\n        }\n\n        if mustDelete {\n            if cur == nil {\n                cur = query(resolver: resolver, options: options, c: c)\n            }\n\n            while cur != nil && cur!.moveToNext() {\n                let rowCalendarId = cur!.getLong(EVENT_QUERY_CALENDAR_ID_COL)\n\n                if dupes == .DUP_REPLACE && rowCalendarId != selectedCal.mId {\n                    Log_OC.i(TAG, \"Avoiding deleting duplicate event in calendar \\(rowCalendarId)\")\n                    continue\n                }\n\n                let id = cur!.getString(EVENT_QUERY_ID_COL)\n                let eventUri = Uri.withAppendedPath(Events.CONTENT_URI, id)\n                numDel += resolver.delete(eventUri, null, null)\n                let whereClause = \"\\(Reminders.EVENT_ID)=?\"\n                resolver.delete(Reminders.CONTENT_URI, whereClause, [id])\n                if mIsInserter && rowCalendarId != selectedCal.mId && dupes == .DUP_REPLACE_ANY {\n                    Log_OC.i(TAG, \"Changing calendar: \\(rowCalendarId) to \\(insertCalendarId)\")\n                    insertCalendarId = rowCalendarId\n                }\n            }\n        }\n\n        cur?.close()\n\n        if !mIsInserter {\n            continue\n        }\n\n        if Events.UID_2445 != nil && !c.containsKey(Events.UID_2445) {\n            c.put(Events.UID_2445, generateUid())\n        }\n\n        c.put(Events.CALENDAR_ID, insertCalendarId)\n        if options.getTestFileSupport() {\n            processEventTests(e, c: c, reminders: reminders)\n            numIns += 1\n            continue\n        }\n\n        let uri = insertAndLog(resolver: resolver, uri: Events.CONTENT_URI, values: c, logTag: \"Event\")\n        if uri == nil {\n            continue\n        }\n\n        let id = Int64(uri!.lastPathSegment!)!\n\n        for time in options.getReminders(reminders: reminders) {\n            cAlarm.put(Reminders.EVENT_ID, id)\n            cAlarm.put(Reminders.MINUTES, time)\n            insertAndLog(resolver: resolver, uri: Reminders.CONTENT_URI, values: cAlarm, logTag: \"Reminder\")\n        }\n        numIns += 1\n    }\n\n    selectedCal.mNumEntries += numIns\n    selectedCal.mNumEntries -= numDel\n\n    let res = context.resources\n    let n = mIsInserter ? numIns : numDel\n    var msg = res.getQuantityString(R.plurals.processed_n_entries, n, n) + \"\\n\"\n    if mIsInserter {\n        msg += \"\\n\"\n        if options.getDuplicateHandling() == .DUP_DONT_CHECK {\n            msg += res.getString(R.string.did_not_check_for_dupes)\n        } else {\n            msg += res.getQuantityString(R.plurals.found_n_duplicates, numDups, numDups)\n        }\n    }\n}\n```"
    },
    {
        "method_name": "convertToDB",
        "method_code": "rivate ContentValues convertToDB(VEvent e, Options options,\n                                      List<Integer> reminders, long calendarId) {\n        reminders.clear();\n\n        boolean allDay = false;\n        boolean startIsDate = !(e.getStartDate().getDate() instanceof DateTime);\n        boolean isRecurring = hasProperty(e, Property.RRULE) || hasProperty(e, Property.RDATE);\n\n        if (startIsDate) {\n            // If the start date is a DATE we expect the end date to be a date too and the\n            // event is all-day, midnight to midnight (RFC 2445).\n            allDay = true;\n        }\n\n        if (!hasProperty(e, Property.DTEND) && !hasProperty(e, Property.DURATION)) {\n            // No end date or duration given.\n            // Since we added a duration above when the start date is a DATE:\n            // - The start date is a DATETIME, the event lasts no time at all (RFC 2445).\n            e.getProperties().add(ZERO_SECONDS);\n            // Zero time events are always free (RFC 2445), so override/set TRANSP accordingly.\n            removeProperty(e, Property.TRANSP);\n            e.getProperties().add(Transp.TRANSPARENT);\n        }\n\n        if (isRecurring) {\n            // Recurring event. Android insists on a duration.\n            if (!hasProperty(e, Property.DURATION)) {\n                // Calculate duration from start to end date\n                Duration d = new Duration(e.getStartDate().getDate(), e.getEndDate().getDate());\n                e.getProperties().add(d);\n            }\n            removeProperty(e, Property.DTEND);\n        } else {\n            // Non-recurring event. Android insists on an end date.\n            if (!hasProperty(e, Property.DTEND)) {\n                // Calculate end date from duration, set it and remove the duration.\n                e.getProperties().add(e.getEndDate());\n            }\n            removeProperty(e, Property.DURATION);\n        }\n\n        // Now calculate the db values for the event\n        ContentValues c = new ContentValues();\n\n        c.put(Events.CALENDAR_ID, calendarId);\n        copyProperty(c, Events.TITLE, e, Property.SUMMARY);\n        copyProperty(c, Events.DESCRIPTION, e, Property.DESCRIPTION);\n\n        if (e.getOrganizer() != null) {\n            URI uri = e.getOrganizer().getCalAddress();\n            try {\n                MailTo mailTo = MailTo.parse(uri.toString());\n                c.put(Events.ORGANIZER, mailTo.getTo());\n                c.put(Events.GUESTS_CAN_MODIFY, 1); // Ensure we can edit if not the organiser\n            } catch (ParseException ignored) {\n                Log_OC.e(TAG, \"Failed to parse Organiser URI \" + uri.toString());\n            }\n        }\n\n        copyProperty(c, Events.EVENT_LOCATION, e, Property.LOCATION);\n\n        if (hasProperty(e, Property.STATUS)) {\n            String status = e.getProperty(Property.STATUS).getValue();\n            switch (status) {\n                case \"TENTATIVE\":\n                    c.put(Events.STATUS, Events.STATUS_TENTATIVE);\n                    break;\n                case \"CONFIRMED\":\n                    c.put(Events.STATUS, Events.STATUS_CONFIRMED);\n                    break;\n                case \"CANCELLED\":  // NOTE: In ical4j it is CANCELLED with two L\n                    c.put(Events.STATUS, Events.STATUS_CANCELED);\n                    break;\n            }\n        }\n\n        copyProperty(c, Events.DURATION, e, Property.DURATION);\n\n        if (allDay) {\n            c.put(Events.ALL_DAY, 1);\n        }\n\n        copyDateProperty(c, Events.DTSTART, Events.EVENT_TIMEZONE, e.getStartDate());\n        if (hasProperty(e, Property.DTEND)) {\n            copyDateProperty(c, Events.DTEND, Events.EVENT_END_TIMEZONE, e.getEndDate());\n        }\n\n        if (hasProperty(e, Property.CLASS)) {\n            String access = e.getProperty(Property.CLASS).getValue();\n            int accessLevel = Events.ACCESS_DEFAULT;\n            switch (access) {\n                case \"CONFIDENTIAL\":\n                    accessLevel = Events.ACCESS_CONFIDENTIAL;\n                    break;\n                case \"PRIVATE\":\n                    accessLevel = Events.ACCESS_PRIVATE;\n                    break;\n                case \"PUBLIC\":\n                    accessLevel = Events.ACCESS_PUBLIC;\n                    break;\n            }\n\n            c.put(Events.ACCESS_LEVEL, accessLevel);\n        }\n\n        // Work out availability. This is confusing as FREEBUSY and TRANSP overlap.\n        if (Events.AVAILABILITY != null) {\n            int availability = Events.AVAILABILITY_BUSY;\n            if (hasProperty(e, Property.TRANSP)) {\n                if (e.getTransparency() == Transp.TRANSPARENT) {\n                    availability = Events.AVAILABILITY_FREE;\n                }\n\n            } else if (hasProperty(e, Property.FREEBUSY)) {\n                FreeBusy fb = (FreeBusy) e.getProperty(Property.FREEBUSY);\n                FbType fbType = (FbType) fb.getParameter(Parameter.FBTYPE);\n                if (fbType != null && fbType == FbType.FREE) {\n                    availability = Events.AVAILABILITY_FREE;\n                } else if (fbType != null && fbType == FbType.BUSY_TENTATIVE) {\n                    availability = Events.AVAILABILITY_TENTATIVE;\n                }\n            }\n            c.put(Events.AVAILABILITY, availability);\n        }\n\n        copyProperty(c, Events.RRULE, e, Property.RRULE);\n        copyProperty(c, Events.RDATE, e, Property.RDATE);\n        copyProperty(c, Events.EXRULE, e, Property.EXRULE);\n        copyProperty(c, Events.EXDATE, e, Property.EXDATE);\n        copyProperty(c, Events.CUSTOM_APP_URI, e, Property.URL);\n        copyProperty(c, Events.UID_2445, e, Property.UID);\n        if (c.containsKey(Events.UID_2445) && TextUtils.isEmpty(c.getAsString(Events.UID_2445))) {\n            // Remove null/empty UIDs\n            c.remove(Events.UID_2445);\n        }\n\n        for (Object alarm : e.getAlarms()) {\n            VAlarm a = (VAlarm) alarm;\n\n            if (a.getAction() != Action.AUDIO && a.getAction() != Action.DISPLAY) {\n                continue; // Ignore email and procedure alarms\n            }\n\n            Trigger t = a.getTrigger();\n            final long startMs = e.getStartDate().getDate().getTime();\n            long alarmStartMs = startMs;\n            long alarmMs;\n\n            // FIXME: - Support for repeating alarms\n            //        - Check the calendars max number of alarms\n            if (t.getDateTime() != null) {\n                alarmMs = t.getDateTime().getTime(); // Absolute\n            } else if (t.getDuration() != null && t.getDuration().isNegative()) {\n                //alarm trigger before start of event\n                Related rel = (Related) t.getParameter(Parameter.RELATED);\n                if (rel != null && rel == Related.END) {\n                    alarmStartMs = e.getEndDate().getDate().getTime();\n                }\n                alarmMs = alarmStartMs - durationToMs(t.getDuration()); // Relative \"-\"\n            } else if (t.getDuration() != null && !t.getDuration().isNegative()) {\n                //alarm trigger after start of event\n                Related rel = (Related) t.getParameter(Parameter.RELATED);\n                if (rel != null && rel == Related.END) {\n                    alarmStartMs = e.getEndDate().getDate().getTime();\n                }\n                alarmMs = alarmStartMs + durationToMs(t.getDuration()); // Relative \"+\"\n            } else {\n                continue;\n            }\n\n            int reminder = (int) ((startMs - alarmMs) / DateUtils.MINUTE_IN_MILLIS);\n            if (!reminders.contains(reminder)) {\n                reminders.add(reminder);\n            }\n        }\n\n        if (options.getReminders(reminders).size() > 0) {\n            c.put(Events.HAS_ALARM, 1);\n        }\n\n        // FIXME: Attendees, SELF_ATTENDEE_STATUS\n        return c;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled convertToDB from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: convertToDB\n\n        Method Code: rivate ContentValues convertToDB(VEvent e, Options options,\n                                      List<Integer> reminders, long calendarId) {\n        reminders.clear();\n\n        boolean allDay = false;\n        boolean startIsDate = !(e.getStartDate().getDate() instanceof DateTime);\n        boolean isRecurring = hasProperty(e, Property.RRULE) || hasProperty(e, Property.RDATE);\n\n        if (startIsDate) {\n            // If the start date is a DATE we expect the end date to be a date too and the\n            // event is all-day, midnight to midnight (RFC 2445).\n            allDay = true;\n        }\n\n        if (!hasProperty(e, Property.DTEND) && !hasProperty(e, Property.DURATION)) {\n            // No end date or duration given.\n            // Since we added a duration above when the start date is a DATE:\n            // - The start date is a DATETIME, the event lasts no time at all (RFC 2445).\n            e.getProperties().add(ZERO_SECONDS);\n            // Zero time events are always free (RFC 2445), so override/set TRANSP accordingly.\n            removeProperty(e, Property.TRANSP);\n            e.getProperties().add(Transp.TRANSPARENT);\n        }\n\n        if (isRecurring) {\n            // Recurring event. Android insists on a duration.\n            if (!hasProperty(e, Property.DURATION)) {\n                // Calculate duration from start to end date\n                Duration d = new Duration(e.getStartDate().getDate(), e.getEndDate().getDate());\n                e.getProperties().add(d);\n            }\n            removeProperty(e, Property.DTEND);\n        } else {\n            // Non-recurring event. Android insists on an end date.\n            if (!hasProperty(e, Property.DTEND)) {\n                // Calculate end date from duration, set it and remove the duration.\n                e.getProperties().add(e.getEndDate());\n            }\n            removeProperty(e, Property.DURATION);\n        }\n\n        // Now calculate the db values for the event\n        ContentValues c = new ContentValues();\n\n        c.put(Events.CALENDAR_ID, calendarId);\n        copyProperty(c, Events.TITLE, e, Property.SUMMARY);\n        copyProperty(c, Events.DESCRIPTION, e, Property.DESCRIPTION);\n\n        if (e.getOrganizer() != null) {\n            URI uri = e.getOrganizer().getCalAddress();\n            try {\n                MailTo mailTo = MailTo.parse(uri.toString());\n                c.put(Events.ORGANIZER, mailTo.getTo());\n                c.put(Events.GUESTS_CAN_MODIFY, 1); // Ensure we can edit if not the organiser\n            } catch (ParseException ignored) {\n                Log_OC.e(TAG, \"Failed to parse Organiser URI \" + uri.toString());\n            }\n        }\n\n        copyProperty(c, Events.EVENT_LOCATION, e, Property.LOCATION);\n\n        if (hasProperty(e, Property.STATUS)) {\n            String status = e.getProperty(Property.STATUS).getValue();\n            switch (status) {\n                case \"TENTATIVE\":\n                    c.put(Events.STATUS, Events.STATUS_TENTATIVE);\n                    break;\n                case \"CONFIRMED\":\n                    c.put(Events.STATUS, Events.STATUS_CONFIRMED);\n                    break;\n                case \"CANCELLED\":  // NOTE: In ical4j it is CANCELLED with two L\n                    c.put(Events.STATUS, Events.STATUS_CANCELED);\n                    break;\n            }\n        }\n\n        copyProperty(c, Events.DURATION, e, Property.DURATION);\n\n        if (allDay) {\n            c.put(Events.ALL_DAY, 1);\n        }\n\n        copyDateProperty(c, Events.DTSTART, Events.EVENT_TIMEZONE, e.getStartDate());\n        if (hasProperty(e, Property.DTEND)) {\n            copyDateProperty(c, Events.DTEND, Events.EVENT_END_TIMEZONE, e.getEndDate());\n        }\n\n        if (hasProperty(e, Property.CLASS)) {\n            String access = e.getProperty(Property.CLASS).getValue();\n            int accessLevel = Events.ACCESS_DEFAULT;\n            switch (access) {\n                case \"CONFIDENTIAL\":\n                    accessLevel = Events.ACCESS_CONFIDENTIAL;\n                    break;\n                case \"PRIVATE\":\n                    accessLevel = Events.ACCESS_PRIVATE;\n                    break;\n                case \"PUBLIC\":\n                    accessLevel = Events.ACCESS_PUBLIC;\n                    break;\n            }\n\n            c.put(Events.ACCESS_LEVEL, accessLevel);\n        }\n\n        // Work out availability. This is confusing as FREEBUSY and TRANSP overlap.\n        if (Events.AVAILABILITY != null) {\n            int availability = Events.AVAILABILITY_BUSY;\n            if (hasProperty(e, Property.TRANSP)) {\n                if (e.getTransparency() == Transp.TRANSPARENT) {\n                    availability = Events.AVAILABILITY_FREE;\n                }\n\n            } else if (hasProperty(e, Property.FREEBUSY)) {\n                FreeBusy fb = (FreeBusy) e.getProperty(Property.FREEBUSY);\n                FbType fbType = (FbType) fb.getParameter(Parameter.FBTYPE);\n                if (fbType != null && fbType == FbType.FREE) {\n                    availability = Events.AVAILABILITY_FREE;\n                } else if (fbType != null && fbType == FbType.BUSY_TENTATIVE) {\n                    availability = Events.AVAILABILITY_TENTATIVE;\n                }\n            }\n            c.put(Events.AVAILABILITY, availability);\n        }\n\n        copyProperty(c, Events.RRULE, e, Property.RRULE);\n        copyProperty(c, Events.RDATE, e, Property.RDATE);\n        copyProperty(c, Events.EXRULE, e, Property.EXRULE);\n        copyProperty(c, Events.EXDATE, e, Property.EXDATE);\n        copyProperty(c, Events.CUSTOM_APP_URI, e, Property.URL);\n        copyProperty(c, Events.UID_2445, e, Property.UID);\n        if (c.containsKey(Events.UID_2445) && TextUtils.isEmpty(c.getAsString(Events.UID_2445))) {\n            // Remove null/empty UIDs\n            c.remove(Events.UID_2445);\n        }\n\n        for (Object alarm : e.getAlarms()) {\n            VAlarm a = (VAlarm) alarm;\n\n            if (a.getAction() != Action.AUDIO && a.getAction() != Action.DISPLAY) {\n                continue; // Ignore email and procedure alarms\n            }\n\n            Trigger t = a.getTrigger();\n            final long startMs = e.getStartDate().getDate().getTime();\n            long alarmStartMs = startMs;\n            long alarmMs;\n\n            // FIXME: - Support for repeating alarms\n            //        - Check the calendars max number of alarms\n            if (t.getDateTime() != null) {\n                alarmMs = t.getDateTime().getTime(); // Absolute\n            } else if (t.getDuration() != null && t.getDuration().isNegative()) {\n                //alarm trigger before start of event\n                Related rel = (Related) t.getParameter(Parameter.RELATED);\n                if (rel != null && rel == Related.END) {\n                    alarmStartMs = e.getEndDate().getDate().getTime();\n                }\n                alarmMs = alarmStartMs - durationToMs(t.getDuration()); // Relative \"-\"\n            } else if (t.getDuration() != null && !t.getDuration().isNegative()) {\n                //alarm trigger after start of event\n                Related rel = (Related) t.getParameter(Parameter.RELATED);\n                if (rel != null && rel == Related.END) {\n                    alarmStartMs = e.getEndDate().getDate().getTime();\n                }\n                alarmMs = alarmStartMs + durationToMs(t.getDuration()); // Relative \"+\"\n            } else {\n                continue;\n            }\n\n            int reminder = (int) ((startMs - alarmMs) / DateUtils.MINUTE_IN_MILLIS);\n            if (!reminders.contains(reminder)) {\n                reminders.add(reminder);\n            }\n        }\n\n        if (options.getReminders(reminders).size() > 0) {\n            c.put(Events.HAS_ALARM, 1);\n        }\n\n        // FIXME: Attendees, SELF_ATTENDEE_STATUS\n        return c;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func convertToDB(e: VEvent, options: Options, reminders: inout [Int], calendarId: Int64) -> [String: Any] {\n    reminders.removeAll()\n\n    var allDay = false\n    let startIsDate = !(e.startDate.date is DateTime)\n    let isRecurring = hasProperty(e, property: .RRULE) || hasProperty(e, property: .RDATE)\n\n    if startIsDate {\n        allDay = true\n    }\n\n    if !hasProperty(e, property: .DTEND) && !hasProperty(e, property: .DURATION) {\n        e.properties.append(ZERO_SECONDS)\n        removeProperty(e, property: .TRANSP)\n        e.properties.append(Transp.TRANSPARENT)\n    }\n\n    if isRecurring {\n        if !hasProperty(e, property: .DURATION) {\n            let d = Duration(start: e.startDate.date, end: e.endDate.date)\n            e.properties.append(d)\n        }\n        removeProperty(e, property: .DTEND)\n    } else {\n        if !hasProperty(e, property: .DTEND) {\n            e.properties.append(e.endDate)\n        }\n        removeProperty(e, property: .DURATION)\n    }\n\n    var c = [String: Any]()\n\n    c[Events.CALENDAR_ID] = calendarId\n    copyProperty(c: &c, eventKey: Events.TITLE, e: e, property: .SUMMARY)\n    copyProperty(c: &c, eventKey: Events.DESCRIPTION, e: e, property: .DESCRIPTION)\n\n    if let organizer = e.organizer {\n        let uri = organizer.calAddress\n        do {\n            let mailTo = try MailTo.parse(uri: uri.absoluteString)\n            c[Events.ORGANIZER] = mailTo.to\n            c[Events.GUESTS_CAN_MODIFY] = 1\n        } catch {\n            print(\"Failed to parse Organiser URI \\(uri.absoluteString)\")\n        }\n    }\n\n    copyProperty(c: &c, eventKey: Events.EVENT_LOCATION, e: e, property: .LOCATION)\n\n    if hasProperty(e, property: .STATUS) {\n        let status = e.getProperty(property: .STATUS)?.value\n        switch status {\n        case \"TENTATIVE\":\n            c[Events.STATUS] = Events.STATUS_TENTATIVE\n        case \"CONFIRMED\":\n            c[Events.STATUS] = Events.STATUS_CONFIRMED\n        case \"CANCELLED\":\n            c[Events.STATUS] = Events.STATUS_CANCELED\n        default:\n            break\n        }\n    }\n\n    copyProperty(c: &c, eventKey: Events.DURATION, e: e, property: .DURATION)\n\n    if allDay {\n        c[Events.ALL_DAY] = 1\n    }\n\n    copyDateProperty(c: &c, eventKey: Events.DTSTART, timezoneKey: Events.EVENT_TIMEZONE, date: e.startDate)\n    if hasProperty(e, property: .DTEND) {\n        copyDateProperty(c: &c, eventKey: Events.DTEND, timezoneKey: Events.EVENT_END_TIMEZONE, date: e.endDate)\n    }\n\n    if hasProperty(e, property: .CLASS) {\n        let access = e.getProperty(property: .CLASS)?.value\n        var accessLevel = Events.ACCESS_DEFAULT\n        switch access {\n        case \"CONFIDENTIAL\":\n            accessLevel = Events.ACCESS_CONFIDENTIAL\n        case \"PRIVATE\":\n            accessLevel = Events.ACCESS_PRIVATE\n        case \"PUBLIC\":\n            accessLevel = Events.ACCESS_PUBLIC\n        default:\n            break\n        }\n        c[Events.ACCESS_LEVEL] = accessLevel\n    }\n\n    if Events.AVAILABILITY != nil {\n        var availability = Events.AVAILABILITY_BUSY\n        if hasProperty(e, property: .TRANSP) {\n            if e.transparency == Transp.TRANSPARENT {\n                availability = Events.AVAILABILITY_FREE\n            }\n        } else if hasProperty(e, property: .FREEBUSY) {\n            if let fb = e.getProperty(property: .FREEBUSY) as? FreeBusy,\n               let fbType = fb.getParameter(parameter: .FBTYPE) as? FbType {\n                if fbType == .FREE {\n                    availability = Events.AVAILABILITY_FREE\n                } else if fbType == .BUSY_TENTATIVE {\n                    availability = Events.AVAILABILITY_TENTATIVE\n                }\n            }\n        }\n        c[Events.AVAILABILITY] = availability\n    }\n\n    copyProperty(c: &c, eventKey: Events.RRULE, e: e, property: .RRULE)\n    copyProperty(c: &c, eventKey: Events.RDATE, e: e, property: .RDATE)\n    copyProperty(c: &c, eventKey: Events.EXRULE, e: e, property: .EXRULE)\n    copyProperty(c: &c, eventKey: Events.EXDATE, e: e, property: .EXDATE)\n    copyProperty(c: &c, eventKey: Events.CUSTOM_APP_URI, e: e, property: .URL)\n    copyProperty(c: &c, eventKey: Events.UID_2445, e: e, property: .UID)\n    if let uid = c[Events.UID_2445] as? String, uid.isEmpty {\n        c.removeValue(forKey: Events.UID_2445)\n    }\n\n    for alarm in e.alarms {\n        guard let a = alarm as? VAlarm else { continue }\n\n        if a.action != .AUDIO && a.action != .DISPLAY {\n            continue\n        }\n\n        let t = a.trigger\n        let startMs = e.startDate.date.timeIntervalSince1970 * 1000\n        var alarmStartMs = startMs\n        var alarmMs: TimeInterval\n\n        if let dateTime = t.dateTime {\n            alarmMs = dateTime.timeIntervalSince1970 * 1000\n        } else if let duration = t.duration, duration.isNegative {\n            if let rel = t.getParameter(parameter: .RELATED) as? Related, rel == .END {\n                alarmStartMs = e.endDate.date.timeIntervalSince1970 * 1000\n            }\n            alarmMs = alarmStartMs - durationToMs(duration: duration)\n        } else if let duration = t.duration, !duration.isNegative {\n            if let rel = t.getParameter(parameter: .RELATED) as? Related, rel == .END {\n                alarmStartMs = e.endDate.date.timeIntervalSince1970 * 1000\n            }\n            alarmMs = alarmStartMs + durationToMs(duration: duration)\n        } else {\n            continue\n        }\n\n        let reminder = Int((startMs - alarmMs) / DateUtils.MINUTE_IN_MILLIS)\n        if !reminders.contains(reminder) {\n            reminders.append(reminder)\n        }\n    }\n\n    if options.getReminders(reminders: reminders).count > 0 {\n        c[Events.HAS_ALARM] = 1\n    }\n\n    return c\n}\n```"
    },
    {
        "method_name": "createDuration",
        "method_code": "rivate static Duration createDuration(String value) {\n        Duration d = new Duration();\n        d.setValue(value);\n        return d;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled createDuration from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: createDuration\n\n        Method Code: rivate static Duration createDuration(String value) {\n        Duration d = new Duration();\n        d.setValue(value);\n        return d;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func createDuration(value: String) -> Duration {\n    let d = Duration()\n    d.setValue(value)\n    return d\n}\n```"
    },
    {
        "method_name": "durationToMs",
        "method_code": "rivate static long durationToMs(Dur d) {\n        long ms = 0;\n        ms += d.getSeconds() * DateUtils.SECOND_IN_MILLIS;\n        ms += d.getMinutes() * DateUtils.MINUTE_IN_MILLIS;\n        ms += d.getHours() * DateUtils.HOUR_IN_MILLIS;\n        ms += d.getDays() * DateUtils.DAY_IN_MILLIS;\n        ms += d.getWeeks() * DateUtils.WEEK_IN_MILLIS;\n        return ms;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled durationToMs from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: durationToMs\n\n        Method Code: rivate static long durationToMs(Dur d) {\n        long ms = 0;\n        ms += d.getSeconds() * DateUtils.SECOND_IN_MILLIS;\n        ms += d.getMinutes() * DateUtils.MINUTE_IN_MILLIS;\n        ms += d.getHours() * DateUtils.HOUR_IN_MILLIS;\n        ms += d.getDays() * DateUtils.DAY_IN_MILLIS;\n        ms += d.getWeeks() * DateUtils.WEEK_IN_MILLIS;\n        return ms;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func durationToMs(_ d: Dur) -> Int64 {\n    var ms: Int64 = 0\n    ms += Int64(d.getSeconds()) * DateUtils.SECOND_IN_MILLIS\n    ms += Int64(d.getMinutes()) * DateUtils.MINUTE_IN_MILLIS\n    ms += Int64(d.getHours()) * DateUtils.HOUR_IN_MILLIS\n    ms += Int64(d.getDays()) * DateUtils.DAY_IN_MILLIS\n    ms += Int64(d.getWeeks()) * DateUtils.WEEK_IN_MILLIS\n    return ms\n}\n```"
    },
    {
        "method_name": "hasProperty",
        "method_code": "rivate boolean hasProperty(VEvent e, String name) {\n        return e.getProperty(name) != null;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled hasProperty from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: hasProperty\n\n        Method Code: rivate boolean hasProperty(VEvent e, String name) {\n        return e.getProperty(name) != null;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func hasProperty(e: VEvent, name: String) -> Bool {\n    return e.getProperty(name) != nil\n}\n```"
    },
    {
        "method_name": "removeProperty",
        "method_code": "rivate void removeProperty(VEvent e, String name) {\n        Property p = e.getProperty(name);\n        if (p != null) {\n            e.getProperties().remove(p);\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled removeProperty from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: removeProperty\n\n        Method Code: rivate void removeProperty(VEvent e, String name) {\n        Property p = e.getProperty(name);\n        if (p != null) {\n            e.getProperties().remove(p);\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func removeProperty(from event: VEvent, name: String) {\n    if let property = event.getProperty(name) {\n        event.getProperties().remove(property)\n    }\n}\n```"
    },
    {
        "method_name": "copyProperty",
        "method_code": "rivate void copyProperty(ContentValues c, String dbName, VEvent e, String evName) {\n        if (dbName != null) {\n            Property p = e.getProperty(evName);\n            if (p != null) {\n                c.put(dbName, p.getValue());\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyProperty from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: copyProperty\n\n        Method Code: rivate void copyProperty(ContentValues c, String dbName, VEvent e, String evName) {\n        if (dbName != null) {\n            Property p = e.getProperty(evName);\n            if (p != null) {\n                c.put(dbName, p.getValue());\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func copyProperty(c: inout [String: Any], dbName: String?, e: VEvent, evName: String) {\n    if let dbName = dbName {\n        if let p = e.getProperty(evName) {\n            c[dbName] = p.getValue()\n        }\n    }\n}\n```"
    },
    {
        "method_name": "copyDateProperty",
        "method_code": "rivate void copyDateProperty(ContentValues c, String dbName, String dbTzName, DateProperty date) {\n        if (dbName != null && date.getDate() != null) {\n            c.put(dbName, date.getDate().getTime()); // ms since epoc in GMT\n            if (dbTzName != null) {\n                if (date.isUtc() || date.getTimeZone() == null) {\n                    c.put(dbTzName, \"UTC\");\n                } else {\n                    c.put(dbTzName, date.getTimeZone().getID());\n                }\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled copyDateProperty from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: copyDateProperty\n\n        Method Code: rivate void copyDateProperty(ContentValues c, String dbName, String dbTzName, DateProperty date) {\n        if (dbName != null && date.getDate() != null) {\n            c.put(dbName, date.getDate().getTime()); // ms since epoc in GMT\n            if (dbTzName != null) {\n                if (date.isUtc() || date.getTimeZone() == null) {\n                    c.put(dbTzName, \"UTC\");\n                } else {\n                    c.put(dbTzName, date.getTimeZone().getID());\n                }\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func copyDateProperty(c: inout [String: Any], dbName: String?, dbTzName: String?, date: DateProperty) {\n    if let dbName = dbName, let dateValue = date.getDate() {\n        c[dbName] = dateValue.timeIntervalSince1970 * 1000 // ms since epoch in GMT\n        if let dbTzName = dbTzName {\n            if date.isUtc() || date.getTimeZone() == nil {\n                c[dbTzName] = \"UTC\"\n            } else {\n                c[dbTzName] = date.getTimeZone()?.identifier\n            }\n        }\n    }\n}\n```"
    },
    {
        "method_name": "insertAndLog",
        "method_code": "rivate Uri insertAndLog(ContentResolver resolver, Uri uri, ContentValues c, String type) {\n        Log_OC.d(TAG, \"Inserting \" + type + \" values: \" + c);\n\n        Uri result = resolver.insert(uri, c);\n        if (result == null) {\n            Log_OC.e(TAG, \"failed to insert \" + type);\n            Log_OC.e(TAG, \"failed \" + type + \" values: \" + c); // Not already logged, dump now\n        } else {\n            Log_OC.d(TAG, \"Insert \" + type + \" returned \" + result.toString());\n        }\n        return result;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled insertAndLog from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: insertAndLog\n\n        Method Code: rivate Uri insertAndLog(ContentResolver resolver, Uri uri, ContentValues c, String type) {\n        Log_OC.d(TAG, \"Inserting \" + type + \" values: \" + c);\n\n        Uri result = resolver.insert(uri, c);\n        if (result == null) {\n            Log_OC.e(TAG, \"failed to insert \" + type);\n            Log_OC.e(TAG, \"failed \" + type + \" values: \" + c); // Not already logged, dump now\n        } else {\n            Log_OC.d(TAG, \"Insert \" + type + \" returned \" + result.toString());\n        }\n        return result;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func insertAndLog(resolver: ContentResolver, uri: Uri, values: ContentValues, type: String) -> Uri? {\n    Log_OC.d(TAG, \"Inserting \\(type) values: \\(values)\")\n\n    let result = resolver.insert(uri, values)\n    if result == nil {\n        Log_OC.e(TAG, \"failed to insert \\(type)\")\n        Log_OC.e(TAG, \"failed \\(type) values: \\(values)\")\n    } else {\n        Log_OC.d(TAG, \"Insert \\(type) returned \\(result!.toString())\")\n    }\n    return result\n}\n```"
    },
    {
        "method_name": "queryEvents",
        "method_code": "rivate Cursor queryEvents(ContentResolver resolver, StringBuilder b, List<String> argsList) {\n        final String where = b.toString() + \" AND deleted=0\";\n        final String[] args = argsList.toArray(new String[argsList.size()]);\n        return resolver.query(Events.CONTENT_URI, EVENT_QUERY_COLUMNS, where, args, null);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled queryEvents from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: queryEvents\n\n        Method Code: rivate Cursor queryEvents(ContentResolver resolver, StringBuilder b, List<String> argsList) {\n        final String where = b.toString() + \" AND deleted=0\";\n        final String[] args = argsList.toArray(new String[argsList.size()]);\n        return resolver.query(Events.CONTENT_URI, EVENT_QUERY_COLUMNS, where, args, null);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func queryEvents(resolver: ContentResolver, b: StringBuilder, argsList: [String]) -> Cursor? {\n    let whereClause = \"\\(b.toString()) AND deleted=0\"\n    let args = argsList.map { $0 }\n    return resolver.query(Events.CONTENT_URI, EVENT_QUERY_COLUMNS, whereClause, args, nil)\n}\n```"
    },
    {
        "method_name": "query",
        "method_code": "rivate Cursor query(ContentResolver resolver, Options options, ContentValues c) {\n\n        StringBuilder b = new StringBuilder();\n        List<String> argsList = new ArrayList<>();\n\n        if (options.getKeepUids() && Events.UID_2445 != null && c.containsKey(Events.UID_2445)) {\n            // Use our UID to query, either globally or per-calendar unique\n            if (!options.getGlobalUids()) {\n                b.append(Events.CALENDAR_ID).append(\"=? AND \");\n                argsList.add(c.getAsString(Events.CALENDAR_ID));\n            }\n            b.append(Events.UID_2445).append(\"=?\");\n            argsList.add(c.getAsString(Events.UID_2445));\n            return queryEvents(resolver, b, argsList);\n        }\n\n        // Without UIDs, the best we can do is check the start date and title within\n        // the current calendar, even though this may return false duplicates.\n        if (!c.containsKey(Events.CALENDAR_ID) || !c.containsKey(Events.DTSTART)) {\n            return null;\n        }\n\n        b.append(Events.CALENDAR_ID).append(\"=? AND \");\n        b.append(Events.DTSTART).append(\"=? AND \");\n        b.append(Events.TITLE);\n\n        argsList.add(c.getAsString(Events.CALENDAR_ID));\n        argsList.add(c.getAsString(Events.DTSTART));\n\n        if (c.containsKey(Events.TITLE)) {\n            b.append(\"=?\");\n            argsList.add(c.getAsString(Events.TITLE));\n        } else {\n            b.append(\" is null\");\n        }\n\n        return queryEvents(resolver, b, argsList);\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled query from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: query\n\n        Method Code: rivate Cursor query(ContentResolver resolver, Options options, ContentValues c) {\n\n        StringBuilder b = new StringBuilder();\n        List<String> argsList = new ArrayList<>();\n\n        if (options.getKeepUids() && Events.UID_2445 != null && c.containsKey(Events.UID_2445)) {\n            // Use our UID to query, either globally or per-calendar unique\n            if (!options.getGlobalUids()) {\n                b.append(Events.CALENDAR_ID).append(\"=? AND \");\n                argsList.add(c.getAsString(Events.CALENDAR_ID));\n            }\n            b.append(Events.UID_2445).append(\"=?\");\n            argsList.add(c.getAsString(Events.UID_2445));\n            return queryEvents(resolver, b, argsList);\n        }\n\n        // Without UIDs, the best we can do is check the start date and title within\n        // the current calendar, even though this may return false duplicates.\n        if (!c.containsKey(Events.CALENDAR_ID) || !c.containsKey(Events.DTSTART)) {\n            return null;\n        }\n\n        b.append(Events.CALENDAR_ID).append(\"=? AND \");\n        b.append(Events.DTSTART).append(\"=? AND \");\n        b.append(Events.TITLE);\n\n        argsList.add(c.getAsString(Events.CALENDAR_ID));\n        argsList.add(c.getAsString(Events.DTSTART));\n\n        if (c.containsKey(Events.TITLE)) {\n            b.append(\"=?\");\n            argsList.add(c.getAsString(Events.TITLE));\n        } else {\n            b.append(\" is null\");\n        }\n\n        return queryEvents(resolver, b, argsList);\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func query(resolver: ContentResolver, options: Options, c: ContentValues) -> Cursor? {\n    var b = StringBuilder()\n    var argsList = [String]()\n\n    if options.getKeepUids() && Events.UID_2445 != nil && c.containsKey(Events.UID_2445) {\n        if !options.getGlobalUids() {\n            b.append(\"\\(Events.CALENDAR_ID)=? AND \")\n            argsList.append(c.getAsString(Events.CALENDAR_ID))\n        }\n        b.append(\"\\(Events.UID_2445)=?\")\n        argsList.append(c.getAsString(Events.UID_2445))\n        return queryEvents(resolver: resolver, b: b, argsList: argsList)\n    }\n\n    if !c.containsKey(Events.CALENDAR_ID) || !c.containsKey(Events.DTSTART) {\n        return nil\n    }\n\n    b.append(\"\\(Events.CALENDAR_ID)=? AND \")\n    b.append(\"\\(Events.DTSTART)=? AND \")\n    b.append(Events.TITLE)\n\n    argsList.append(c.getAsString(Events.CALENDAR_ID))\n    argsList.append(c.getAsString(Events.DTSTART))\n\n    if c.containsKey(Events.TITLE) {\n        b.append(\"=?\")\n        argsList.append(c.getAsString(Events.TITLE))\n    } else {\n        b.append(\" is null\")\n    }\n\n    return queryEvents(resolver: resolver, b: b, argsList: argsList)\n}\n```"
    },
    {
        "method_name": "checkTestValue",
        "method_code": "rivate void checkTestValue(VEvent e, ContentValues c, String keyValue, String testName) {\n        String[] parts = keyValue.split(\"=\");\n        String key = parts[0];\n        String expected = parts.length > 1 ? parts[1] : \"\";\n        String got = c.getAsString(key);\n\n        if (\"<non-null>\".equals(expected) && got != null) {\n            got = \"<non-null>\"; // Sentinel for testing present and non-null\n        }\n        if (got == null) {\n            got = \"<null>\"; // Sentinel for testing not present values\n        }\n\n        if (!expected.equals(got)) {\n            Log_OC.e(TAG, \"    \" + keyValue + \" -> FAILED\");\n            Log_OC.e(TAG, \"    values: \" + c);\n            String error = \"Test \" + testName + \" FAILED, expected '\" + keyValue + \"', got '\" + got + \"'\";\n            throw new RuntimeException(error);\n        }\n        Log_OC.i(TAG, \"    \" + keyValue + \" -> PASSED\");\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled checkTestValue from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: checkTestValue\n\n        Method Code: rivate void checkTestValue(VEvent e, ContentValues c, String keyValue, String testName) {\n        String[] parts = keyValue.split(\"=\");\n        String key = parts[0];\n        String expected = parts.length > 1 ? parts[1] : \"\";\n        String got = c.getAsString(key);\n\n        if (\"<non-null>\".equals(expected) && got != null) {\n            got = \"<non-null>\"; // Sentinel for testing present and non-null\n        }\n        if (got == null) {\n            got = \"<null>\"; // Sentinel for testing not present values\n        }\n\n        if (!expected.equals(got)) {\n            Log_OC.e(TAG, \"    \" + keyValue + \" -> FAILED\");\n            Log_OC.e(TAG, \"    values: \" + c);\n            String error = \"Test \" + testName + \" FAILED, expected '\" + keyValue + \"', got '\" + got + \"'\";\n            throw new RuntimeException(error);\n        }\n        Log_OC.i(TAG, \"    \" + keyValue + \" -> PASSED\");\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func checkTestValue(e: VEvent, c: [String: Any], keyValue: String, testName: String) {\n    let parts = keyValue.split(separator: \"=\")\n    let key = String(parts[0])\n    let expected = parts.count > 1 ? String(parts[1]) : \"\"\n    var got = c[key] as? String\n\n    if expected == \"<non-null>\" && got != nil {\n        got = \"<non-null>\" // Sentinel for testing present and non-null\n    }\n    if got == nil {\n        got = \"<null>\" // Sentinel for testing not present values\n    }\n\n    if expected != got {\n        Log_OC.e(TAG, \"    \\(keyValue) -> FAILED\")\n        Log_OC.e(TAG, \"    values: \\(c)\")\n        let error = \"Test \\(testName) FAILED, expected '\\(keyValue)', got '\\(got ?? \"<null>\")'\"\n        fatalError(error)\n    }\n    Log_OC.i(TAG, \"    \\(keyValue) -> PASSED\")\n}\n```"
    },
    {
        "method_name": "processEventTests",
        "method_code": "rivate void processEventTests(VEvent e, ContentValues c, List<Integer> reminders) {\n\n        Property testName = e.getProperty(\"X-TEST-NAME\");\n        if (testName == null) {\n            return; // Not a test case\n        }\n\n        // This is a test event. Verify it using the embedded meta data.\n        Log_OC.i(TAG, \"Processing test case \" + testName.getValue() + \"...\");\n\n        String reminderValues = \"\";\n        String sep = \"\";\n        for (Integer i : reminders) {\n            reminderValues += sep + i;\n            sep = \",\";\n        }\n        c.put(\"reminders\", reminderValues);\n\n        for (Object o : e.getProperties()) {\n            Property p = (Property) o;\n            switch (p.getName()) {\n                case \"X-TEST-VALUE\":\n                    checkTestValue(e, c, p.getValue(), testName.getValue());\n                    break;\n                case \"X-TEST-MIN-VERSION\":\n                    final int ver = Integer.parseInt(p.getValue());\n                    if (android.os.Build.VERSION.SDK_INT < ver) {\n                        Log_OC.e(TAG, \"    -> SKIPPED (MIN-VERSION < \" + ver + \")\");\n                        return;\n                    }\n                    break;\n            }\n        }\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled processEventTests from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: processEventTests\n\n        Method Code: rivate void processEventTests(VEvent e, ContentValues c, List<Integer> reminders) {\n\n        Property testName = e.getProperty(\"X-TEST-NAME\");\n        if (testName == null) {\n            return; // Not a test case\n        }\n\n        // This is a test event. Verify it using the embedded meta data.\n        Log_OC.i(TAG, \"Processing test case \" + testName.getValue() + \"...\");\n\n        String reminderValues = \"\";\n        String sep = \"\";\n        for (Integer i : reminders) {\n            reminderValues += sep + i;\n            sep = \",\";\n        }\n        c.put(\"reminders\", reminderValues);\n\n        for (Object o : e.getProperties()) {\n            Property p = (Property) o;\n            switch (p.getName()) {\n                case \"X-TEST-VALUE\":\n                    checkTestValue(e, c, p.getValue(), testName.getValue());\n                    break;\n                case \"X-TEST-MIN-VERSION\":\n                    final int ver = Integer.parseInt(p.getValue());\n                    if (android.os.Build.VERSION.SDK_INT < ver) {\n                        Log_OC.e(TAG, \"    -> SKIPPED (MIN-VERSION < \" + ver + \")\");\n                        return;\n                    }\n                    break;\n            }\n        }\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func processEventTests(e: VEvent, c: inout [String: Any], reminders: [Int]) {\n    guard let testName = e.getProperty(\"X-TEST-NAME\") else {\n        return // Not a test case\n    }\n\n    // This is a test event. Verify it using the embedded meta data.\n    Log_OC.i(TAG, \"Processing test case \\(testName.getValue())...\")\n\n    var reminderValues = \"\"\n    var sep = \"\"\n    for i in reminders {\n        reminderValues += sep + String(i)\n        sep = \",\"\n    }\n    c[\"reminders\"] = reminderValues\n\n    for o in e.getProperties() {\n        if let p = o as? Property {\n            switch p.getName() {\n            case \"X-TEST-VALUE\":\n                checkTestValue(e: e, c: &c, value: p.getValue(), testName: testName.getValue())\n            case \"X-TEST-MIN-VERSION\":\n                if let ver = Int(p.getValue()), android.os.Build.VERSION.SDK_INT < ver {\n                    Log_OC.e(TAG, \"    -> SKIPPED (MIN-VERSION < \\(ver))\")\n                    return\n                }\n            default:\n                break\n            }\n        }\n    }\n}\n```"
    },
    {
        "method_name": "generateUid",
        "method_code": "rivate String generateUid() {\n        // Generated UIDs take the form <ms>-<uuid>@nextcloud.com.\n        if (mUidTail == null) {\n            String uidPid = preferences.getUidPid();\n            if (uidPid.length() == 0) {\n                uidPid = UUID.randomUUID().toString().replace(\"-\", \"\");\n                preferences.setUidPid(uidPid);\n            }\n            mUidTail = uidPid + \"@nextcloud.com\";\n        }\n\n        mUidMs = Math.max(mUidMs, System.currentTimeMillis());\n        String uid = mUidMs + mUidTail;\n        mUidMs++;\n\n        return uid;\n    }\n",
        "prompt": "\n        Please translate the following Java (Android) method titled generateUid from ProcessVEvent.java into Swift.\n\n        Input:\n\n        Method Name: generateUid\n\n        Method Code: rivate String generateUid() {\n        // Generated UIDs take the form <ms>-<uuid>@nextcloud.com.\n        if (mUidTail == null) {\n            String uidPid = preferences.getUidPid();\n            if (uidPid.length() == 0) {\n                uidPid = UUID.randomUUID().toString().replace(\"-\", \"\");\n                preferences.setUidPid(uidPid);\n            }\n            mUidTail = uidPid + \"@nextcloud.com\";\n        }\n\n        mUidMs = Math.max(mUidMs, System.currentTimeMillis());\n        String uid = mUidMs + mUidTail;\n        mUidMs++;\n\n        return uid;\n    }\n\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func generateUid() -> String {\n    if mUidTail == nil {\n        var uidPid = preferences.getUidPid()\n        if uidPid.isEmpty {\n            uidPid = UUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")\n            preferences.setUidPid(uidPid)\n        }\n        mUidTail = uidPid + \"@nextcloud.com\"\n    }\n\n    mUidMs = max(mUidMs, Date().timeIntervalSince1970 * 1000)\n    let uid = \"\\(Int(mUidMs))\\(mUidTail!)\"\n    mUidMs += 1\n\n    return uid\n}\n```"
    }
]