[
    {
        "method_name": "addColorFilter",
        "method_code": "public static Bitmap addColorFilter(Bitmap originalBitmap, int filterColor, int opacity) {\n        Bitmap resultBitmap = originalBitmap.copy(Bitmap.Config.ARGB_8888, true);\n        Canvas canvas = new Canvas(resultBitmap);\n        canvas.drawBitmap(resultBitmap, 0, 0, null);\n\n        Paint paint = new Paint();\n        paint.setColor(filterColor);\n\n        paint.setAlpha(opacity);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));\n        canvas.drawRect(0, 0, resultBitmap.getWidth(), resultBitmap.getHeight(), paint);\n\n        return resultBitmap;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled addColorFilter from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: addColorFilter\n\n        Method Code: public static Bitmap addColorFilter(Bitmap originalBitmap, int filterColor, int opacity) {\n        Bitmap resultBitmap = originalBitmap.copy(Bitmap.Config.ARGB_8888, true);\n        Canvas canvas = new Canvas(resultBitmap);\n        canvas.drawBitmap(resultBitmap, 0, 0, null);\n\n        Paint paint = new Paint();\n        paint.setColor(filterColor);\n\n        paint.setAlpha(opacity);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));\n        canvas.drawRect(0, 0, resultBitmap.getWidth(), resultBitmap.getHeight(), paint);\n\n        return resultBitmap;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc addColorFilter(originalImage: UIImage, filterColor: UIColor, opacity: CGFloat) -> UIImage? {\n    UIGraphicsBeginImageContextWithOptions(originalImage.size, false, originalImage.scale)\n    guard let context = UIGraphicsGetCurrentContext(), let cgImage = originalImage.cgImage else {\n        return nil\n    }\n    \n    let rect = CGRect(origin: .zero, size: originalImage.size)\n    context.draw(cgImage, in: rect)\n    \n    context.setFillColor(filterColor.withAlphaComponent(opacity).cgColor)\n    context.setBlendMode(.sourceAtop)\n    context.fill(rect)\n    \n    let resultImage = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    return resultImage\n}\n```"
    },
    {
        "method_name": "decodeSampledBitmapFromFile",
        "method_code": "public static Bitmap decodeSampledBitmapFromFile(String srcPath, int reqWidth, int reqHeight) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            // For API 28 and above, use ImageDecoder\n            try {\n                return ImageDecoder.decodeBitmap(ImageDecoder.createSource(new File(srcPath)),\n                                                 (decoder, info, source) -> {\n                                                     // Set the target size\n                                                     decoder.setTargetSize(reqWidth, reqHeight);\n                                                 });\n            } catch (Exception exception) {\n                Log_OC.e(\"BitmapUtil\", \"Error decoding the bitmap from file: \" + srcPath + \", exception: \" + exception.getMessage());\n            }\n        }\n        // set desired options that will affect the size of the bitmap\n        final Options options = new Options();\n\n        // make a false load of the bitmap to get its dimensions\n        options.inJustDecodeBounds = true;\n\n        // FIXME after auto-rename can't generate thumbnail from localPath\n        BitmapFactory.decodeFile(srcPath, options);\n\n        // calculate factor to subsample the bitmap\n        options.inSampleSize = calculateSampleFactor(options, reqWidth, reqHeight);\n\n        // decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(srcPath, options);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled decodeSampledBitmapFromFile from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: decodeSampledBitmapFromFile\n\n        Method Code: public static Bitmap decodeSampledBitmapFromFile(String srcPath, int reqWidth, int reqHeight) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            // For API 28 and above, use ImageDecoder\n            try {\n                return ImageDecoder.decodeBitmap(ImageDecoder.createSource(new File(srcPath)),\n                                                 (decoder, info, source) -> {\n                                                     // Set the target size\n                                                     decoder.setTargetSize(reqWidth, reqHeight);\n                                                 });\n            } catch (Exception exception) {\n                Log_OC.e(\"BitmapUtil\", \"Error decoding the bitmap from file: \" + srcPath + \", exception: \" + exception.getMessage());\n            }\n        }\n        // set desired options that will affect the size of the bitmap\n        final Options options = new Options();\n\n        // make a false load of the bitmap to get its dimensions\n        options.inJustDecodeBounds = true;\n\n        // FIXME after auto-rename can't generate thumbnail from localPath\n        BitmapFactory.decodeFile(srcPath, options);\n\n        // calculate factor to subsample the bitmap\n        options.inSampleSize = calculateSampleFactor(options, reqWidth, reqHeight);\n\n        // decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(srcPath, options);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc decodeSampledBitmapFromFile(srcPath: String, reqWidth: Int, reqHeight: Int) -> UIImage? {\n    if #available(iOS 13.0, *) {\n        // For iOS 13 and above, use ImageDecoder equivalent\n        do {\n            let fileURL = URL(fileURLWithPath: srcPath)\n            let source = CGImageSourceCreateWithURL(fileURL as CFURL, nil)\n            let options: [CFString: Any] = [\n                kCGImageSourceThumbnailMaxPixelSize: max(reqWidth, reqHeight),\n                kCGImageSourceCreateThumbnailFromImageAlways: true\n            ]\n            if let source = source, let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) {\n                return UIImage(cgImage: cgImage)\n            }\n        } catch {\n            print(\"Error decoding the bitmap from file: \\(srcPath), exception: \\(error.localizedDescription)\")\n        }\n    }\n    \n    // set desired options that will affect the size of the bitmap\n    let options = [kCGImageSourceShouldCache: false] as CFDictionary\n    \n    // make a false load of the bitmap to get its dimensions\n    guard let imageSource = CGImageSourceCreateWithURL(URL(fileURLWithPath: srcPath) as CFURL, options) else {\n        return nil\n    }\n    \n    let propertiesOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n    guard let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, propertiesOptions) as? [CFString: Any],\n          let pixelWidth = properties[kCGImagePropertyPixelWidth] as? Int,\n          let pixelHeight = properties[kCGImagePropertyPixelHeight] as? Int else {\n        return nil\n    }\n    \n    // calculate factor to subsample the bitmap\n    let inSampleSize = calculateSampleFactor(pixelWidth: pixelWidth, pixelHeight: pixelHeight, reqWidth: reqWidth, reqHeight: reqHeight)\n    \n    // decode bitmap with inSampleSize set\n    let thumbnailOptions: [CFString: Any] = [\n        kCGImageSourceThumbnailMaxPixelSize: max(reqWidth, reqHeight) / inSampleSize,\n        kCGImageSourceCreateThumbnailFromImageAlways: true\n    ]\n    \n    if let cgImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, thumbnailOptions as CFDictionary) {\n        return UIImage(cgImage: cgImage)\n    }\n    \n    return nil\n}\n\nfunc calculateSampleFactor(pixelWidth: Int, pixelHeight: Int, reqWidth: Int, reqHeight: Int) -> Int {\n    var inSampleSize = 1\n    if pixelHeight > reqHeight || pixelWidth > reqWidth {\n        let halfHeight = pixelHeight / 2\n        let halfWidth = pixelWidth / 2\n        \n        while (halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth {\n            inSampleSize *= 2\n        }\n    }\n    return inSampleSize\n}\n```"
    },
    {
        "method_name": "calculateSampleFactor",
        "method_code": "public static int calculateSampleFactor(Options options, int reqWidth, int reqHeight) {\n\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n\n        if (height > reqHeight || width > reqWidth) {\n            final int halfHeight = height / 2;\n            final int halfWidth = width / 2;\n\n            // calculates the largest inSampleSize value (for smallest sample) that is a power of 2 and keeps both\n            // height and width **larger** than the requested height and width.\n            while ((halfHeight / inSampleSize) > reqHeight || (halfWidth / inSampleSize) > reqWidth) {\n                inSampleSize *= 2;\n            }\n        }\n\n        return inSampleSize;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled calculateSampleFactor from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: calculateSampleFactor\n\n        Method Code: public static int calculateSampleFactor(Options options, int reqWidth, int reqHeight) {\n\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n\n        if (height > reqHeight || width > reqWidth) {\n            final int halfHeight = height / 2;\n            final int halfWidth = width / 2;\n\n            // calculates the largest inSampleSize value (for smallest sample) that is a power of 2 and keeps both\n            // height and width **larger** than the requested height and width.\n            while ((halfHeight / inSampleSize) > reqHeight || (halfWidth / inSampleSize) > reqWidth) {\n                inSampleSize *= 2;\n            }\n        }\n\n        return inSampleSize;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc calculateSampleFactor(options: (outHeight: Int, outWidth: Int), reqWidth: Int, reqHeight: Int) -> Int {\n    let height = options.outHeight\n    let width = options.outWidth\n    var inSampleSize = 1\n\n    if height > reqHeight || width > reqWidth {\n        let halfHeight = height / 2\n        let halfWidth = width / 2\n\n        while (halfHeight / inSampleSize) > reqHeight || (halfWidth / inSampleSize) > reqWidth {\n            inSampleSize *= 2\n        }\n    }\n\n    return inSampleSize\n}\n```"
    },
    {
        "method_name": "scaleBitmap",
        "method_code": "public static Bitmap scaleBitmap(Bitmap bitmap, float px, int width, int height, int max) {\n        float scale = px / max;\n        int w = Math.round(scale * width);\n        int h = Math.round(scale * height);\n        return Bitmap.createScaledBitmap(bitmap, w, h, true);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled scaleBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: scaleBitmap\n\n        Method Code: public static Bitmap scaleBitmap(Bitmap bitmap, float px, int width, int height, int max) {\n        float scale = px / max;\n        int w = Math.round(scale * width);\n        int h = Math.round(scale * height);\n        return Bitmap.createScaledBitmap(bitmap, w, h, true);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc scaleBitmap(bitmap: UIImage, px: CGFloat, width: Int, height: Int, max: Int) -> UIImage? {\n    let scale = px / CGFloat(max)\n    let w = Int(round(scale * CGFloat(width)))\n    let h = Int(round(scale * CGFloat(height)))\n    let size = CGSize(width: w, height: h)\n    \n    UIGraphicsBeginImageContextWithOptions(size, false, 0.0)\n    bitmap.draw(in: CGRect(origin: .zero, size: size))\n    let scaledBitmap = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    return scaledBitmap\n}\n```"
    },
    {
        "method_name": "rotateImage",
        "method_code": "public static Bitmap rotateImage(Bitmap bitmap, String storagePath) {\n        Bitmap resultBitmap = bitmap;\n\n        try {\n            ExifInterface exifInterface = new ExifInterface(storagePath);\n            int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);\n\n            if (orientation != ExifInterface.ORIENTATION_NORMAL) {\n                Matrix matrix = new Matrix();\n                switch (orientation) {\n                    // 2\n                    case ExifInterface.ORIENTATION_FLIP_HORIZONTAL: {\n                        matrix.postScale(-1.0f, 1.0f);\n                        break;\n                    }\n                    // 3\n                    case ExifInterface.ORIENTATION_ROTATE_180: {\n                        matrix.postRotate(180);\n                        break;\n                    }\n                    // 4\n                    case ExifInterface.ORIENTATION_FLIP_VERTICAL: {\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 5\n                    case ExifInterface.ORIENTATION_TRANSPOSE: {\n                        matrix.postRotate(-90);\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 6\n                    case ExifInterface.ORIENTATION_ROTATE_90: {\n                        matrix.postRotate(90);\n                        break;\n                    }\n                    // 7\n                    case ExifInterface.ORIENTATION_TRANSVERSE: {\n                        matrix.postRotate(90);\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 8\n                    case ExifInterface.ORIENTATION_ROTATE_270: {\n                        matrix.postRotate(270);\n                        break;\n                    }\n                }\n\n                // Rotate the bitmap\n                resultBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);\n                if (!resultBitmap.equals(bitmap)) {\n                    bitmap.recycle();\n                }\n            }\n        } catch (Exception exception) {\n            Log_OC.e(\"BitmapUtil\", \"Could not rotate the image: \" + storagePath);\n        }\n        return resultBitmap;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled rotateImage from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: rotateImage\n\n        Method Code: public static Bitmap rotateImage(Bitmap bitmap, String storagePath) {\n        Bitmap resultBitmap = bitmap;\n\n        try {\n            ExifInterface exifInterface = new ExifInterface(storagePath);\n            int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);\n\n            if (orientation != ExifInterface.ORIENTATION_NORMAL) {\n                Matrix matrix = new Matrix();\n                switch (orientation) {\n                    // 2\n                    case ExifInterface.ORIENTATION_FLIP_HORIZONTAL: {\n                        matrix.postScale(-1.0f, 1.0f);\n                        break;\n                    }\n                    // 3\n                    case ExifInterface.ORIENTATION_ROTATE_180: {\n                        matrix.postRotate(180);\n                        break;\n                    }\n                    // 4\n                    case ExifInterface.ORIENTATION_FLIP_VERTICAL: {\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 5\n                    case ExifInterface.ORIENTATION_TRANSPOSE: {\n                        matrix.postRotate(-90);\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 6\n                    case ExifInterface.ORIENTATION_ROTATE_90: {\n                        matrix.postRotate(90);\n                        break;\n                    }\n                    // 7\n                    case ExifInterface.ORIENTATION_TRANSVERSE: {\n                        matrix.postRotate(90);\n                        matrix.postScale(1.0f, -1.0f);\n                        break;\n                    }\n                    // 8\n                    case ExifInterface.ORIENTATION_ROTATE_270: {\n                        matrix.postRotate(270);\n                        break;\n                    }\n                }\n\n                // Rotate the bitmap\n                resultBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);\n                if (!resultBitmap.equals(bitmap)) {\n                    bitmap.recycle();\n                }\n            }\n        } catch (Exception exception) {\n            Log_OC.e(\"BitmapUtil\", \"Could not rotate the image: \" + storagePath);\n        }\n        return resultBitmap;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\nimport ImageIO\n\nfunc rotateImage(_ image: UIImage, storagePath: String) -> UIImage? {\n    guard let imageSource = CGImageSourceCreateWithURL(URL(fileURLWithPath: storagePath) as CFURL, nil),\n          let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],\n          let exifOrientation = imageProperties[kCGImagePropertyOrientation] as? Int else {\n        return image\n    }\n    \n    var transform = CGAffineTransform.identity\n    \n    switch exifOrientation {\n    case 2:\n        transform = transform.scaledBy(x: -1.0, y: 1.0)\n    case 3:\n        transform = transform.rotated(by: .pi)\n    case 4:\n        transform = transform.scaledBy(x: 1.0, y: -1.0)\n    case 5:\n        transform = transform.rotated(by: -.pi / 2).scaledBy(x: 1.0, y: -1.0)\n    case 6:\n        transform = transform.rotated(by: .pi / 2)\n    case 7:\n        transform = transform.rotated(by: .pi / 2).scaledBy(x: 1.0, y: -1.0)\n    case 8:\n        transform = transform.rotated(by: -.pi / 2)\n    default:\n        return image\n    }\n    \n    guard let cgImage = image.cgImage else { return image }\n    let context = CGContext(data: nil, width: cgImage.width, height: cgImage.height, bitsPerComponent: cgImage.bitsPerComponent, bytesPerRow: 0, space: cgImage.colorSpace ?? CGColorSpaceCreateDeviceRGB(), bitmapInfo: cgImage.bitmapInfo.rawValue)\n    \n    context?.concatenate(transform)\n    \n    switch exifOrientation {\n    case 5, 6, 7, 8:\n        context?.draw(cgImage, in: CGRect(x: 0, y: 0, width: cgImage.height, height: cgImage.width))\n    default:\n        context?.draw(cgImage, in: CGRect(x: 0, y: 0, width: cgImage.width, height: cgImage.height))\n    }\n    \n    guard let newCGImage = context?.makeImage() else { return image }\n    return UIImage(cgImage: newCGImage)\n}\n```"
    },
    {
        "method_name": "getImageResolution",
        "method_code": "public static int[] getImageResolution(String srcPath) {\n        Options options = new Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(srcPath, options);\n        return new int [] {options.outWidth, options.outHeight};\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getImageResolution from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: getImageResolution\n\n        Method Code: public static int[] getImageResolution(String srcPath) {\n        Options options = new Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(srcPath, options);\n        return new int [] {options.outWidth, options.outHeight};\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc getImageResolution(srcPath: String) -> [Int] {\n    let imageSource = CGImageSourceCreateWithURL(URL(fileURLWithPath: srcPath) as CFURL, nil)\n    let options: [NSString: Any] = [kCGImageSourceShouldCache: false]\n    if let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource!, 0, options as CFDictionary) as? [CFString: Any],\n       let width = imageProperties[kCGImagePropertyPixelWidth] as? Int,\n       let height = imageProperties[kCGImagePropertyPixelHeight] as? Int {\n        return [width, height]\n    }\n    return [0, 0]\n}\n```"
    },
    {
        "method_name": "usernameToColor",
        "method_code": "public static Color usernameToColor(String name) {\n        String hash = name.toLowerCase(Locale.ROOT);\n\n        // Check if the input is already a valid MD5 hash (32 hex characters)\n        if (hash.length() != 32 || !hash.matches(\"[0-9a-f]+\")) {\n            try {\n                hash = md5(hash);\n            } catch (NoSuchAlgorithmException e) {\n                int color = getResources().getColor(R.color.primary_dark);\n                return new Color(android.graphics.Color.red(color),\n                                 android.graphics.Color.green(color),\n                                 android.graphics.Color.blue(color));\n            }\n        }\n\n        hash = hash.replaceAll(\"[^0-9a-f]\", \"\");\n        int steps = 6;\n\n        Color[] finalPalette = generateColors(steps);\n\n        return finalPalette[hashToInt(hash, steps * 3)];\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled usernameToColor from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: usernameToColor\n\n        Method Code: public static Color usernameToColor(String name) {\n        String hash = name.toLowerCase(Locale.ROOT);\n\n        // Check if the input is already a valid MD5 hash (32 hex characters)\n        if (hash.length() != 32 || !hash.matches(\"[0-9a-f]+\")) {\n            try {\n                hash = md5(hash);\n            } catch (NoSuchAlgorithmException e) {\n                int color = getResources().getColor(R.color.primary_dark);\n                return new Color(android.graphics.Color.red(color),\n                                 android.graphics.Color.green(color),\n                                 android.graphics.Color.blue(color));\n            }\n        }\n\n        hash = hash.replaceAll(\"[^0-9a-f]\", \"\");\n        int steps = 6;\n\n        Color[] finalPalette = generateColors(steps);\n\n        return finalPalette[hashToInt(hash, steps * 3)];\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc usernameToColor(_ name: String) -> UIColor {\n    var hash = name.lowercased()\n\n    // Check if the input is already a valid MD5 hash (32 hex characters)\n    if hash.count != 32 || !hash.range(of: \"^[0-9a-f]+$\", options: .regularExpression) {\n        do {\n            hash = try md5(hash)\n        } catch {\n            let color = UIColor(named: \"primary_dark\") ?? UIColor.black\n            return color\n        }\n    }\n\n    hash = hash.replacingOccurrences(of: \"[^0-9a-f]\", with: \"\", options: .regularExpression)\n    let steps = 6\n\n    let finalPalette = generateColors(steps)\n\n    return finalPalette[hashToInt(hash, steps * 3)]\n}\n\n// Placeholder functions for md5, generateColors, and hashToInt\nfunc md5(_ input: String) throws -> String {\n    // Implement MD5 hashing\n    return \"\"\n}\n\nfunc generateColors(_ steps: Int) -> [UIColor] {\n    // Implement color generation\n    return []\n}\n\nfunc hashToInt(_ hash: String, _ max: Int) -> Int {\n    // Implement hash to integer conversion\n    return 0\n}\n```"
    },
    {
        "method_name": "hashToInt",
        "method_code": "private static int hashToInt(String hash, int maximum) {\n        int finalInt = 0;\n\n        // Sum the values of the hexadecimal digits\n        for (int i = 0; i < hash.length(); i++) {\n            // Efficient hex char-to-int conversion\n            finalInt += Character.digit(hash.charAt(i), 16);\n        }\n\n        // Return the sum modulo maximum\n        return finalInt % maximum;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled hashToInt from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: hashToInt\n\n        Method Code: private static int hashToInt(String hash, int maximum) {\n        int finalInt = 0;\n\n        // Sum the values of the hexadecimal digits\n        for (int i = 0; i < hash.length(); i++) {\n            // Efficient hex char-to-int conversion\n            finalInt += Character.digit(hash.charAt(i), 16);\n        }\n\n        // Return the sum modulo maximum\n        return finalInt % maximum;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func hashToInt(hash: String, maximum: Int) -> Int {\n    var finalInt = 0\n\n    // Sum the values of the hexadecimal digits\n    for char in hash {\n        // Efficient hex char-to-int conversion\n        if let digit = Int(String(char), radix: 16) {\n            finalInt += digit\n        }\n    }\n\n    // Return the sum modulo maximum\n    return finalInt % maximum\n}\n```"
    },
    {
        "method_name": "generateColors",
        "method_code": "private static Color[] generateColors(int steps) {\n        Color red = new Color(182, 70, 157);\n        Color yellow = new Color(221, 203, 85);\n        Color blue = new Color(0, 130, 201); // Nextcloud blue\n\n        Color[] palette1 = mixPalette(steps, red, yellow);\n        Color[] palette2 = mixPalette(steps, yellow, blue);\n        Color[] palette3 = mixPalette(steps, blue, red);\n\n        Color[] resultPalette = new Color[palette1.length + palette2.length + palette3.length];\n        System.arraycopy(palette1, 0, resultPalette, 0, steps);\n        System.arraycopy(palette2, 0, resultPalette, steps, steps);\n        System.arraycopy(palette3, 0, resultPalette, steps * 2, steps);\n\n        return resultPalette;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled generateColors from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: generateColors\n\n        Method Code: private static Color[] generateColors(int steps) {\n        Color red = new Color(182, 70, 157);\n        Color yellow = new Color(221, 203, 85);\n        Color blue = new Color(0, 130, 201); // Nextcloud blue\n\n        Color[] palette1 = mixPalette(steps, red, yellow);\n        Color[] palette2 = mixPalette(steps, yellow, blue);\n        Color[] palette3 = mixPalette(steps, blue, red);\n\n        Color[] resultPalette = new Color[palette1.length + palette2.length + palette3.length];\n        System.arraycopy(palette1, 0, resultPalette, 0, steps);\n        System.arraycopy(palette2, 0, resultPalette, steps, steps);\n        System.arraycopy(palette3, 0, resultPalette, steps * 2, steps);\n\n        return resultPalette;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func generateColors(steps: Int) -> [UIColor] {\n    let red = UIColor(red: 182/255.0, green: 70/255.0, blue: 157/255.0, alpha: 1.0)\n    let yellow = UIColor(red: 221/255.0, green: 203/255.0, blue: 85/255.0, alpha: 1.0)\n    let blue = UIColor(red: 0/255.0, green: 130/255.0, blue: 201/255.0, alpha: 1.0)\n\n    let palette1 = mixPalette(steps: steps, startColor: red, endColor: yellow)\n    let palette2 = mixPalette(steps: steps, startColor: yellow, endColor: blue)\n    let palette3 = mixPalette(steps: steps, startColor: blue, endColor: red)\n\n    var resultPalette = [UIColor]()\n    resultPalette.append(contentsOf: palette1)\n    resultPalette.append(contentsOf: palette2)\n    resultPalette.append(contentsOf: palette3)\n\n    return resultPalette\n}\n```"
    },
    {
        "method_name": "mixPalette",
        "method_code": "@SuppressFBWarnings(\"CLI_CONSTANT_LIST_INDEX\")\n    private static Color[] mixPalette(int steps, Color color1, Color color2) {\n        Color[] palette = new Color[steps];\n        palette[0] = color1;\n\n        float[] step = stepCalc(steps, color1, color2);\n        for (int i = 1; i < steps; i++) {\n            int r = (int) (color1.r + step[0] * i);\n            int g = (int) (color1.g + step[1] * i);\n            int b = (int) (color1.b + step[2] * i);\n\n            palette[i] = new Color(r, g, b);\n        }\n\n        return palette;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled mixPalette from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: mixPalette\n\n        Method Code: @SuppressFBWarnings(\"CLI_CONSTANT_LIST_INDEX\")\n    private static Color[] mixPalette(int steps, Color color1, Color color2) {\n        Color[] palette = new Color[steps];\n        palette[0] = color1;\n\n        float[] step = stepCalc(steps, color1, color2);\n        for (int i = 1; i < steps; i++) {\n            int r = (int) (color1.r + step[0] * i);\n            int g = (int) (color1.g + step[1] * i);\n            int b = (int) (color1.b + step[2] * i);\n\n            palette[i] = new Color(r, g, b);\n        }\n\n        return palette;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func mixPalette(steps: Int, color1: UIColor, color2: UIColor) -> [UIColor] {\n    var palette = [UIColor](repeating: color1, count: steps)\n    palette[0] = color1\n\n    let step = stepCalc(steps: steps, color1: color1, color2: color2)\n    for i in 1..<steps {\n        let r = Int(color1.r + step[0] * CGFloat(i))\n        let g = Int(color1.g + step[1] * CGFloat(i))\n        let b = Int(color1.b + step[2] * CGFloat(i))\n\n        palette[i] = UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: 1.0)\n    }\n\n    return palette\n}\n```"
    },
    {
        "method_name": "stepCalc",
        "method_code": "private static float[] stepCalc(int steps, Color color1, Color color2) {\n        float[] step = new float[3];\n\n        step[0] = (color2.r - color1.r) / (float) steps;\n        step[1] = (color2.g - color1.g) / (float) steps;\n        step[2] = (color2.b - color1.b) / (float) steps;\n\n        return step;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled stepCalc from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: stepCalc\n\n        Method Code: private static float[] stepCalc(int steps, Color color1, Color color2) {\n        float[] step = new float[3];\n\n        step[0] = (color2.r - color1.r) / (float) steps;\n        step[1] = (color2.g - color1.g) / (float) steps;\n        step[2] = (color2.b - color1.b) / (float) steps;\n\n        return step;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func stepCalc(steps: Int, color1: UIColor, color2: UIColor) -> [CGFloat] {\n    var step = [CGFloat](repeating: 0.0, count: 3)\n    \n    var r1: CGFloat = 0, g1: CGFloat = 0, b1: CGFloat = 0, a1: CGFloat = 0\n    var r2: CGFloat = 0, g2: CGFloat = 0, b2: CGFloat = 0, a2: CGFloat = 0\n    \n    color1.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)\n    color2.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)\n    \n    step[0] = (r2 - r1) / CGFloat(steps)\n    step[1] = (g2 - g1) / CGFloat(steps)\n    step[2] = (b2 - b1) / CGFloat(steps)\n    \n    return step\n}\n```"
    },
    {
        "method_name": "equals",
        "method_code": "@Override\n        public boolean equals(@Nullable Object obj) {\n            if (!(obj instanceof Color)) {\n                return false;\n            }\n\n            Color other = (Color) obj;\n            return this.r == other.r && this.g == other.g && this.b == other.b;\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled equals from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: equals\n\n        Method Code: @Override\n        public boolean equals(@Nullable Object obj) {\n            if (!(obj instanceof Color)) {\n                return false;\n            }\n\n            Color other = (Color) obj;\n            return this.r == other.r && this.g == other.g && this.b == other.b;\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func isEqual(_ object: Any?) -> Bool {\n    guard let other = object as? Color else {\n        return false\n    }\n    return self.r == other.r && self.g == other.g && self.b == other.b\n}\n```"
    },
    {
        "method_name": "hashCode",
        "method_code": "@Override\n        public int hashCode() {\n            return (r << 16) + (g << 8) + b;\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled hashCode from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: hashCode\n\n        Method Code: @Override\n        public int hashCode() {\n            return (r << 16) + (g << 8) + b;\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func hashCode() -> Int {\n    return (r << 16) + (g << 8) + b\n}\n```"
    },
    {
        "method_name": "md5",
        "method_code": "public static String md5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        // Use UTF-8 for consistency\n        byte[] hashBytes = md5.digest(string.getBytes(StandardCharsets.UTF_8));\n\n        StringBuilder hexString = new StringBuilder(32);\n        for (byte b : hashBytes) {\n            // Convert each byte to a 2-digit hex string\n            hexString.append(String.format(\"%02x\", b));\n        }\n        return hexString.toString();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled md5 from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: md5\n\n        Method Code: public static String md5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        // Use UTF-8 for consistency\n        byte[] hashBytes = md5.digest(string.getBytes(StandardCharsets.UTF_8));\n\n        StringBuilder hexString = new StringBuilder(32);\n        for (byte b : hashBytes) {\n            // Convert each byte to a 2-digit hex string\n            hexString.append(String.format(\"%02x\", b));\n        }\n        return hexString.toString();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport CommonCrypto\n\nfunc md5(_ string: String) throws -> String {\n    guard let data = string.data(using: .utf8) else {\n        throw NSError(domain: \"Invalid string encoding\", code: 0, userInfo: nil)\n    }\n    \n    var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    data.withUnsafeBytes {\n        _ = CC_MD5($0.baseAddress, CC_LONG(data.count), &hash)\n    }\n    \n    return hash.map { String(format: \"%02x\", $0) }.joined()\n}\n```"
    },
    {
        "method_name": "bitmapToCircularBitmapDrawable",
        "method_code": "@Nullable\n    public static RoundedBitmapDrawable bitmapToCircularBitmapDrawable(Resources resources,\n                                                                       Bitmap bitmap,\n                                                                       float radius) {\n        if (bitmap == null) {\n            return null;\n        }\n\n        RoundedBitmapDrawable roundedBitmap = RoundedBitmapDrawableFactory.create(resources, bitmap);\n        roundedBitmap.setCircular(true);\n\n        if (radius != -1) {\n            roundedBitmap.setCornerRadius(radius);\n        }\n\n        return roundedBitmap;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled bitmapToCircularBitmapDrawable from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: bitmapToCircularBitmapDrawable\n\n        Method Code: @Nullable\n    public static RoundedBitmapDrawable bitmapToCircularBitmapDrawable(Resources resources,\n                                                                       Bitmap bitmap,\n                                                                       float radius) {\n        if (bitmap == null) {\n            return null;\n        }\n\n        RoundedBitmapDrawable roundedBitmap = RoundedBitmapDrawableFactory.create(resources, bitmap);\n        roundedBitmap.setCircular(true);\n\n        if (radius != -1) {\n            roundedBitmap.setCornerRadius(radius);\n        }\n\n        return roundedBitmap;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc bitmapToCircularBitmapDrawable(bitmap: UIImage?, radius: CGFloat) -> UIImage? {\n    guard let bitmap = bitmap else {\n        return nil\n    }\n\n    let size = bitmap.size\n    let rect = CGRect(origin: .zero, size: size)\n\n    UIGraphicsBeginImageContextWithOptions(size, false, bitmap.scale)\n    let context = UIGraphicsGetCurrentContext()\n\n    if radius != -1 {\n        let path = UIBezierPath(roundedRect: rect, cornerRadius: radius)\n        path.addClip()\n    } else {\n        context?.addEllipse(in: rect)\n        context?.clip()\n    }\n\n    bitmap.draw(in: rect)\n    let roundedBitmap = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n\n    return roundedBitmap\n}\n```"
    },
    {
        "method_name": "bitmapToCircularBitmapDrawable",
        "method_code": "@Nullable\n    public static RoundedBitmapDrawable bitmapToCircularBitmapDrawable(Resources resources, Bitmap bitmap) {\n        return bitmapToCircularBitmapDrawable(resources, bitmap, -1);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled bitmapToCircularBitmapDrawable from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: bitmapToCircularBitmapDrawable\n\n        Method Code: @Nullable\n    public static RoundedBitmapDrawable bitmapToCircularBitmapDrawable(Resources resources, Bitmap bitmap) {\n        return bitmapToCircularBitmapDrawable(resources, bitmap, -1);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc bitmapToCircularBitmapDrawable(resources: Resources, bitmap: UIImage?) -> UIImage? {\n    return bitmapToCircularBitmapDrawable(resources: resources, bitmap: bitmap, borderWidth: -1)\n}\n```"
    },
    {
        "method_name": "setRoundedBitmap",
        "method_code": "public static void setRoundedBitmap(Resources resources, Bitmap bitmap, float radius, ImageView imageView) {\n\n        imageView.setImageDrawable(BitmapUtils.bitmapToCircularBitmapDrawable(resources,\n                                                                              bitmap,\n                                                                              radius));\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled setRoundedBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: setRoundedBitmap\n\n        Method Code: public static void setRoundedBitmap(Resources resources, Bitmap bitmap, float radius, ImageView imageView) {\n\n        imageView.setImageDrawable(BitmapUtils.bitmapToCircularBitmapDrawable(resources,\n                                                                              bitmap,\n                                                                              radius));\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func setRoundedBitmap(resources: Resources, bitmap: Bitmap, radius: Float, imageView: UIImageView) {\n    imageView.image = BitmapUtils.bitmapToCircularBitmapDrawable(resources: resources, bitmap: bitmap, radius: radius)\n}\n```"
    },
    {
        "method_name": "drawableToBitmap",
        "method_code": "public static Bitmap drawableToBitmap(Drawable drawable) {\n        return drawableToBitmap(drawable, -1, -1);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled drawableToBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: drawableToBitmap\n\n        Method Code: public static Bitmap drawableToBitmap(Drawable drawable) {\n        return drawableToBitmap(drawable, -1, -1);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func drawableToBitmap(drawable: Drawable) -> Bitmap {\n    return drawableToBitmap(drawable: drawable, width: -1, height: -1)\n}\n```"
    },
    {
        "method_name": "drawableToBitmap",
        "method_code": "@NonNull\n    public static Bitmap drawableToBitmap(Drawable drawable, int desiredWidth, int desiredHeight) {\n        if (drawable instanceof BitmapDrawable) {\n            BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;\n            if (bitmapDrawable.getBitmap() != null) {\n                return bitmapDrawable.getBitmap();\n            }\n        }\n\n        Bitmap bitmap;\n        int width;\n        int height;\n\n        if (desiredWidth > 0 && desiredHeight > 0) {\n            width = desiredWidth;\n            height = desiredHeight;\n        } else {\n            if (drawable.getIntrinsicWidth() <= 0 || drawable.getIntrinsicHeight() <= 0) {\n                if (drawable.getBounds().width() > 0 && drawable.getBounds().height() > 0) {\n                    width = drawable.getBounds().width();\n                    height = drawable.getBounds().height();\n                } else {\n                    width = 1;\n                    height = 1;\n                }\n            } else {\n                width = drawable.getIntrinsicWidth();\n                height = drawable.getIntrinsicHeight();\n            }\n        }\n\n        bitmap = Bitmap.createBitmap(width,\n                                     height,\n                                     Bitmap.Config.ARGB_8888);\n\n        Canvas canvas = new Canvas(bitmap);\n        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n        drawable.draw(canvas);\n        return bitmap;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled drawableToBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: drawableToBitmap\n\n        Method Code: @NonNull\n    public static Bitmap drawableToBitmap(Drawable drawable, int desiredWidth, int desiredHeight) {\n        if (drawable instanceof BitmapDrawable) {\n            BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;\n            if (bitmapDrawable.getBitmap() != null) {\n                return bitmapDrawable.getBitmap();\n            }\n        }\n\n        Bitmap bitmap;\n        int width;\n        int height;\n\n        if (desiredWidth > 0 && desiredHeight > 0) {\n            width = desiredWidth;\n            height = desiredHeight;\n        } else {\n            if (drawable.getIntrinsicWidth() <= 0 || drawable.getIntrinsicHeight() <= 0) {\n                if (drawable.getBounds().width() > 0 && drawable.getBounds().height() > 0) {\n                    width = drawable.getBounds().width();\n                    height = drawable.getBounds().height();\n                } else {\n                    width = 1;\n                    height = 1;\n                }\n            } else {\n                width = drawable.getIntrinsicWidth();\n                height = drawable.getIntrinsicHeight();\n            }\n        }\n\n        bitmap = Bitmap.createBitmap(width,\n                                     height,\n                                     Bitmap.Config.ARGB_8888);\n\n        Canvas canvas = new Canvas(bitmap);\n        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n        drawable.draw(canvas);\n        return bitmap;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc drawableToBitmap(drawable: Drawable, desiredWidth: Int, desiredHeight: Int) -> UIImage {\n    if let bitmapDrawable = drawable as? BitmapDrawable, let bitmap = bitmapDrawable.bitmap {\n        return bitmap\n    }\n\n    var width: Int\n    var height: Int\n\n    if desiredWidth > 0 && desiredHeight > 0 {\n        width = desiredWidth\n        height = desiredHeight\n    } else {\n        if drawable.intrinsicWidth <= 0 || drawable.intrinsicHeight <= 0 {\n            if drawable.bounds.width > 0 && drawable.bounds.height > 0 {\n                width = Int(drawable.bounds.width)\n                height = Int(drawable.bounds.height)\n            } else {\n                width = 1\n                height = 1\n            }\n        } else {\n            width = drawable.intrinsicWidth\n            height = drawable.intrinsicHeight\n        }\n    }\n\n    UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: height), false, 0.0)\n    guard let context = UIGraphicsGetCurrentContext() else {\n        return UIImage()\n    }\n    drawable.draw(in: CGRect(x: 0, y: 0, width: width, height: height))\n    let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage()\n    UIGraphicsEndImageContext()\n    return image\n}\n```"
    },
    {
        "method_name": "setRoundedBitmap",
        "method_code": "public static void setRoundedBitmap(Bitmap thumbnail, ImageView imageView) {\n        BitmapUtils.setRoundedBitmap(getResources(),\n                                     thumbnail,\n                                     getResources().getDimension(R.dimen.file_icon_rounded_corner_radius),\n                                     imageView);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled setRoundedBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: setRoundedBitmap\n\n        Method Code: public static void setRoundedBitmap(Bitmap thumbnail, ImageView imageView) {\n        BitmapUtils.setRoundedBitmap(getResources(),\n                                     thumbnail,\n                                     getResources().getDimension(R.dimen.file_icon_rounded_corner_radius),\n                                     imageView);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func setRoundedBitmap(thumbnail: UIImage, imageView: UIImageView) {\n    BitmapUtils.setRoundedBitmap(\n        resources: getResources(),\n        thumbnail: thumbnail,\n        cornerRadius: getResources().getDimension(R.dimen.file_icon_rounded_corner_radius),\n        imageView: imageView\n    )\n}\n```"
    },
    {
        "method_name": "setRoundedBitmapForGridMode",
        "method_code": "public static void setRoundedBitmapForGridMode(Bitmap thumbnail, ImageView imageView) {\n        BitmapUtils.setRoundedBitmap(getResources(),\n                                     thumbnail,\n                                     getResources().getDimension(R.dimen.file_icon_rounded_corner_radius_for_grid_mode),\n                                     imageView);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled setRoundedBitmapForGridMode from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: setRoundedBitmapForGridMode\n\n        Method Code: public static void setRoundedBitmapForGridMode(Bitmap thumbnail, ImageView imageView) {\n        BitmapUtils.setRoundedBitmap(getResources(),\n                                     thumbnail,\n                                     getResources().getDimension(R.dimen.file_icon_rounded_corner_radius_for_grid_mode),\n                                     imageView);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func setRoundedBitmapForGridMode(thumbnail: UIImage, imageView: UIImageView) {\n    BitmapUtils.setRoundedBitmap(\n        resources: getResources(),\n        thumbnail: thumbnail,\n        cornerRadius: getResources().getDimension(R.dimen.file_icon_rounded_corner_radius_for_grid_mode),\n        imageView: imageView\n    )\n}\n```"
    },
    {
        "method_name": "createAvatarWithStatus",
        "method_code": "public static Bitmap createAvatarWithStatus(Bitmap avatar, StatusType statusType, @NonNull String icon, Context context) {\n        float avatarRadius = getResources().getDimension(R.dimen.list_item_avatar_icon_radius);\n        int width = DisplayUtils.convertDpToPixel(2 * avatarRadius, context);\n\n        Bitmap output = Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(output);\n\n        // avatar\n        Bitmap croppedBitmap = getCroppedBitmap(avatar, width);\n\n        canvas.drawBitmap(croppedBitmap, 0f, 0f, null);\n\n        // status\n        int statusSize = width / 4;\n\n        Status status = new Status(statusType, \"\", icon, -1);\n        StatusDrawable statusDrawable = new StatusDrawable(status, statusSize, context);\n\n        canvas.translate(width / 2f, width / 2f);\n        statusDrawable.draw(canvas);\n\n        return output;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createAvatarWithStatus from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: createAvatarWithStatus\n\n        Method Code: public static Bitmap createAvatarWithStatus(Bitmap avatar, StatusType statusType, @NonNull String icon, Context context) {\n        float avatarRadius = getResources().getDimension(R.dimen.list_item_avatar_icon_radius);\n        int width = DisplayUtils.convertDpToPixel(2 * avatarRadius, context);\n\n        Bitmap output = Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(output);\n\n        // avatar\n        Bitmap croppedBitmap = getCroppedBitmap(avatar, width);\n\n        canvas.drawBitmap(croppedBitmap, 0f, 0f, null);\n\n        // status\n        int statusSize = width / 4;\n\n        Status status = new Status(statusType, \"\", icon, -1);\n        StatusDrawable statusDrawable = new StatusDrawable(status, statusSize, context);\n\n        canvas.translate(width / 2f, width / 2f);\n        statusDrawable.draw(canvas);\n\n        return output;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc createAvatarWithStatus(avatar: UIImage, statusType: StatusType, icon: String, context: UIViewController) -> UIImage? {\n    let avatarRadius = context.view.bounds.width / 2 // Assuming a method to get dimension\n    let width = Int(2 * avatarRadius)\n\n    UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: width), false, 0.0)\n    guard let context = UIGraphicsGetCurrentContext() else { return nil }\n\n    // avatar\n    let croppedBitmap = getCroppedBitmap(avatar: avatar, width: width)\n    croppedBitmap.draw(in: CGRect(x: 0, y: 0, width: width, height: width))\n\n    // status\n    let statusSize = width / 4\n\n    let status = Status(type: statusType, text: \"\", icon: icon, id: -1)\n    let statusDrawable = StatusDrawable(status: status, size: statusSize, context: context)\n\n    context.translateBy(x: CGFloat(width) / 2, y: CGFloat(width) / 2)\n    statusDrawable.draw(in: context)\n\n    let output = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n\n    return output\n}\n```"
    },
    {
        "method_name": "roundBitmap",
        "method_code": "public static Bitmap roundBitmap(Bitmap bitmap) {\n        Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);\n\n        final Canvas canvas = new Canvas(output);\n\n        final int color = R.color.white;\n        final Paint paint = new Paint();\n        final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());\n        final RectF rectF = new RectF(rect);\n\n        paint.setAntiAlias(true);\n        canvas.drawARGB(0, 0, 0, 0);\n        paint.setColor(getResources().getColor(color, null));\n        canvas.drawOval(rectF, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        canvas.drawBitmap(bitmap, rect, rect, paint);\n\n        return output;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled roundBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: roundBitmap\n\n        Method Code: public static Bitmap roundBitmap(Bitmap bitmap) {\n        Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);\n\n        final Canvas canvas = new Canvas(output);\n\n        final int color = R.color.white;\n        final Paint paint = new Paint();\n        final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());\n        final RectF rectF = new RectF(rect);\n\n        paint.setAntiAlias(true);\n        canvas.drawARGB(0, 0, 0, 0);\n        paint.setColor(getResources().getColor(color, null));\n        canvas.drawOval(rectF, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        canvas.drawBitmap(bitmap, rect, rect, paint);\n\n        return output;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc roundBitmap(_ bitmap: UIImage) -> UIImage? {\n    let size = bitmap.size\n    UIGraphicsBeginImageContextWithOptions(size, false, 0.0)\n    guard let context = UIGraphicsGetCurrentContext() else { return nil }\n    \n    let rect = CGRect(origin: .zero, size: size)\n    let rectF = CGRect(origin: .zero, size: size)\n    \n    context.setFillColor(UIColor.white.cgColor)\n    context.fill(rect)\n    \n    context.addEllipse(in: rectF)\n    context.clip()\n    \n    bitmap.draw(in: rect)\n    \n    let output = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    return output\n}\n```"
    },
    {
        "method_name": "tintImage",
        "method_code": "public static Bitmap tintImage(Bitmap bitmap, int color) {\n        Paint paint = new Paint();\n        paint.setColorFilter(new PorterDuffColorFilter(color, PorterDuff.Mode.SRC_IN));\n        Bitmap bitmapResult = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmapResult);\n        canvas.drawBitmap(bitmap, 0, 0, paint);\n        return bitmapResult;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled tintImage from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: tintImage\n\n        Method Code: public static Bitmap tintImage(Bitmap bitmap, int color) {\n        Paint paint = new Paint();\n        paint.setColorFilter(new PorterDuffColorFilter(color, PorterDuff.Mode.SRC_IN));\n        Bitmap bitmapResult = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmapResult);\n        canvas.drawBitmap(bitmap, 0, 0, paint);\n        return bitmapResult;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc tintImage(bitmap: UIImage, color: UIColor) -> UIImage? {\n    UIGraphicsBeginImageContextWithOptions(bitmap.size, false, bitmap.scale)\n    guard let context = UIGraphicsGetCurrentContext() else { return nil }\n    \n    context.translateBy(x: 0, y: bitmap.size.height)\n    context.scaleBy(x: 1.0, y: -1.0)\n    context.setBlendMode(.normal)\n    \n    let rect = CGRect(x: 0, y: 0, width: bitmap.size.width, height: bitmap.size.height)\n    context.clip(to: rect, mask: bitmap.cgImage!)\n    color.setFill()\n    context.fill(rect)\n    \n    let tintedImage = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    return tintedImage\n}\n```"
    },
    {
        "method_name": "getCroppedBitmap",
        "method_code": "private static Bitmap getCroppedBitmap(Bitmap bitmap, int width) {\n        Bitmap output = Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(output);\n        int color = -0xbdbdbe;\n        Paint paint = new Paint();\n        Rect rect = new Rect(0, 0, width, width);\n        paint.setAntiAlias(true);\n        canvas.drawARGB(0, 0, 0, 0);\n        paint.setColor(color);\n\n        canvas.drawCircle(width / 2f, width / 2f, width / 2f, paint);\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n\n        canvas.drawBitmap(Bitmap.createScaledBitmap(bitmap, width, width, false), rect, rect, paint);\n\n        return output;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getCroppedBitmap from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: getCroppedBitmap\n\n        Method Code: private static Bitmap getCroppedBitmap(Bitmap bitmap, int width) {\n        Bitmap output = Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(output);\n        int color = -0xbdbdbe;\n        Paint paint = new Paint();\n        Rect rect = new Rect(0, 0, width, width);\n        paint.setAntiAlias(true);\n        canvas.drawARGB(0, 0, 0, 0);\n        paint.setColor(color);\n\n        canvas.drawCircle(width / 2f, width / 2f, width / 2f, paint);\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n\n        canvas.drawBitmap(Bitmap.createScaledBitmap(bitmap, width, width, false), rect, rect, paint);\n\n        return output;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getCroppedBitmap(bitmap: UIImage, width: Int) -> UIImage? {\n    UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: width), false, 0.0)\n    guard let context = UIGraphicsGetCurrentContext() else { return nil }\n    \n    let color = UIColor(red: 0.2627, green: 0.2627, blue: 0.2627, alpha: 1.0)\n    let rect = CGRect(x: 0, y: 0, width: width, height: width)\n    \n    context.setFillColor(UIColor.clear.cgColor)\n    context.fill(rect)\n    \n    context.setFillColor(color.cgColor)\n    context.setBlendMode(.copy)\n    \n    context.addEllipse(in: rect)\n    context.clip()\n    \n    let scaledBitmap = bitmap.resized(to: CGSize(width: width, height: width))\n    scaledBitmap.draw(in: rect)\n    \n    let output = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    return output\n}\n\nextension UIImage {\n    func resized(to size: CGSize) -> UIImage {\n        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)\n        self.draw(in: CGRect(origin: .zero, size: size))\n        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()\n        UIGraphicsEndImageContext()\n        return resizedImage ?? self\n    }\n}\n```"
    },
    {
        "method_name": "getResources",
        "method_code": "private static Resources getResources() {\n        return MainApp.getAppContext().getResources();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getResources from BitmapUtils.java into Swift.\n\n        Input:\n\n        Method Name: getResources\n\n        Method Code: private static Resources getResources() {\n        return MainApp.getAppContext().getResources();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func getResources() -> Resources {\n    return MainApp.getAppContext().resources\n}\n```"
    }
]