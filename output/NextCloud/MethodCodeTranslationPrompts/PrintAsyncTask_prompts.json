[
    {
        "method_name": "onPreExecute",
        "method_code": "@Override\n    protected void onPreExecute() {\n        richDocumentsWebViewWeakReference.get().runOnUiThread(\n            () -> richDocumentsWebViewWeakReference.get().showLoadingDialog(\n                richDocumentsWebViewWeakReference.get().getString(R.string.common_loading)));\n\n        super.onPreExecute();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onPreExecute from PrintAsyncTask.java into Swift.\n\n        Input:\n\n        Method Name: onPreExecute\n\n        Method Code: @Override\n    protected void onPreExecute() {\n        richDocumentsWebViewWeakReference.get().runOnUiThread(\n            () -> richDocumentsWebViewWeakReference.get().showLoadingDialog(\n                richDocumentsWebViewWeakReference.get().getString(R.string.common_loading)));\n\n        super.onPreExecute();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onPreExecute() {\n    DispatchQueue.main.async {\n        richDocumentsWebViewWeakReference.get()?.showLoadingDialog(\n            richDocumentsWebViewWeakReference.get()?.getString(R.string.common_loading) ?? \"\")\n    }\n    super.onPreExecute()\n}\n```"
    },
    {
        "method_name": "doInBackground",
        "method_code": "@Override\n    protected Boolean doInBackground(Void... voids) {\n        HttpClient client = new HttpClient();\n        GetMethod getMethod = null;\n\n        FileOutputStream fos = null;\n        try {\n            getMethod = new GetMethod(url);\n            int status = client.executeMethod(getMethod);\n            if (status == HttpStatus.SC_OK) {\n                if (file.exists() && !file.delete()) {\n                    return Boolean.FALSE;\n                }\n\n                file.getParentFile().mkdirs();\n\n                if (!file.getParentFile().exists()) {\n                    Log_OC.d(TAG, file.getParentFile().getAbsolutePath() + \" does not exist\");\n                    return Boolean.FALSE;\n                }\n\n                if (!file.createNewFile()) {\n                    Log_OC.d(TAG, file.getAbsolutePath() + \" could not be created\");\n                    return Boolean.FALSE;\n                }\n\n                BufferedInputStream bis = new BufferedInputStream(getMethod.getResponseBodyAsStream());\n                fos = new FileOutputStream(file);\n                long transferred = 0;\n\n                Header contentLength = getMethod.getResponseHeader(\"Content-Length\");\n                long totalToTransfer = contentLength != null && contentLength.getValue().length() > 0 ?\n                    Long.parseLong(contentLength.getValue()) : 0;\n\n                byte[] bytes = new byte[4096];\n                int readResult;\n                while ((readResult = bis.read(bytes)) != -1) {\n                    fos.write(bytes, 0, readResult);\n                    transferred += readResult;\n                }\n                // Check if the file is completed\n                if (transferred != totalToTransfer) {\n                    return Boolean.FALSE;\n                }\n\n                if (getMethod.getResponseBodyAsStream() != null) {\n                    getMethod.getResponseBodyAsStream().close();\n                }\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Error reading file\", e);\n        } finally {\n            if (getMethod != null) {\n                getMethod.releaseConnection();\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, \"Error closing file output stream\", e);\n                }\n            }\n        }\n\n        return Boolean.TRUE;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled doInBackground from PrintAsyncTask.java into Swift.\n\n        Input:\n\n        Method Name: doInBackground\n\n        Method Code: @Override\n    protected Boolean doInBackground(Void... voids) {\n        HttpClient client = new HttpClient();\n        GetMethod getMethod = null;\n\n        FileOutputStream fos = null;\n        try {\n            getMethod = new GetMethod(url);\n            int status = client.executeMethod(getMethod);\n            if (status == HttpStatus.SC_OK) {\n                if (file.exists() && !file.delete()) {\n                    return Boolean.FALSE;\n                }\n\n                file.getParentFile().mkdirs();\n\n                if (!file.getParentFile().exists()) {\n                    Log_OC.d(TAG, file.getParentFile().getAbsolutePath() + \" does not exist\");\n                    return Boolean.FALSE;\n                }\n\n                if (!file.createNewFile()) {\n                    Log_OC.d(TAG, file.getAbsolutePath() + \" could not be created\");\n                    return Boolean.FALSE;\n                }\n\n                BufferedInputStream bis = new BufferedInputStream(getMethod.getResponseBodyAsStream());\n                fos = new FileOutputStream(file);\n                long transferred = 0;\n\n                Header contentLength = getMethod.getResponseHeader(\"Content-Length\");\n                long totalToTransfer = contentLength != null && contentLength.getValue().length() > 0 ?\n                    Long.parseLong(contentLength.getValue()) : 0;\n\n                byte[] bytes = new byte[4096];\n                int readResult;\n                while ((readResult = bis.read(bytes)) != -1) {\n                    fos.write(bytes, 0, readResult);\n                    transferred += readResult;\n                }\n                // Check if the file is completed\n                if (transferred != totalToTransfer) {\n                    return Boolean.FALSE;\n                }\n\n                if (getMethod.getResponseBodyAsStream() != null) {\n                    getMethod.getResponseBodyAsStream().close();\n                }\n            }\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Error reading file\", e);\n        } finally {\n            if (getMethod != null) {\n                getMethod.releaseConnection();\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    Log_OC.e(TAG, \"Error closing file output stream\", e);\n                }\n            }\n        }\n\n        return Boolean.TRUE;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc doInBackground() -> Bool {\n    let client = HttpClient()\n    var getMethod: GetMethod? = nil\n    var fos: FileOutputStream? = nil\n\n    do {\n        getMethod = GetMethod(url: url)\n        let status = try client.executeMethod(getMethod!)\n        if status == HttpStatus.SC_OK {\n            if file.exists() && !file.delete() {\n                return false\n            }\n\n            file.getParentFile().mkdirs()\n\n            if !file.getParentFile().exists() {\n                Log_OC.d(TAG, \"\\(file.getParentFile().getAbsolutePath()) does not exist\")\n                return false\n            }\n\n            if !file.createNewFile() {\n                Log_OC.d(TAG, \"\\(file.getAbsolutePath()) could not be created\")\n                return false\n            }\n\n            let bis = BufferedInputStream(inputStream: getMethod!.getResponseBodyAsStream())\n            fos = FileOutputStream(file: file)\n            var transferred: Int64 = 0\n\n            let contentLength = getMethod!.getResponseHeader(\"Content-Length\")\n            let totalToTransfer: Int64 = contentLength != nil && !contentLength!.getValue().isEmpty ?\n                Int64(contentLength!.getValue()) ?? 0 : 0\n\n            var bytes = [UInt8](repeating: 0, count: 4096)\n            var readResult: Int\n            while (readResult = bis.read(&bytes)) != -1 {\n                fos!.write(bytes, 0, readResult)\n                transferred += Int64(readResult)\n            }\n            // Check if the file is completed\n            if transferred != totalToTransfer {\n                return false\n            }\n\n            if getMethod!.getResponseBodyAsStream() != nil {\n                getMethod!.getResponseBodyAsStream().close()\n            }\n        }\n    } catch {\n        Log_OC.e(TAG, \"Error reading file\", error)\n    } finally {\n        if getMethod != nil {\n            getMethod!.releaseConnection()\n        }\n        if fos != nil {\n            do {\n                try fos!.close()\n            } catch {\n                Log_OC.e(TAG, \"Error closing file output stream\", error)\n            }\n        }\n    }\n\n    return true\n}\n```"
    },
    {
        "method_name": "onPostExecute",
        "method_code": "@Override\n    protected void onPostExecute(Boolean result) {\n        RichDocumentsEditorWebView richDocumentsWebView = richDocumentsWebViewWeakReference.get();\n        richDocumentsWebView.dismissLoadingDialog();\n\n        PrintManager printManager = (PrintManager) richDocumentsWebView.getSystemService(PRINT_SERVICE);\n\n        if (!result || printManager == null) {\n            DisplayUtils.showSnackMessage(richDocumentsWebView,\n                                          richDocumentsWebView.getString(R.string.failed_to_print));\n\n            return;\n        }\n\n        PrintDocumentAdapter printAdapter = new PrintAdapter(file.getAbsolutePath());\n\n        printManager.print(JOB_NAME, printAdapter, new PrintAttributes.Builder().build());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onPostExecute from PrintAsyncTask.java into Swift.\n\n        Input:\n\n        Method Name: onPostExecute\n\n        Method Code: @Override\n    protected void onPostExecute(Boolean result) {\n        RichDocumentsEditorWebView richDocumentsWebView = richDocumentsWebViewWeakReference.get();\n        richDocumentsWebView.dismissLoadingDialog();\n\n        PrintManager printManager = (PrintManager) richDocumentsWebView.getSystemService(PRINT_SERVICE);\n\n        if (!result || printManager == null) {\n            DisplayUtils.showSnackMessage(richDocumentsWebView,\n                                          richDocumentsWebView.getString(R.string.failed_to_print));\n\n            return;\n        }\n\n        PrintDocumentAdapter printAdapter = new PrintAdapter(file.getAbsolutePath());\n\n        printManager.print(JOB_NAME, printAdapter, new PrintAttributes.Builder().build());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onPostExecute(_ result: Bool) {\n    guard let richDocumentsWebView = richDocumentsWebViewWeakReference.get() else { return }\n    richDocumentsWebView.dismissLoadingDialog()\n\n    guard let printManager = richDocumentsWebView.getSystemService(PRINT_SERVICE) as? PrintManager else {\n        DisplayUtils.showSnackMessage(richDocumentsWebView, richDocumentsWebView.getString(R.string.failed_to_print))\n        return\n    }\n\n    let printAdapter = PrintAdapter(file.absolutePath)\n    printManager.print(JOB_NAME, adapter: printAdapter, attributes: PrintAttributes.Builder().build())\n}\n```"
    }
]