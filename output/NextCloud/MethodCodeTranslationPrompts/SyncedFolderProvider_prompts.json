[
    {
        "method_name": "storeSyncedFolder",
        "method_code": "public long storeSyncedFolder(SyncedFolder syncedFolder) {\n        Log_OC.v(TAG, \"Inserting \" + syncedFolder.getLocalPath() + \" with enabled=\" + syncedFolder.isEnabled());\n\n        ContentValues cv = createContentValuesFromSyncedFolder(syncedFolder);\n\n        Uri result = mContentResolver.insert(ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS, cv);\n\n        if (result != null) {\n            return Long.parseLong(result.getPathSegments().get(1));\n        } else {\n            Log_OC.e(TAG, \"Failed to insert item \" + syncedFolder.getLocalPath() + \" into folder sync db.\");\n            return -1;\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled storeSyncedFolder from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: storeSyncedFolder\n\n        Method Code: public long storeSyncedFolder(SyncedFolder syncedFolder) {\n        Log_OC.v(TAG, \"Inserting \" + syncedFolder.getLocalPath() + \" with enabled=\" + syncedFolder.isEnabled());\n\n        ContentValues cv = createContentValuesFromSyncedFolder(syncedFolder);\n\n        Uri result = mContentResolver.insert(ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS, cv);\n\n        if (result != null) {\n            return Long.parseLong(result.getPathSegments().get(1));\n        } else {\n            Log_OC.e(TAG, \"Failed to insert item \" + syncedFolder.getLocalPath() + \" into folder sync db.\");\n            return -1;\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc storeSyncedFolder(_ syncedFolder: SyncedFolder) -> Int64 {\n    Log_OC.v(TAG, \"Inserting \\(syncedFolder.getLocalPath()) with enabled=\\(syncedFolder.isEnabled())\")\n\n    let cv = createContentValuesFromSyncedFolder(syncedFolder)\n\n    if let result = mContentResolver.insert(ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS, cv) {\n        return Int64(result.pathComponents[1]) ?? -1\n    } else {\n        Log_OC.e(TAG, \"Failed to insert item \\(syncedFolder.getLocalPath()) into folder sync db.\")\n        return -1\n    }\n}\n```"
    },
    {
        "method_name": "isAutoUploadFolder",
        "method_code": "public static boolean isAutoUploadFolder(SyncedFolderProvider syncedFolderProvider, ServerFileInterface file, User user) {\n        return syncedFolderProvider != null && syncedFolderProvider.findByRemotePathAndAccount(file.getRemotePath(), user);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isAutoUploadFolder from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: isAutoUploadFolder\n\n        Method Code: public static boolean isAutoUploadFolder(SyncedFolderProvider syncedFolderProvider, ServerFileInterface file, User user) {\n        return syncedFolderProvider != null && syncedFolderProvider.findByRemotePathAndAccount(file.getRemotePath(), user);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\npublic static func isAutoUploadFolder(syncedFolderProvider: SyncedFolderProvider?, file: ServerFileInterface, user: User) -> Bool {\n    return syncedFolderProvider != nil && syncedFolderProvider!.findByRemotePathAndAccount(remotePath: file.getRemotePath(), user: user)\n}\n```"
    },
    {
        "method_name": "countEnabledSyncedFolders",
        "method_code": "public int countEnabledSyncedFolders() {\n        int count = 0;\n        Cursor cursor = mContentResolver.query(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                null,\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED + \" = ?\",\n                new String[]{\"1\"},\n                null\n        );\n\n        if (cursor != null) {\n             count = cursor.getCount();\n             cursor.close();\n        }\n\n        return count;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled countEnabledSyncedFolders from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: countEnabledSyncedFolders\n\n        Method Code: public int countEnabledSyncedFolders() {\n        int count = 0;\n        Cursor cursor = mContentResolver.query(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                null,\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED + \" = ?\",\n                new String[]{\"1\"},\n                null\n        );\n\n        if (cursor != null) {\n             count = cursor.getCount();\n             cursor.close();\n        }\n\n        return count;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc countEnabledSyncedFolders() -> Int {\n    var count = 0\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED) = ?\"\n    let selectionArgs = [\"1\"]\n    \n    if let cursor = mContentResolver.query(contentUri, null, selection, selectionArgs, null) {\n        count = cursor.count\n        cursor.close()\n    }\n    \n    return count\n}\n```"
    },
    {
        "method_name": "getSyncedFolders",
        "method_code": "public List<SyncedFolder> getSyncedFolders() {\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            null,\n            null,\n            null\n                                              );\n\n        if (cursor != null) {\n            List<SyncedFolder> list = new ArrayList<>(cursor.getCount());\n            if (cursor.moveToFirst()) {\n                do {\n                    SyncedFolder syncedFolder = createSyncedFolderFromCursor(cursor);\n                    if (syncedFolder == null) {\n                        Log_OC.e(TAG, \"SyncedFolder could not be created from cursor\");\n                    } else {\n                        list.add(cursor.getPosition(), syncedFolder);\n                    }\n                } while (cursor.moveToNext());\n\n            }\n            cursor.close();\n            return list;\n        } else {\n            Log_OC.e(TAG, \"DB error creating read all cursor for synced folders.\");\n        }\n\n        return new ArrayList<>(0);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getSyncedFolders from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: getSyncedFolders\n\n        Method Code: public List<SyncedFolder> getSyncedFolders() {\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            null,\n            null,\n            null\n                                              );\n\n        if (cursor != null) {\n            List<SyncedFolder> list = new ArrayList<>(cursor.getCount());\n            if (cursor.moveToFirst()) {\n                do {\n                    SyncedFolder syncedFolder = createSyncedFolderFromCursor(cursor);\n                    if (syncedFolder == null) {\n                        Log_OC.e(TAG, \"SyncedFolder could not be created from cursor\");\n                    } else {\n                        list.add(cursor.getPosition(), syncedFolder);\n                    }\n                } while (cursor.moveToNext());\n\n            }\n            cursor.close();\n            return list;\n        } else {\n            Log_OC.e(TAG, \"DB error creating read all cursor for synced folders.\");\n        }\n\n        return new ArrayList<>(0);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSyncedFolders() -> [SyncedFolder] {\n    guard let cursor = mContentResolver.query(\n        ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n        projection: nil,\n        selection: nil,\n        selectionArgs: nil,\n        sortOrder: nil\n    ) else {\n        Log_OC.e(TAG, \"DB error creating read all cursor for synced folders.\")\n        return []\n    }\n\n    var list = [SyncedFolder]()\n    if cursor.moveToFirst() {\n        repeat {\n            if let syncedFolder = createSyncedFolderFromCursor(cursor) {\n                list.insert(syncedFolder, at: cursor.position)\n            } else {\n                Log_OC.e(TAG, \"SyncedFolder could not be created from cursor\")\n            }\n        } while cursor.moveToNext()\n    }\n    cursor.close()\n    return list\n}\n```"
    },
    {
        "method_name": "updateSyncedFolderEnabled",
        "method_code": "public int updateSyncedFolderEnabled(long id, Boolean enabled) {\n        Log_OC.v(TAG, \"Storing synced folder id\" + id + \" with enabled=\" + enabled);\n\n        int result = 0;\n        Cursor cursor = mContentResolver.query(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                null,\n                ProviderMeta.ProviderTableMeta._ID + \"=?\",\n                new String[]{String.valueOf(id)},\n                null\n        );\n\n        if (cursor != null && cursor.getCount() == 1) {\n            while (cursor.moveToNext()) {\n                // read sync folder object and update\n                SyncedFolder syncedFolder = createSyncedFolderFromCursor(cursor);\n\n                syncedFolder.setEnabled(enabled, clock.getCurrentTime());\n\n                // update sync folder object in db\n                result = updateSyncFolder(syncedFolder);\n\n            }\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for ID=\" + id + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for id=\" + id + \" available in sync folder database. \" +\n                        \"Expected 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled updateSyncedFolderEnabled from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: updateSyncedFolderEnabled\n\n        Method Code: public int updateSyncedFolderEnabled(long id, Boolean enabled) {\n        Log_OC.v(TAG, \"Storing synced folder id\" + id + \" with enabled=\" + enabled);\n\n        int result = 0;\n        Cursor cursor = mContentResolver.query(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                null,\n                ProviderMeta.ProviderTableMeta._ID + \"=?\",\n                new String[]{String.valueOf(id)},\n                null\n        );\n\n        if (cursor != null && cursor.getCount() == 1) {\n            while (cursor.moveToNext()) {\n                // read sync folder object and update\n                SyncedFolder syncedFolder = createSyncedFolderFromCursor(cursor);\n\n                syncedFolder.setEnabled(enabled, clock.getCurrentTime());\n\n                // update sync folder object in db\n                result = updateSyncFolder(syncedFolder);\n\n            }\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for ID=\" + id + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for id=\" + id + \" available in sync folder database. \" +\n                        \"Expected 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc updateSyncedFolderEnabled(id: Int64, enabled: Bool) -> Int {\n    Log_OC.v(TAG, \"Storing synced folder id\\(id) with enabled=\\(enabled)\")\n\n    var result = 0\n    let cursor = mContentResolver.query(\n        ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n        projection: nil,\n        selection: \"\\(ProviderMeta.ProviderTableMeta._ID)=?\",\n        selectionArgs: [String(id)],\n        sortOrder: nil\n    )\n\n    if let cursor = cursor, cursor.count == 1 {\n        while cursor.moveToNext() {\n            // read sync folder object and update\n            let syncedFolder = createSyncedFolderFromCursor(cursor)\n\n            syncedFolder.setEnabled(enabled, clock.getCurrentTime())\n\n            // update sync folder object in db\n            result = updateSyncFolder(syncedFolder)\n        }\n    } else {\n        if cursor == nil {\n            Log_OC.e(TAG, \"Sync folder db cursor for ID=\\(id) in NULL.\")\n        } else {\n            Log_OC.e(TAG, \"\\(cursor.count) items for id=\\(id) available in sync folder database. Expected 1. Failed to update sync folder db.\")\n        }\n    }\n\n    cursor?.close()\n\n    return result\n}\n```"
    },
    {
        "method_name": "findByLocalPathAndAccount",
        "method_code": "public SyncedFolder findByLocalPathAndAccount(String localPath, User user) {\n        SyncedFolder result = null;\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH + \" LIKE ? AND \" +\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" =? \",\n            new String[]{localPath + \"%\", user.getAccountName()},\n            null\n        );\n\n        if (cursor != null && cursor.getCount() == 1) {\n            result = createSyncedFolderFromCursor(cursor);\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for local path=\" + localPath + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for local path=\" + localPath\n                        + \" available in sync folder db. Expected 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled findByLocalPathAndAccount from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: findByLocalPathAndAccount\n\n        Method Code: public SyncedFolder findByLocalPathAndAccount(String localPath, User user) {\n        SyncedFolder result = null;\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH + \" LIKE ? AND \" +\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" =? \",\n            new String[]{localPath + \"%\", user.getAccountName()},\n            null\n        );\n\n        if (cursor != null && cursor.getCount() == 1) {\n            result = createSyncedFolderFromCursor(cursor);\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for local path=\" + localPath + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for local path=\" + localPath\n                        + \" available in sync folder db. Expected 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc findByLocalPathAndAccount(localPath: String, user: User) -> SyncedFolder? {\n    var result: SyncedFolder? = nil\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH) LIKE ? AND \\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT) =?\"\n    let selectionArgs = [localPath + \"%\", user.getAccountName()]\n    \n    if let cursor = mContentResolver.query(contentUri, null, selection, selectionArgs, null) {\n        if cursor.count == 1 {\n            result = createSyncedFolderFromCursor(cursor)\n        } else {\n            if cursor == nil {\n                Log_OC.e(TAG, \"Sync folder db cursor for local path=\\(localPath) in NULL.\")\n            } else {\n                Log_OC.e(TAG, \"\\(cursor.count) items for local path=\\(localPath) available in sync folder db. Expected 1. Failed to update sync folder db.\")\n            }\n        }\n        cursor.close()\n    }\n    \n    return result\n}\n```"
    },
    {
        "method_name": "getSyncedFolderByID",
        "method_code": "@Nullable\n    public SyncedFolder getSyncedFolderByID(Long syncedFolderID) {\n        SyncedFolder result = null;\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta._ID + \" =? \",\n            new String[]{syncedFolderID.toString()},\n            null\n                                              );\n\n        if (cursor != null && cursor.getCount() == 1 && cursor.moveToFirst()) {\n            result = createSyncedFolderFromCursor(cursor);\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getSyncedFolderByID from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: getSyncedFolderByID\n\n        Method Code: @Nullable\n    public SyncedFolder getSyncedFolderByID(Long syncedFolderID) {\n        SyncedFolder result = null;\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta._ID + \" =? \",\n            new String[]{syncedFolderID.toString()},\n            null\n                                              );\n\n        if (cursor != null && cursor.getCount() == 1 && cursor.moveToFirst()) {\n            result = createSyncedFolderFromCursor(cursor);\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getSyncedFolderByID(syncedFolderID: Int64) -> SyncedFolder? {\n    var result: SyncedFolder? = nil\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta._ID) =?\"\n    let selectionArgs = [String(syncedFolderID)]\n    \n    if let cursor = mContentResolver.query(contentUri, projection: nil, selection: selection, selectionArgs: selectionArgs, sortOrder: nil) {\n        if cursor.count == 1 && cursor.moveToFirst() {\n            result = createSyncedFolderFromCursor(cursor)\n        }\n        cursor.close()\n    }\n    \n    return result\n}\n```"
    },
    {
        "method_name": "deleteSyncFoldersForAccount",
        "method_code": "public int deleteSyncFoldersForAccount(User user) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" = ?\",\n                new String[]{String.valueOf(user.getAccountName())}\n        );\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteSyncFoldersForAccount from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: deleteSyncFoldersForAccount\n\n        Method Code: public int deleteSyncFoldersForAccount(User user) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" = ?\",\n                new String[]{String.valueOf(user.getAccountName())}\n        );\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc deleteSyncFoldersForAccount(user: User) -> Int {\n    let accountName = user.getAccountName()\n    let uri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT) = ?\"\n    let selectionArgs = [String(accountName)]\n    return mContentResolver.delete(uri, selection: selection, selectionArgs: selectionArgs)\n}\n```"
    },
    {
        "method_name": "deleteSyncFolderWithId",
        "method_code": "private int deleteSyncFolderWithId(long id) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" = ?\",\n                new String[]{String.valueOf(id)}\n        );\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteSyncFolderWithId from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: deleteSyncFolderWithId\n\n        Method Code: private int deleteSyncFolderWithId(long id) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" = ?\",\n                new String[]{String.valueOf(id)}\n        );\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func deleteSyncFolderWithId(id: Int64) -> Int {\n    let uri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta._ID) = ?\"\n    let selectionArgs = [String(id)]\n    return mContentResolver.delete(uri, selection: selection, selectionArgs: selectionArgs)\n}\n```"
    },
    {
        "method_name": "updateAutoUploadPaths",
        "method_code": "public void updateAutoUploadPaths(Context context) {\n        List<SyncedFolder> syncedFolders = getSyncedFolders();\n        for (SyncedFolder syncedFolder : syncedFolders) {\n            if (!new File(syncedFolder.getLocalPath()).exists()) {\n                String localPath = syncedFolder.getLocalPath();\n                if (localPath.endsWith(PATH_SEPARATOR)) {\n                    localPath = localPath.substring(0, localPath.lastIndexOf('/'));\n                }\n                localPath = localPath.substring(0, localPath.lastIndexOf('/'));\n                if (new File(localPath).exists()) {\n                    syncedFolder.setLocalPath(localPath);\n                    updateSyncFolder(syncedFolder);\n                } else {\n                    deleteSyncFolderWithId(syncedFolder.getId());\n                }\n            }\n        }\n\n        if (context != null) {\n            AppPreferences preferences = AppPreferencesImpl.fromContext(context);\n            preferences.setAutoUploadPathsUpdateEnabled(true);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled updateAutoUploadPaths from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: updateAutoUploadPaths\n\n        Method Code: public void updateAutoUploadPaths(Context context) {\n        List<SyncedFolder> syncedFolders = getSyncedFolders();\n        for (SyncedFolder syncedFolder : syncedFolders) {\n            if (!new File(syncedFolder.getLocalPath()).exists()) {\n                String localPath = syncedFolder.getLocalPath();\n                if (localPath.endsWith(PATH_SEPARATOR)) {\n                    localPath = localPath.substring(0, localPath.lastIndexOf('/'));\n                }\n                localPath = localPath.substring(0, localPath.lastIndexOf('/'));\n                if (new File(localPath).exists()) {\n                    syncedFolder.setLocalPath(localPath);\n                    updateSyncFolder(syncedFolder);\n                } else {\n                    deleteSyncFolderWithId(syncedFolder.getId());\n                }\n            }\n        }\n\n        if (context != null) {\n            AppPreferences preferences = AppPreferencesImpl.fromContext(context);\n            preferences.setAutoUploadPathsUpdateEnabled(true);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc updateAutoUploadPaths(context: Context?) {\n    let syncedFolders = getSyncedFolders()\n    for syncedFolder in syncedFolders {\n        if !FileManager.default.fileExists(atPath: syncedFolder.localPath) {\n            var localPath = syncedFolder.localPath\n            if localPath.hasSuffix(PATH_SEPARATOR) {\n                localPath = String(localPath.dropLast())\n            }\n            localPath = String(localPath[..<localPath.lastIndex(of: \"/\")!])\n            if FileManager.default.fileExists(atPath: localPath) {\n                syncedFolder.localPath = localPath\n                updateSyncFolder(syncedFolder)\n            } else {\n                deleteSyncFolderWithId(syncedFolder.id)\n            }\n        }\n    }\n\n    if let context = context {\n        let preferences = AppPreferencesImpl.fromContext(context)\n        preferences.setAutoUploadPathsUpdateEnabled(true)\n    }\n}\n```"
    },
    {
        "method_name": "deleteSyncedFoldersNotInList",
        "method_code": "public int deleteSyncedFoldersNotInList(List<Long> ids) {\n        int result = mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" NOT IN (?)\",\n                new String[]{String.valueOf(ids)}\n        );\n\n        if(result > 0) {\n            preferences.setLegacyClean(true);\n        }\n\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteSyncedFoldersNotInList from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: deleteSyncedFoldersNotInList\n\n        Method Code: public int deleteSyncedFoldersNotInList(List<Long> ids) {\n        int result = mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" NOT IN (?)\",\n                new String[]{String.valueOf(ids)}\n        );\n\n        if(result > 0) {\n            preferences.setLegacyClean(true);\n        }\n\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc deleteSyncedFoldersNotInList(ids: [Int64]) -> Int {\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta._ID) NOT IN (?)\"\n    let selectionArgs = [String(describing: ids)]\n    \n    let result = mContentResolver.delete(contentUri, selection: selection, selectionArgs: selectionArgs)\n    \n    if result > 0 {\n        preferences.setLegacyClean(true)\n    }\n    \n    return result\n}\n```"
    },
    {
        "method_name": "deleteSyncedFolder",
        "method_code": "public int deleteSyncedFolder(long id) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" = ?\",\n                new String[]{String.valueOf(id)}\n        );\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteSyncedFolder from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: deleteSyncedFolder\n\n        Method Code: public int deleteSyncedFolder(long id) {\n        return mContentResolver.delete(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                ProviderMeta.ProviderTableMeta._ID + \" = ?\",\n                new String[]{String.valueOf(id)}\n        );\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc deleteSyncedFolder(id: Int64) -> Int {\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta._ID) = ?\"\n    let selectionArgs = [String(id)]\n    return mContentResolver.delete(contentUri, selection: selection, selectionArgs: selectionArgs)\n}\n```"
    },
    {
        "method_name": "getPreferences",
        "method_code": "public AppPreferences getPreferences() {\n        return preferences;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getPreferences from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: getPreferences\n\n        Method Code: public AppPreferences getPreferences() {\n        return preferences;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getPreferences() -> AppPreferences {\n    return preferences\n}\n```"
    },
    {
        "method_name": "updateSyncFolder",
        "method_code": "public int updateSyncFolder(SyncedFolder syncedFolder) {\n        Log_OC.v(TAG, \"Updating \" + syncedFolder.getLocalPath() + \" with enabled=\" + syncedFolder.isEnabled());\n\n        ContentValues cv = createContentValuesFromSyncedFolder(syncedFolder);\n\n        return mContentResolver.update(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                cv,\n                ProviderMeta.ProviderTableMeta._ID + \"=?\",\n                new String[]{String.valueOf(syncedFolder.getId())}\n        );\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled updateSyncFolder from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: updateSyncFolder\n\n        Method Code: public int updateSyncFolder(SyncedFolder syncedFolder) {\n        Log_OC.v(TAG, \"Updating \" + syncedFolder.getLocalPath() + \" with enabled=\" + syncedFolder.isEnabled());\n\n        ContentValues cv = createContentValuesFromSyncedFolder(syncedFolder);\n\n        return mContentResolver.update(\n                ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n                cv,\n                ProviderMeta.ProviderTableMeta._ID + \"=?\",\n                new String[]{String.valueOf(syncedFolder.getId())}\n        );\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc updateSyncFolder(syncedFolder: SyncedFolder) -> Int {\n    Log_OC.v(TAG, \"Updating \\(syncedFolder.localPath) with enabled=\\(syncedFolder.isEnabled)\")\n\n    let cv = createContentValuesFromSyncedFolder(syncedFolder: syncedFolder)\n\n    return mContentResolver.update(\n        ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n        values: cv,\n        selection: \"\\(ProviderMeta.ProviderTableMeta._ID)=?\",\n        selectionArgs: [String(syncedFolder.id)]\n    )\n}\n```"
    },
    {
        "method_name": "createSyncedFolderFromCursor",
        "method_code": "private SyncedFolder createSyncedFolderFromCursor(Cursor cursor) {\n        SyncedFolder syncedFolder = null;\n        if (cursor != null) {\n            long id = cursor.getLong(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta._ID));\n            String localPath = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH));\n            String remotePath = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH));\n            boolean wifiOnly = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY)) == 1;\n            boolean chargingOnly = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY)) == 1;\n            boolean existing = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING)) == 1;\n            boolean subfolderByDate = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE)) == 1;\n            String accountName = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT));\n            int uploadAction = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION));\n            int nameCollisionPolicy = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY));\n            boolean enabled = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED)) == 1;\n            long enabledTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS));\n            MediaFolderType type = MediaFolderType.getById(cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE)));\n            boolean hidden = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN)) == 1;\n            SubFolderRule subFolderRule = SubFolderRule.values()[cursor.getInt(\n                    cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE))];\n            boolean excludeHidden = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN)) == 1;\n            long lastScanTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS));\n\n\n            syncedFolder = new SyncedFolder(id,\n                                            localPath,\n                                            remotePath,\n                                            wifiOnly,\n                                            chargingOnly,\n                                            existing,\n                                            subfolderByDate,\n                                            accountName,\n                                            uploadAction,\n                                            nameCollisionPolicy,\n                                            enabled,\n                                            enabledTimestampMs,\n                                            type,\n                                            hidden,\n                                            subFolderRule,\n                                            excludeHidden,\n                                            lastScanTimestampMs);\n        }\n        return syncedFolder;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createSyncedFolderFromCursor from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: createSyncedFolderFromCursor\n\n        Method Code: private SyncedFolder createSyncedFolderFromCursor(Cursor cursor) {\n        SyncedFolder syncedFolder = null;\n        if (cursor != null) {\n            long id = cursor.getLong(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta._ID));\n            String localPath = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH));\n            String remotePath = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH));\n            boolean wifiOnly = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY)) == 1;\n            boolean chargingOnly = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY)) == 1;\n            boolean existing = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING)) == 1;\n            boolean subfolderByDate = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE)) == 1;\n            String accountName = cursor.getString(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT));\n            int uploadAction = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION));\n            int nameCollisionPolicy = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY));\n            boolean enabled = cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED)) == 1;\n            long enabledTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS));\n            MediaFolderType type = MediaFolderType.getById(cursor.getInt(cursor.getColumnIndexOrThrow(\n                    ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE)));\n            boolean hidden = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN)) == 1;\n            SubFolderRule subFolderRule = SubFolderRule.values()[cursor.getInt(\n                    cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE))];\n            boolean excludeHidden = cursor.getInt(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN)) == 1;\n            long lastScanTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS));\n\n\n            syncedFolder = new SyncedFolder(id,\n                                            localPath,\n                                            remotePath,\n                                            wifiOnly,\n                                            chargingOnly,\n                                            existing,\n                                            subfolderByDate,\n                                            accountName,\n                                            uploadAction,\n                                            nameCollisionPolicy,\n                                            enabled,\n                                            enabledTimestampMs,\n                                            type,\n                                            hidden,\n                                            subFolderRule,\n                                            excludeHidden,\n                                            lastScanTimestampMs);\n        }\n        return syncedFolder;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func createSyncedFolderFromCursor(cursor: Cursor?) -> SyncedFolder? {\n    var syncedFolder: SyncedFolder? = nil\n    if let cursor = cursor {\n        let id = cursor.getLong(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta._ID))\n        let localPath = cursor.getString(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH))\n        let remotePath = cursor.getString(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH))\n        let wifiOnly = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY)) == 1\n        let chargingOnly = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY)) == 1\n        let existing = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING)) == 1\n        let subfolderByDate = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE)) == 1\n        let accountName = cursor.getString(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT))\n        let uploadAction = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION))\n        let nameCollisionPolicy = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY))\n        let enabled = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED)) == 1\n        let enabledTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS))\n        let type = MediaFolderType.getById(cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE)))\n        let hidden = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN)) == 1\n        let subFolderRule = SubFolderRule.values()[cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE))]\n        let excludeHidden = cursor.getInt(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN)) == 1\n        let lastScanTimestampMs = cursor.getLong(cursor.getColumnIndexOrThrow(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS))\n\n        syncedFolder = SyncedFolder(id: id,\n                                    localPath: localPath,\n                                    remotePath: remotePath,\n                                    wifiOnly: wifiOnly,\n                                    chargingOnly: chargingOnly,\n                                    existing: existing,\n                                    subfolderByDate: subfolderByDate,\n                                    accountName: accountName,\n                                    uploadAction: uploadAction,\n                                    nameCollisionPolicy: nameCollisionPolicy,\n                                    enabled: enabled,\n                                    enabledTimestampMs: enabledTimestampMs,\n                                    type: type,\n                                    hidden: hidden,\n                                    subFolderRule: subFolderRule,\n                                    excludeHidden: excludeHidden,\n                                    lastScanTimestampMs: lastScanTimestampMs)\n    }\n    return syncedFolder\n}\n```"
    },
    {
        "method_name": "createContentValuesFromSyncedFolder",
        "method_code": "@NonNull\n    private ContentValues createContentValuesFromSyncedFolder(SyncedFolder syncedFolder) {\n        ContentValues cv = new ContentValues();\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH, syncedFolder.getLocalPath());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH, syncedFolder.getRemotePath());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY, syncedFolder.isWifiOnly());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY, syncedFolder.isChargingOnly());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING, syncedFolder.isExisting());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED, syncedFolder.isEnabled());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS, syncedFolder.getEnabledTimestampMs());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE, syncedFolder.isSubfolderByDate());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT, syncedFolder.getAccount());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION, syncedFolder.getUploadAction());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY,\n               syncedFolder.getNameCollisionPolicyInt());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE, syncedFolder.getType().id);\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN, syncedFolder.isHidden());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE, syncedFolder.getSubfolderRule().ordinal());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN, syncedFolder.isExcludeHidden());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS, syncedFolder.getLastScanTimestampMs());\n        return cv;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createContentValuesFromSyncedFolder from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: createContentValuesFromSyncedFolder\n\n        Method Code: @NonNull\n    private ContentValues createContentValuesFromSyncedFolder(SyncedFolder syncedFolder) {\n        ContentValues cv = new ContentValues();\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH, syncedFolder.getLocalPath());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH, syncedFolder.getRemotePath());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY, syncedFolder.isWifiOnly());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY, syncedFolder.isChargingOnly());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING, syncedFolder.isExisting());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED, syncedFolder.isEnabled());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS, syncedFolder.getEnabledTimestampMs());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE, syncedFolder.isSubfolderByDate());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT, syncedFolder.getAccount());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION, syncedFolder.getUploadAction());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY,\n               syncedFolder.getNameCollisionPolicyInt());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE, syncedFolder.getType().id);\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN, syncedFolder.isHidden());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE, syncedFolder.getSubfolderRule().ordinal());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN, syncedFolder.isExcludeHidden());\n        cv.put(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS, syncedFolder.getLastScanTimestampMs());\n        return cv;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func createContentValuesFromSyncedFolder(syncedFolder: SyncedFolder) -> [String: Any] {\n    var cv: [String: Any] = [:]\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LOCAL_PATH] = syncedFolder.getLocalPath()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH] = syncedFolder.getRemotePath()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_WIFI_ONLY] = syncedFolder.isWifiOnly()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_CHARGING_ONLY] = syncedFolder.isChargingOnly()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXISTING] = syncedFolder.isExisting()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED] = syncedFolder.isEnabled()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ENABLED_TIMESTAMP_MS] = syncedFolder.getEnabledTimestampMs()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_BY_DATE] = syncedFolder.isSubfolderByDate()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT] = syncedFolder.getAccount()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_UPLOAD_ACTION] = syncedFolder.getUploadAction()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_NAME_COLLISION_POLICY] = syncedFolder.getNameCollisionPolicyInt()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_TYPE] = syncedFolder.getType().id\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_HIDDEN] = syncedFolder.isHidden()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_SUBFOLDER_RULE] = syncedFolder.getSubfolderRule().rawValue\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_EXCLUDE_HIDDEN] = syncedFolder.isExcludeHidden()\n    cv[ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_LAST_SCAN_TIMESTAMP_MS] = syncedFolder.getLastScanTimestampMs()\n    return cv\n}\n```"
    },
    {
        "method_name": "findByRemotePathAndAccount",
        "method_code": "public boolean findByRemotePathAndAccount(String remotePath, User user) {\n        boolean result = false;\n\n        //if path ends with / then remove the last / to work the query right way\n        //because the sub folders of synced folders will not have the slash at the end\n        if (remotePath.endsWith(\"/\")) {\n            remotePath = remotePath.substring(0, remotePath.length() - 1);\n        }\n\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH + \" LIKE ? AND \" +\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" =? \",\n            new String[]{\"%\" + remotePath + \"%\", user.getAccountName()},\n            null);\n\n        if (cursor != null && cursor.getCount() >= 1) {\n            result = true;\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for remote path = \" + remotePath + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for remote path = \" + remotePath\n                    + \" available in sync folder db. Expected 1 or greater than 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled findByRemotePathAndAccount from SyncedFolderProvider.java into Swift.\n\n        Input:\n\n        Method Name: findByRemotePathAndAccount\n\n        Method Code: public boolean findByRemotePathAndAccount(String remotePath, User user) {\n        boolean result = false;\n\n        //if path ends with / then remove the last / to work the query right way\n        //because the sub folders of synced folders will not have the slash at the end\n        if (remotePath.endsWith(\"/\")) {\n            remotePath = remotePath.substring(0, remotePath.length() - 1);\n        }\n\n        Cursor cursor = mContentResolver.query(\n            ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS,\n            null,\n            ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH + \" LIKE ? AND \" +\n                ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT + \" =? \",\n            new String[]{\"%\" + remotePath + \"%\", user.getAccountName()},\n            null);\n\n        if (cursor != null && cursor.getCount() >= 1) {\n            result = true;\n        } else {\n            if (cursor == null) {\n                Log_OC.e(TAG, \"Sync folder db cursor for remote path = \" + remotePath + \" in NULL.\");\n            } else {\n                Log_OC.e(TAG, cursor.getCount() + \" items for remote path = \" + remotePath\n                    + \" available in sync folder db. Expected 1 or greater than 1. Failed to update sync folder db.\");\n            }\n        }\n\n        if (cursor != null) {\n            cursor.close();\n        }\n\n        return result;\n\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc findByRemotePathAndAccount(remotePath: String, user: User) -> Bool {\n    var result = false\n    var modifiedRemotePath = remotePath\n\n    // if path ends with / then remove the last / to work the query right way\n    // because the sub folders of synced folders will not have the slash at the end\n    if modifiedRemotePath.hasSuffix(\"/\") {\n        modifiedRemotePath = String(modifiedRemotePath.dropLast())\n    }\n\n    let contentUri = ProviderMeta.ProviderTableMeta.CONTENT_URI_SYNCED_FOLDERS\n    let selection = \"\\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_REMOTE_PATH) LIKE ? AND \\(ProviderMeta.ProviderTableMeta.SYNCED_FOLDER_ACCOUNT) =?\"\n    let selectionArgs = [\"%\\(modifiedRemotePath)%\", user.getAccountName()]\n\n    if let cursor = mContentResolver.query(contentUri, null, selection, selectionArgs, null) {\n        if cursor.count >= 1 {\n            result = true\n        } else {\n            Log_OC.e(TAG, \"\\(cursor.count) items for remote path = \\(modifiedRemotePath) available in sync folder db. Expected 1 or greater than 1. Failed to update sync folder db.\")\n        }\n        cursor.close()\n    } else {\n        Log_OC.e(TAG, \"Sync folder db cursor for remote path = \\(modifiedRemotePath) in NULL.\")\n    }\n\n    return result\n}\n```"
    }
]