[
    {
        "method_name": "walkFileTreeRandomly",
        "method_code": "public static void walkFileTreeRandomly(Path start, FileVisitor<? super Path> visitor) throws IOException {\n        File file = start.toFile();\n        if (!file.canRead()) {\n            visitor.visitFileFailed(start, new AccessDeniedException(file.toString()));\n        } else {\n            if (Files.isDirectory(start)) {\n                FileVisitResult preVisitDirectoryResult = visitor.preVisitDirectory(start, (BasicFileAttributes)null);\n                if (preVisitDirectoryResult == FileVisitResult.CONTINUE) {\n                    File[] children = start.toFile().listFiles();\n                    Collections.shuffle(Arrays.asList(children));\n                    if (children != null) {\n                        File[] var5 = children;\n                        int var6 = children.length;\n\n                        for(int var7 = 0; var7 < var6; ++var7) {\n                            File child = var5[var7];\n                            walkFileTreeRandomly(FileBasedPathImpl.get(child), visitor);\n                        }\n\n                        visitor.postVisitDirectory(start, (IOException)null);\n                    }\n                }\n            } else {\n                visitor.visitFile(start, new BasicFileAttributes(file));\n            }\n\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled walkFileTreeRandomly from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: walkFileTreeRandomly\n\n        Method Code: public static void walkFileTreeRandomly(Path start, FileVisitor<? super Path> visitor) throws IOException {\n        File file = start.toFile();\n        if (!file.canRead()) {\n            visitor.visitFileFailed(start, new AccessDeniedException(file.toString()));\n        } else {\n            if (Files.isDirectory(start)) {\n                FileVisitResult preVisitDirectoryResult = visitor.preVisitDirectory(start, (BasicFileAttributes)null);\n                if (preVisitDirectoryResult == FileVisitResult.CONTINUE) {\n                    File[] children = start.toFile().listFiles();\n                    Collections.shuffle(Arrays.asList(children));\n                    if (children != null) {\n                        File[] var5 = children;\n                        int var6 = children.length;\n\n                        for(int var7 = 0; var7 < var6; ++var7) {\n                            File child = var5[var7];\n                            walkFileTreeRandomly(FileBasedPathImpl.get(child), visitor);\n                        }\n\n                        visitor.postVisitDirectory(start, (IOException)null);\n                    }\n                }\n            } else {\n                visitor.visitFile(start, new BasicFileAttributes(file));\n            }\n\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nenum FileVisitResult {\n    case continueVisit\n    case terminate\n}\n\nprotocol FileVisitor {\n    func preVisitDirectory(_ dir: URL, attributes: [FileAttributeKey: Any]?) -> FileVisitResult\n    func visitFile(_ file: URL, attributes: [FileAttributeKey: Any]?)\n    func visitFileFailed(_ file: URL, error: Error)\n    func postVisitDirectory(_ dir: URL, error: Error?)\n}\n\nfunc walkFileTreeRandomly(start: URL, visitor: FileVisitor) throws {\n    let file = start\n    let fileManager = FileManager.default\n\n    guard fileManager.isReadableFile(atPath: file.path) else {\n        visitor.visitFileFailed(file, error: NSError(domain: NSCocoaErrorDomain, code: NSFileReadNoPermissionError, userInfo: [NSFilePathErrorKey: file.path]))\n        return\n    }\n\n    var isDirectory: ObjCBool = false\n    if fileManager.fileExists(atPath: file.path, isDirectory: &isDirectory), isDirectory.boolValue {\n        let preVisitDirectoryResult = visitor.preVisitDirectory(file, attributes: try? fileManager.attributesOfItem(atPath: file.path))\n        if preVisitDirectoryResult == .continueVisit {\n            if let children = try? fileManager.contentsOfDirectory(at: file, includingPropertiesForKeys: nil, options: []) {\n                let shuffledChildren = children.shuffled()\n                for child in shuffledChildren {\n                    try walkFileTreeRandomly(start: child, visitor: visitor)\n                }\n                visitor.postVisitDirectory(file, error: nil)\n            }\n        }\n    } else {\n        visitor.visitFile(file, attributes: try? fileManager.attributesOfItem(atPath: file.path))\n    }\n}\n```"
    },
    {
        "method_name": "insertCustomFolderIntoDB",
        "method_code": "private static void insertCustomFolderIntoDB(Path path,\n                                                 SyncedFolder syncedFolder,\n                                                 FilesystemDataProvider filesystemDataProvider,\n                                                 long lastCheck) {\n\n        final long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        try {\n\n            walkFileTreeRandomly(path, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n                    File file = path.toFile();\n                    if (syncedFolder.isExcludeHidden() && file.isHidden()) {\n                        // exclude hidden file or folder\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (attrs.lastModifiedTime().toMillis() < lastCheck) {\n                        // skip files that were already checked\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (syncedFolder.isExisting() || attrs.lastModifiedTime().toMillis() >= enabledTimestampMs) {\n                        // storeOrUpdateFileValue takes a few ms\n                        // -> Rest of this file check takes not even 1 ms.\n                        filesystemDataProvider.storeOrUpdateFileValue(path.toAbsolutePath().toString(),\n                                                                      attrs.lastModifiedTime().toMillis(),\n                                                                      file.isDirectory(), syncedFolder);\n                    }\n\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    if (syncedFolder.isExcludeHidden() && dir.compareTo(Paths.get(syncedFolder.getLocalPath())) != 0 && dir.toFile().isHidden()) {\n                        return FileVisitResult.SKIP_SUBTREE;\n                    }\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Something went wrong while indexing files for auto upload\", e);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled insertCustomFolderIntoDB from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: insertCustomFolderIntoDB\n\n        Method Code: private static void insertCustomFolderIntoDB(Path path,\n                                                 SyncedFolder syncedFolder,\n                                                 FilesystemDataProvider filesystemDataProvider,\n                                                 long lastCheck) {\n\n        final long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        try {\n\n            walkFileTreeRandomly(path, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n                    File file = path.toFile();\n                    if (syncedFolder.isExcludeHidden() && file.isHidden()) {\n                        // exclude hidden file or folder\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (attrs.lastModifiedTime().toMillis() < lastCheck) {\n                        // skip files that were already checked\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (syncedFolder.isExisting() || attrs.lastModifiedTime().toMillis() >= enabledTimestampMs) {\n                        // storeOrUpdateFileValue takes a few ms\n                        // -> Rest of this file check takes not even 1 ms.\n                        filesystemDataProvider.storeOrUpdateFileValue(path.toAbsolutePath().toString(),\n                                                                      attrs.lastModifiedTime().toMillis(),\n                                                                      file.isDirectory(), syncedFolder);\n                    }\n\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    if (syncedFolder.isExcludeHidden() && dir.compareTo(Paths.get(syncedFolder.getLocalPath())) != 0 && dir.toFile().isHidden()) {\n                        return FileVisitResult.SKIP_SUBTREE;\n                    }\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            Log_OC.e(TAG, \"Something went wrong while indexing files for auto upload\", e);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func insertCustomFolderIntoDB(path: URL, syncedFolder: SyncedFolder, filesystemDataProvider: FilesystemDataProvider, lastCheck: Int64) {\n    let enabledTimestampMs = syncedFolder.getEnabledTimestampMs()\n\n    do {\n        try walkFileTreeRandomly(path: path) { (url, attrs) -> FileVisitResult in\n            let file = url\n            if syncedFolder.isExcludeHidden() && file.isHidden {\n                return .continue\n            }\n\n            if attrs.lastModifiedTime < lastCheck {\n                return .continue\n            }\n\n            if syncedFolder.isExisting() || attrs.lastModifiedTime >= enabledTimestampMs {\n                filesystemDataProvider.storeOrUpdateFileValue(path: file.absoluteString, lastModified: attrs.lastModifiedTime, isDirectory: file.isDirectory, syncedFolder: syncedFolder)\n            }\n\n            return .continue\n        } preVisitDirectory: { (dir, attrs) -> FileVisitResult in\n            if syncedFolder.isExcludeHidden() && dir != URL(fileURLWithPath: syncedFolder.getLocalPath()) && dir.isHidden {\n                return .skipSubtree\n            }\n            return .continue\n        } visitFileFailed: { (file, error) -> FileVisitResult in\n            return .continue\n        }\n    } catch {\n        print(\"Something went wrong while indexing files for auto upload: \\(error)\")\n    }\n}\n```"
    },
    {
        "method_name": "visitFile",
        "method_code": "@Override\n                public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n                    File file = path.toFile();\n                    if (syncedFolder.isExcludeHidden() && file.isHidden()) {\n                        // exclude hidden file or folder\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (attrs.lastModifiedTime().toMillis() < lastCheck) {\n                        // skip files that were already checked\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (syncedFolder.isExisting() || attrs.lastModifiedTime().toMillis() >= enabledTimestampMs) {\n                        // storeOrUpdateFileValue takes a few ms\n                        // -> Rest of this file check takes not even 1 ms.\n                        filesystemDataProvider.storeOrUpdateFileValue(path.toAbsolutePath().toString(),\n                                                                      attrs.lastModifiedTime().toMillis(),\n                                                                      file.isDirectory(), syncedFolder);\n                    }\n\n                    return FileVisitResult.CONTINUE;\n                }",
        "prompt": "\n        Please translate the following Java (Android) method titled visitFile from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: visitFile\n\n        Method Code: @Override\n                public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n                    File file = path.toFile();\n                    if (syncedFolder.isExcludeHidden() && file.isHidden()) {\n                        // exclude hidden file or folder\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (attrs.lastModifiedTime().toMillis() < lastCheck) {\n                        // skip files that were already checked\n                        return FileVisitResult.CONTINUE;\n                    }\n\n                    if (syncedFolder.isExisting() || attrs.lastModifiedTime().toMillis() >= enabledTimestampMs) {\n                        // storeOrUpdateFileValue takes a few ms\n                        // -> Rest of this file check takes not even 1 ms.\n                        filesystemDataProvider.storeOrUpdateFileValue(path.toAbsolutePath().toString(),\n                                                                      attrs.lastModifiedTime().toMillis(),\n                                                                      file.isDirectory(), syncedFolder);\n                    }\n\n                    return FileVisitResult.CONTINUE;\n                }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc visitFile(path: URL, attrs: FileAttributeType) -> FileVisitResult {\n    let file = path.path\n    if syncedFolder.isExcludeHidden && FileManager.default.isHiddenFile(atPath: file) {\n        // exclude hidden file or folder\n        return .continue\n    }\n\n    if let lastModifiedTime = attrs[.modificationDate] as? Date, lastModifiedTime.timeIntervalSince1970 * 1000 < lastCheck {\n        // skip files that were already checked\n        return .continue\n    }\n\n    if syncedFolder.isExisting || (attrs[.modificationDate] as? Date)?.timeIntervalSince1970 ?? 0 * 1000 >= enabledTimestampMs {\n        // storeOrUpdateFileValue takes a few ms\n        // -> Rest of this file check takes not even 1 ms.\n        filesystemDataProvider.storeOrUpdateFileValue(path: path.absoluteString,\n                                                      lastModifiedTime: (attrs[.modificationDate] as? Date)?.timeIntervalSince1970 ?? 0 * 1000,\n                                                      isDirectory: (attrs[.type] as? FileAttributeType) == .typeDirectory,\n                                                      syncedFolder: syncedFolder)\n    }\n\n    return .continue\n}\n```"
    },
    {
        "method_name": "preVisitDirectory",
        "method_code": "@Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    if (syncedFolder.isExcludeHidden() && dir.compareTo(Paths.get(syncedFolder.getLocalPath())) != 0 && dir.toFile().isHidden()) {\n                        return FileVisitResult.SKIP_SUBTREE;\n                    }\n                    return FileVisitResult.CONTINUE;\n                }",
        "prompt": "\n        Please translate the following Java (Android) method titled preVisitDirectory from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: preVisitDirectory\n\n        Method Code: @Override\n                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                    if (syncedFolder.isExcludeHidden() && dir.compareTo(Paths.get(syncedFolder.getLocalPath())) != 0 && dir.toFile().isHidden()) {\n                        return FileVisitResult.SKIP_SUBTREE;\n                    }\n                    return FileVisitResult.CONTINUE;\n                }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func preVisitDirectory(dir: Path, attrs: BasicFileAttributes) -> FileVisitResult {\n    if syncedFolder.isExcludeHidden() && dir != Paths.get(syncedFolder.getLocalPath()) && dir.toFile().isHidden {\n        return .skipSubtree\n    }\n    return .continue\n}\n```"
    },
    {
        "method_name": "visitFileFailed",
        "method_code": "@Override\n                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n                    return FileVisitResult.CONTINUE;\n                }",
        "prompt": "\n        Please translate the following Java (Android) method titled visitFileFailed from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: visitFileFailed\n\n        Method Code: @Override\n                public FileVisitResult visitFileFailed(Path file, IOException exc) {\n                    return FileVisitResult.CONTINUE;\n                }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func visitFileFailed(file: Path, exc: IOException) -> FileVisitResult {\n    return .continue\n}\n```"
    },
    {
        "method_name": "insertAllDBEntriesForSyncedFolder",
        "method_code": "public static void insertAllDBEntriesForSyncedFolder(SyncedFolder syncedFolder) {\n        final Context context = MainApp.getAppContext();\n        final ContentResolver contentResolver = context.getContentResolver();\n\n        final long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        if (syncedFolder.isEnabled() && (syncedFolder.isExisting() || enabledTimestampMs >= 0)) {\n            MediaFolderType mediaType = syncedFolder.getType();\n            final long lastCheckTimestampMs = syncedFolder.getLastScanTimestampMs();\n\n            Log_OC.d(TAG,\"File-sync start check folder \"+syncedFolder.getLocalPath());\n            long startTime = System.nanoTime();\n\n            if (mediaType == MediaFolderType.IMAGE) {\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Images.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n            } else if (mediaType == MediaFolderType.VIDEO) {\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Video.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n            } else {\n                    FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n                    Path path = Paths.get(syncedFolder.getLocalPath());\n                    FilesSyncHelper.insertCustomFolderIntoDB(path, syncedFolder, filesystemDataProvider, lastCheckTimestampMs);\n            }\n\n            Log_OC.d(TAG,\"File-sync finished full check for custom folder \"+syncedFolder.getLocalPath()+\" within \"+(System.nanoTime() - startTime)+ \"ns\");\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled insertAllDBEntriesForSyncedFolder from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: insertAllDBEntriesForSyncedFolder\n\n        Method Code: public static void insertAllDBEntriesForSyncedFolder(SyncedFolder syncedFolder) {\n        final Context context = MainApp.getAppContext();\n        final ContentResolver contentResolver = context.getContentResolver();\n\n        final long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        if (syncedFolder.isEnabled() && (syncedFolder.isExisting() || enabledTimestampMs >= 0)) {\n            MediaFolderType mediaType = syncedFolder.getType();\n            final long lastCheckTimestampMs = syncedFolder.getLastScanTimestampMs();\n\n            Log_OC.d(TAG,\"File-sync start check folder \"+syncedFolder.getLocalPath());\n            long startTime = System.nanoTime();\n\n            if (mediaType == MediaFolderType.IMAGE) {\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Images.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n            } else if (mediaType == MediaFolderType.VIDEO) {\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Video.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n                FilesSyncHelper.insertContentIntoDB(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder,\n                                                    lastCheckTimestampMs);\n            } else {\n                    FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n                    Path path = Paths.get(syncedFolder.getLocalPath());\n                    FilesSyncHelper.insertCustomFolderIntoDB(path, syncedFolder, filesystemDataProvider, lastCheckTimestampMs);\n            }\n\n            Log_OC.d(TAG,\"File-sync finished full check for custom folder \"+syncedFolder.getLocalPath()+\" within \"+(System.nanoTime() - startTime)+ \"ns\");\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport Photos\n\nclass FilesSyncHelper {\n    static func insertAllDBEntriesForSyncedFolder(syncedFolder: SyncedFolder) {\n        let context = MainApp.getAppContext()\n        let contentResolver = context.contentResolver\n\n        let enabledTimestampMs = syncedFolder.getEnabledTimestampMs()\n\n        if syncedFolder.isEnabled() && (syncedFolder.isExisting() || enabledTimestampMs >= 0) {\n            let mediaType = syncedFolder.getType()\n            let lastCheckTimestampMs = syncedFolder.getLastScanTimestampMs()\n\n            Log_OC.d(TAG, \"File-sync start check folder \\(syncedFolder.getLocalPath())\")\n            let startTime = DispatchTime.now()\n\n            if mediaType == .image {\n                FilesSyncHelper.insertContentIntoDB(uri: MediaStore.Images.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder: syncedFolder,\n                                                    lastCheckTimestampMs: lastCheckTimestampMs)\n                FilesSyncHelper.insertContentIntoDB(uri: MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder: syncedFolder,\n                                                    lastCheckTimestampMs: lastCheckTimestampMs)\n            } else if mediaType == .video {\n                FilesSyncHelper.insertContentIntoDB(uri: MediaStore.Video.Media.INTERNAL_CONTENT_URI,\n                                                    syncedFolder: syncedFolder,\n                                                    lastCheckTimestampMs: lastCheckTimestampMs)\n                FilesSyncHelper.insertContentIntoDB(uri: MediaStore.Video.Media.EXTERNAL_CONTENT_URI,\n                                                    syncedFolder: syncedFolder,\n                                                    lastCheckTimestampMs: lastCheckTimestampMs)\n            } else {\n                let filesystemDataProvider = FilesystemDataProvider(contentResolver: contentResolver)\n                let path = URL(fileURLWithPath: syncedFolder.getLocalPath())\n                FilesSyncHelper.insertCustomFolderIntoDB(path: path, syncedFolder: syncedFolder, filesystemDataProvider: filesystemDataProvider, lastCheckTimestampMs: lastCheckTimestampMs)\n            }\n\n            let endTime = DispatchTime.now()\n            let elapsedTime = endTime.uptimeNanoseconds - startTime.uptimeNanoseconds\n            Log_OC.d(TAG, \"File-sync finished full check for custom folder \\(syncedFolder.getLocalPath()) within \\(elapsedTime)ns\")\n        }\n    }\n}\n```"
    },
    {
        "method_name": "insertChangedEntries",
        "method_code": "public static void insertChangedEntries(SyncedFolder syncedFolder,\n                                            String[] changedFiles) {\n        final ContentResolver contentResolver = MainApp.getAppContext().getContentResolver();\n        final FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n        for (String changedFileURI : changedFiles){\n            String changedFile = getFileFromURI(changedFileURI);\n            if (syncedFolder.containsTypedFile(changedFile)){\n                File file = new File(changedFile);\n                filesystemDataProvider.storeOrUpdateFileValue(changedFile,\n                                                              file.lastModified(),file.isDirectory(),\n                                                              syncedFolder);\n            }\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled insertChangedEntries from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: insertChangedEntries\n\n        Method Code: public static void insertChangedEntries(SyncedFolder syncedFolder,\n                                            String[] changedFiles) {\n        final ContentResolver contentResolver = MainApp.getAppContext().getContentResolver();\n        final FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n        for (String changedFileURI : changedFiles){\n            String changedFile = getFileFromURI(changedFileURI);\n            if (syncedFolder.containsTypedFile(changedFile)){\n                File file = new File(changedFile);\n                filesystemDataProvider.storeOrUpdateFileValue(changedFile,\n                                                              file.lastModified(),file.isDirectory(),\n                                                              syncedFolder);\n            }\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\n\nclass FilesSyncHelper {\n    static func insertChangedEntries(syncedFolder: SyncedFolder, changedFiles: [String]) {\n        let contentResolver = MainApp.getAppContext().contentResolver\n        let filesystemDataProvider = FilesystemDataProvider(contentResolver: contentResolver)\n        for changedFileURI in changedFiles {\n            let changedFile = getFileFromURI(changedFileURI)\n            if syncedFolder.containsTypedFile(changedFile) {\n                let file = File(path: changedFile)\n                filesystemDataProvider.storeOrUpdateFileValue(filePath: changedFile, lastModified: file.lastModified, isDirectory: file.isDirectory, syncedFolder: syncedFolder)\n            }\n        }\n    }\n}\n```"
    },
    {
        "method_name": "getFileFromURI",
        "method_code": "private static String getFileFromURI(String uri){\n        final Context context = MainApp.getAppContext();\n\n        Cursor cursor;\n        int column_index_data;\n        String filePath = null;\n\n        String[] projection = {MediaStore.MediaColumns.DATA};\n\n        cursor = context.getContentResolver().query(Uri.parse(uri), projection, null, null, null, null);\n\n        if (cursor != null && cursor.moveToFirst()) {\n            column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA);\n            filePath = cursor.getString(column_index_data);\n            cursor.close();\n        }\n        return filePath;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getFileFromURI from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: getFileFromURI\n\n        Method Code: private static String getFileFromURI(String uri){\n        final Context context = MainApp.getAppContext();\n\n        Cursor cursor;\n        int column_index_data;\n        String filePath = null;\n\n        String[] projection = {MediaStore.MediaColumns.DATA};\n\n        cursor = context.getContentResolver().query(Uri.parse(uri), projection, null, null, null, null);\n\n        if (cursor != null && cursor.moveToFirst()) {\n            column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA);\n            filePath = cursor.getString(column_index_data);\n            cursor.close();\n        }\n        return filePath;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func getFileFromURI(uri: String) -> String? {\n    guard let context = MainApp.getAppContext() else { return nil }\n    \n    let projection = [kUTTypeData as String]\n    let contentUri = URL(string: uri)\n    var filePath: String? = nil\n    \n    if let contentUri = contentUri {\n        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: \"Media\")\n        fetchRequest.predicate = NSPredicate(format: \"uri == %@\", contentUri.absoluteString)\n        fetchRequest.propertiesToFetch = projection\n        \n        do {\n            if let results = try context.fetch(fetchRequest) as? [NSManagedObject], let firstResult = results.first {\n                filePath = firstResult.value(forKey: kUTTypeData as String) as? String\n            }\n        } catch {\n            print(\"Failed to fetch file path: \\(error)\")\n        }\n    }\n    \n    return filePath\n}\n```"
    },
    {
        "method_name": "insertContentIntoDB",
        "method_code": "private static void insertContentIntoDB(Uri uri, SyncedFolder syncedFolder,\n                                            long lastCheckTimestampMs) {\n        final Context context = MainApp.getAppContext();\n        final ContentResolver contentResolver = context.getContentResolver();\n\n        Cursor cursor;\n        int column_index_data;\n        int column_index_date_modified;\n\n        final FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n\n        String contentPath;\n        boolean isFolder;\n\n        String[] projection = {MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DATE_MODIFIED};\n\n        String path = syncedFolder.getLocalPath();\n        if (!path.endsWith(PATH_SEPARATOR)) {\n            path = path + PATH_SEPARATOR;\n        }\n        path = path + \"%\";\n\n        long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        cursor = context.getContentResolver().query(uri, projection, MediaStore.MediaColumns.DATA + \" LIKE ?\",\n                                                    new String[]{path}, null);\n\n        if (cursor != null) {\n            column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA);\n            column_index_date_modified = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_MODIFIED);\n            while (cursor.moveToNext()) {\n                contentPath = cursor.getString(column_index_data);\n                isFolder = new File(contentPath).isDirectory();\n\n                if (syncedFolder.getLastScanTimestampMs() != SyncedFolder.NOT_SCANNED_YET &&\n                    cursor.getLong(column_index_date_modified) < (lastCheckTimestampMs / 1000)) {\n                    continue;\n                }\n\n                if (syncedFolder.isExisting() || cursor.getLong(column_index_date_modified) >= enabledTimestampMs / 1000) {\n                    // storeOrUpdateFileValue takes a few ms\n                    // -> Rest of this file check takes not even 1 ms.\n                    filesystemDataProvider.storeOrUpdateFileValue(contentPath,\n                                                                  cursor.getLong(column_index_date_modified), isFolder,\n                                                                  syncedFolder);\n                }\n            }\n            cursor.close();\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled insertContentIntoDB from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: insertContentIntoDB\n\n        Method Code: private static void insertContentIntoDB(Uri uri, SyncedFolder syncedFolder,\n                                            long lastCheckTimestampMs) {\n        final Context context = MainApp.getAppContext();\n        final ContentResolver contentResolver = context.getContentResolver();\n\n        Cursor cursor;\n        int column_index_data;\n        int column_index_date_modified;\n\n        final FilesystemDataProvider filesystemDataProvider = new FilesystemDataProvider(contentResolver);\n\n        String contentPath;\n        boolean isFolder;\n\n        String[] projection = {MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DATE_MODIFIED};\n\n        String path = syncedFolder.getLocalPath();\n        if (!path.endsWith(PATH_SEPARATOR)) {\n            path = path + PATH_SEPARATOR;\n        }\n        path = path + \"%\";\n\n        long enabledTimestampMs = syncedFolder.getEnabledTimestampMs();\n\n        cursor = context.getContentResolver().query(uri, projection, MediaStore.MediaColumns.DATA + \" LIKE ?\",\n                                                    new String[]{path}, null);\n\n        if (cursor != null) {\n            column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA);\n            column_index_date_modified = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_MODIFIED);\n            while (cursor.moveToNext()) {\n                contentPath = cursor.getString(column_index_data);\n                isFolder = new File(contentPath).isDirectory();\n\n                if (syncedFolder.getLastScanTimestampMs() != SyncedFolder.NOT_SCANNED_YET &&\n                    cursor.getLong(column_index_date_modified) < (lastCheckTimestampMs / 1000)) {\n                    continue;\n                }\n\n                if (syncedFolder.isExisting() || cursor.getLong(column_index_date_modified) >= enabledTimestampMs / 1000) {\n                    // storeOrUpdateFileValue takes a few ms\n                    // -> Rest of this file check takes not even 1 ms.\n                    filesystemDataProvider.storeOrUpdateFileValue(contentPath,\n                                                                  cursor.getLong(column_index_date_modified), isFolder,\n                                                                  syncedFolder);\n                }\n            }\n            cursor.close();\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate static func insertContentIntoDB(uri: Uri, syncedFolder: SyncedFolder, lastCheckTimestampMs: Int64) {\n    let context = MainApp.getAppContext()\n    let contentResolver = context.contentResolver\n\n    var cursor: Cursor?\n    var column_index_data: Int\n    var column_index_date_modified: Int\n\n    let filesystemDataProvider = FilesystemDataProvider(contentResolver: contentResolver)\n\n    var contentPath: String\n    var isFolder: Bool\n\n    let projection = [MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DATE_MODIFIED]\n\n    var path = syncedFolder.getLocalPath()\n    if !path.hasSuffix(PATH_SEPARATOR) {\n        path += PATH_SEPARATOR\n    }\n    path += \"%\"\n\n    let enabledTimestampMs = syncedFolder.getEnabledTimestampMs()\n\n    cursor = context.contentResolver.query(uri, projection, MediaStore.MediaColumns.DATA + \" LIKE ?\", [path], nil)\n\n    if let cursor = cursor {\n        column_index_data = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)\n        column_index_date_modified = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_MODIFIED)\n        while cursor.moveToNext() {\n            contentPath = cursor.getString(column_index_data)\n            isFolder = File(contentPath).isDirectory()\n\n            if syncedFolder.getLastScanTimestampMs() != SyncedFolder.NOT_SCANNED_YET &&\n                cursor.getLong(column_index_date_modified) < (lastCheckTimestampMs / 1000) {\n                continue\n            }\n\n            if syncedFolder.isExisting() || cursor.getLong(column_index_date_modified) >= enabledTimestampMs / 1000 {\n                filesystemDataProvider.storeOrUpdateFileValue(contentPath: contentPath,\n                                                              dateModified: cursor.getLong(column_index_date_modified),\n                                                              isFolder: isFolder,\n                                                              syncedFolder: syncedFolder)\n            }\n        }\n        cursor.close()\n    }\n}\n```"
    },
    {
        "method_name": "restartUploadsIfNeeded",
        "method_code": "public static void restartUploadsIfNeeded(final UploadsStorageManager uploadsStorageManager,\n                                              final UserAccountManager accountManager,\n                                              final ConnectivityService connectivityService,\n                                              final PowerManagementService powerManagementService) {\n        \n        new Thread(() -> {\n            FileUploadHelper.Companion.instance().retryFailedUploads(\n                uploadsStorageManager,\n                connectivityService,\n                accountManager,\n                powerManagementService);\n        }).start();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled restartUploadsIfNeeded from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: restartUploadsIfNeeded\n\n        Method Code: public static void restartUploadsIfNeeded(final UploadsStorageManager uploadsStorageManager,\n                                              final UserAccountManager accountManager,\n                                              final ConnectivityService connectivityService,\n                                              final PowerManagementService powerManagementService) {\n        \n        new Thread(() -> {\n            FileUploadHelper.Companion.instance().retryFailedUploads(\n                uploadsStorageManager,\n                connectivityService,\n                accountManager,\n                powerManagementService);\n        }).start();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc restartUploadsIfNeeded(uploadsStorageManager: UploadsStorageManager, accountManager: UserAccountManager, connectivityService: ConnectivityService, powerManagementService: PowerManagementService) {\n    DispatchQueue.global().async {\n        FileUploadHelper.instance().retryFailedUploads(uploadsStorageManager: uploadsStorageManager, connectivityService: connectivityService, accountManager: accountManager, powerManagementService: powerManagementService)\n    }\n}\n```"
    },
    {
        "method_name": "scheduleFilesSyncForAllFoldersIfNeeded",
        "method_code": "public static void scheduleFilesSyncForAllFoldersIfNeeded(Context context, SyncedFolderProvider syncedFolderProvider, BackgroundJobManager jobManager) {\n        for (SyncedFolder syncedFolder : syncedFolderProvider.getSyncedFolders()) {\n            if (syncedFolder.isEnabled()) {\n                jobManager.schedulePeriodicFilesSyncJob(syncedFolder.getId());\n            }\n        }\n        if (context != null) {\n            jobManager.scheduleContentObserverJob();\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled scheduleFilesSyncForAllFoldersIfNeeded from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: scheduleFilesSyncForAllFoldersIfNeeded\n\n        Method Code: public static void scheduleFilesSyncForAllFoldersIfNeeded(Context context, SyncedFolderProvider syncedFolderProvider, BackgroundJobManager jobManager) {\n        for (SyncedFolder syncedFolder : syncedFolderProvider.getSyncedFolders()) {\n            if (syncedFolder.isEnabled()) {\n                jobManager.schedulePeriodicFilesSyncJob(syncedFolder.getId());\n            }\n        }\n        if (context != null) {\n            jobManager.scheduleContentObserverJob();\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nclass FilesSyncHelper {\n    static func scheduleFilesSyncForAllFoldersIfNeeded(context: Context?, syncedFolderProvider: SyncedFolderProvider, jobManager: BackgroundJobManager) {\n        for syncedFolder in syncedFolderProvider.getSyncedFolders() {\n            if syncedFolder.isEnabled() {\n                jobManager.schedulePeriodicFilesSyncJob(syncedFolder.getId())\n            }\n        }\n        if context != nil {\n            jobManager.scheduleContentObserverJob()\n        }\n    }\n}\n```"
    },
    {
        "method_name": "startFilesSyncForAllFolders",
        "method_code": "public static void startFilesSyncForAllFolders(SyncedFolderProvider syncedFolderProvider, BackgroundJobManager jobManager, boolean overridePowerSaving, String[] changedFiles) {\n        for (SyncedFolder syncedFolder : syncedFolderProvider.getSyncedFolders()) {\n            if (syncedFolder.isEnabled()) {\n                jobManager.startImmediateFilesSyncJob(syncedFolder.getId(),overridePowerSaving,changedFiles);\n            }\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled startFilesSyncForAllFolders from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: startFilesSyncForAllFolders\n\n        Method Code: public static void startFilesSyncForAllFolders(SyncedFolderProvider syncedFolderProvider, BackgroundJobManager jobManager, boolean overridePowerSaving, String[] changedFiles) {\n        for (SyncedFolder syncedFolder : syncedFolderProvider.getSyncedFolders()) {\n            if (syncedFolder.isEnabled()) {\n                jobManager.startImmediateFilesSyncJob(syncedFolder.getId(),overridePowerSaving,changedFiles);\n            }\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\npublic static func startFilesSyncForAllFolders(syncedFolderProvider: SyncedFolderProvider, jobManager: BackgroundJobManager, overridePowerSaving: Bool, changedFiles: [String]) {\n    for syncedFolder in syncedFolderProvider.getSyncedFolders() {\n        if syncedFolder.isEnabled() {\n            jobManager.startImmediateFilesSyncJob(syncedFolder.getId(), overridePowerSaving: overridePowerSaving, changedFiles: changedFiles)\n        }\n    }\n}\n```"
    },
    {
        "method_name": "calculateScanInterval",
        "method_code": "public static long calculateScanInterval(\n        SyncedFolder syncedFolder,\n        ConnectivityService connectivityService,\n        PowerManagementService powerManagementService\n                                            ) {\n        long defaultInterval = BackgroundJobManagerImpl.DEFAULT_PERIODIC_JOB_INTERVAL_MINUTES * 1000 * 60;\n        if (!connectivityService.isConnected() || connectivityService.isInternetWalled()) {\n            return defaultInterval * 2;\n        }\n\n        if ((syncedFolder.isWifiOnly() && !connectivityService.getConnectivity().isWifi())) {\n            return defaultInterval * 4;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 80){\n            return defaultInterval * 2;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 50){\n            return defaultInterval * 4;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 20){\n            return defaultInterval * 8;\n        }\n\n        return defaultInterval;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled calculateScanInterval from FilesSyncHelper.java into Swift.\n\n        Input:\n\n        Method Name: calculateScanInterval\n\n        Method Code: public static long calculateScanInterval(\n        SyncedFolder syncedFolder,\n        ConnectivityService connectivityService,\n        PowerManagementService powerManagementService\n                                            ) {\n        long defaultInterval = BackgroundJobManagerImpl.DEFAULT_PERIODIC_JOB_INTERVAL_MINUTES * 1000 * 60;\n        if (!connectivityService.isConnected() || connectivityService.isInternetWalled()) {\n            return defaultInterval * 2;\n        }\n\n        if ((syncedFolder.isWifiOnly() && !connectivityService.getConnectivity().isWifi())) {\n            return defaultInterval * 4;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 80){\n            return defaultInterval * 2;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 50){\n            return defaultInterval * 4;\n        }\n\n        if (powerManagementService.getBattery().getLevel() < 20){\n            return defaultInterval * 8;\n        }\n\n        return defaultInterval;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func calculateScanInterval(syncedFolder: SyncedFolder, connectivityService: ConnectivityService, powerManagementService: PowerManagementService) -> Int64 {\n    let defaultInterval = BackgroundJobManagerImpl.DEFAULT_PERIODIC_JOB_INTERVAL_MINUTES * 1000 * 60\n    if !connectivityService.isConnected() || connectivityService.isInternetWalled() {\n        return defaultInterval * 2\n    }\n\n    if syncedFolder.isWifiOnly() && !connectivityService.getConnectivity().isWifi() {\n        return defaultInterval * 4\n    }\n\n    if powerManagementService.getBattery().getLevel() < 80 {\n        return defaultInterval * 2\n    }\n\n    if powerManagementService.getBattery().getLevel() < 50 {\n        return defaultInterval * 4\n    }\n\n    if powerManagementService.getBattery().getLevel() < 20 {\n        return defaultInterval * 8\n    }\n\n    return defaultInterval\n}\n```"
    }
]