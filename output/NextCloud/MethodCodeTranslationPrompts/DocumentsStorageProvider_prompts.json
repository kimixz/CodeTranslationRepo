[
    {
        "method_name": "queryRoots",
        "method_code": "@Override\n    public Cursor queryRoots(String[] projection) {\n\n        // always recreate storage manager collection, as it will change after account creation/removal\n        // and we need to serve document(tree)s with persist permissions\n        initiateStorageMap();\n\n        Context context = MainApp.getAppContext();\n        AppPreferences preferences = AppPreferencesImpl.fromContext(context);\n        if (SettingsActivity.LOCK_PASSCODE.equals(preferences.getLockPreference()) ||\n            SettingsActivity.LOCK_DEVICE_CREDENTIALS.equals(preferences.getLockPreference())) {\n            return new FileCursor();\n        }\n\n        final RootCursor result = new RootCursor(projection);\n        for(FileDataStorageManager manager: rootIdToStorageManager.values()) {\n            result.addRoot(new Document(manager, ROOT_PATH), getContext());\n        }\n\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled queryRoots from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: queryRoots\n\n        Method Code: @Override\n    public Cursor queryRoots(String[] projection) {\n\n        // always recreate storage manager collection, as it will change after account creation/removal\n        // and we need to serve document(tree)s with persist permissions\n        initiateStorageMap();\n\n        Context context = MainApp.getAppContext();\n        AppPreferences preferences = AppPreferencesImpl.fromContext(context);\n        if (SettingsActivity.LOCK_PASSCODE.equals(preferences.getLockPreference()) ||\n            SettingsActivity.LOCK_DEVICE_CREDENTIALS.equals(preferences.getLockPreference())) {\n            return new FileCursor();\n        }\n\n        final RootCursor result = new RootCursor(projection);\n        for(FileDataStorageManager manager: rootIdToStorageManager.values()) {\n            result.addRoot(new Document(manager, ROOT_PATH), getContext());\n        }\n\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func queryRoots(projection: [String]?) -> Cursor {\n    // always recreate storage manager collection, as it will change after account creation/removal\n    // and we need to serve document(tree)s with persist permissions\n    initiateStorageMap()\n\n    let context = MainApp.getAppContext()\n    let preferences = AppPreferencesImpl.fromContext(context)\n    if preferences.getLockPreference() == SettingsActivity.LOCK_PASSCODE ||\n        preferences.getLockPreference() == SettingsActivity.LOCK_DEVICE_CREDENTIALS {\n        return FileCursor()\n    }\n\n    let result = RootCursor(projection: projection)\n    for manager in rootIdToStorageManager.values {\n        result.addRoot(Document(manager: manager, path: ROOT_PATH), context: getContext())\n    }\n\n    return result\n}\n```"
    },
    {
        "method_name": "notifyRootsChanged",
        "method_code": "public static void notifyRootsChanged(Context context) {\n        String authority = context.getString(R.string.document_provider_authority);\n        Uri rootsUri = DocumentsContract.buildRootsUri(authority);\n        context.getContentResolver().notifyChange(rootsUri, null);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled notifyRootsChanged from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: notifyRootsChanged\n\n        Method Code: public static void notifyRootsChanged(Context context) {\n        String authority = context.getString(R.string.document_provider_authority);\n        Uri rootsUri = DocumentsContract.buildRootsUri(authority);\n        context.getContentResolver().notifyChange(rootsUri, null);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nstatic func notifyRootsChanged(context: Context) {\n    let authority = context.getString(R.string.document_provider_authority)\n    let rootsUri = DocumentsContract.buildRootsUri(authority)\n    context.getContentResolver().notifyChange(rootsUri, nil)\n}\n```"
    },
    {
        "method_name": "queryDocument",
        "method_code": "@Override\n    public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {\n        Log_OC.d(TAG, \"queryDocument(), id=\" + documentId);\n\n        Document document = toDocument(documentId);\n\n        final FileCursor result = new FileCursor(projection);\n        result.addFile(document);\n\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled queryDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: queryDocument\n\n        Method Code: @Override\n    public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {\n        Log_OC.d(TAG, \"queryDocument(), id=\" + documentId);\n\n        Document document = toDocument(documentId);\n\n        final FileCursor result = new FileCursor(projection);\n        result.addFile(document);\n\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func queryDocument(documentId: String, projection: [String]?) throws -> Cursor {\n    Log_OC.d(TAG, \"queryDocument(), id=\\(documentId)\")\n\n    let document = toDocument(documentId)\n\n    let result = FileCursor(projection: projection)\n    result.addFile(document)\n\n    return result\n}\n```"
    },
    {
        "method_name": "queryChildDocuments",
        "method_code": "@SuppressLint(\"LongLogTag\")\n    @Override\n    public Cursor queryChildDocuments(String parentDocumentId, String[] projection, String sortOrder)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"queryChildDocuments(), id=\" + parentDocumentId);\n\n        Context context = getNonNullContext();\n        Document parentFolder = toDocument(parentDocumentId);\n        final FileCursor resultCursor = new FileCursor(projection);\n\n        if (parentFolder.getFile().isEncrypted() &&\n            !FileOperationsHelper.isEndToEndEncryptionSetup(context, parentFolder.getUser())) {\n            Toast.makeText(context, R.string.e2e_not_yet_setup, Toast.LENGTH_LONG).show();\n            return resultCursor;\n        }\n\n        FileDataStorageManager storageManager = parentFolder.getStorageManager();\n\n\n        for (OCFile file : storageManager.getFolderContent(parentFolder.getFile(), false)) {\n            resultCursor.addFile(new Document(storageManager, file));\n        }\n\n        boolean isLoading = false;\n        if (parentFolder.isExpired()) {\n            final ReloadFolderDocumentTask task = new ReloadFolderDocumentTask(parentFolder, result ->\n                context.getContentResolver().notifyChange(toNotifyUri(parentFolder), null, false));\n            task.executeOnExecutor(executor);\n            resultCursor.setLoadingTask(task);\n            isLoading = true;\n        }\n\n        final Bundle extra = new Bundle();\n        extra.putBoolean(DocumentsContract.EXTRA_LOADING, isLoading);\n        resultCursor.setExtras(extra);\n        resultCursor.setNotificationUri(context.getContentResolver(), toNotifyUri(parentFolder));\n        return resultCursor;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled queryChildDocuments from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: queryChildDocuments\n\n        Method Code: @SuppressLint(\"LongLogTag\")\n    @Override\n    public Cursor queryChildDocuments(String parentDocumentId, String[] projection, String sortOrder)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"queryChildDocuments(), id=\" + parentDocumentId);\n\n        Context context = getNonNullContext();\n        Document parentFolder = toDocument(parentDocumentId);\n        final FileCursor resultCursor = new FileCursor(projection);\n\n        if (parentFolder.getFile().isEncrypted() &&\n            !FileOperationsHelper.isEndToEndEncryptionSetup(context, parentFolder.getUser())) {\n            Toast.makeText(context, R.string.e2e_not_yet_setup, Toast.LENGTH_LONG).show();\n            return resultCursor;\n        }\n\n        FileDataStorageManager storageManager = parentFolder.getStorageManager();\n\n\n        for (OCFile file : storageManager.getFolderContent(parentFolder.getFile(), false)) {\n            resultCursor.addFile(new Document(storageManager, file));\n        }\n\n        boolean isLoading = false;\n        if (parentFolder.isExpired()) {\n            final ReloadFolderDocumentTask task = new ReloadFolderDocumentTask(parentFolder, result ->\n                context.getContentResolver().notifyChange(toNotifyUri(parentFolder), null, false));\n            task.executeOnExecutor(executor);\n            resultCursor.setLoadingTask(task);\n            isLoading = true;\n        }\n\n        final Bundle extra = new Bundle();\n        extra.putBoolean(DocumentsContract.EXTRA_LOADING, isLoading);\n        resultCursor.setExtras(extra);\n        resultCursor.setNotificationUri(context.getContentResolver(), toNotifyUri(parentFolder));\n        return resultCursor;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport UIKit\n\nfunc queryChildDocuments(parentDocumentId: String, projection: [String]?, sortOrder: String?) throws -> FileCursor {\n    print(\"queryChildDocuments(), id=\\(parentDocumentId)\")\n\n    let context = getNonNullContext()\n    let parentFolder = toDocument(parentDocumentId)\n    let resultCursor = FileCursor(projection: projection)\n\n    if parentFolder.file.isEncrypted && !FileOperationsHelper.isEndToEndEncryptionSetup(context: context, user: parentFolder.user) {\n        Toast.makeText(context, R.string.e2e_not_yet_setup, Toast.LENGTH_LONG).show()\n        return resultCursor\n    }\n\n    let storageManager = parentFolder.storageManager\n\n    for file in storageManager.getFolderContent(folder: parentFolder.file, recursive: false) {\n        resultCursor.addFile(document: Document(storageManager: storageManager, file: file))\n    }\n\n    var isLoading = false\n    if parentFolder.isExpired {\n        let task = ReloadFolderDocumentTask(parentFolder: parentFolder) { result in\n            context.contentResolver.notifyChange(uri: toNotifyUri(document: parentFolder), observer: nil, syncToNetwork: false)\n        }\n        task.executeOnExecutor(executor: executor)\n        resultCursor.setLoadingTask(task: task)\n        isLoading = true\n    }\n\n    let extra = Bundle()\n    extra.setValue(isLoading, forKey: DocumentsContract.EXTRA_LOADING)\n    resultCursor.setExtras(extras: extra)\n    resultCursor.setNotificationUri(contentResolver: context.contentResolver, uri: toNotifyUri(document: parentFolder))\n    return resultCursor\n}\n```"
    },
    {
        "method_name": "openDocument",
        "method_code": "@SuppressLint(\"LongLogTag\")\n    @Override\n    public ParcelFileDescriptor openDocument(String documentId, String mode, CancellationSignal cancellationSignal)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"openDocument(), id=\" + documentId);\n\n        if (!isFolderPathValid) {\n            Log_OC.d(TAG, \"Folder path is not valid, operation is cancelled\");\n            return null;\n        }\n\n        Document document = toDocument(documentId);\n        Context context = getNonNullContext();\n\n        OCFile ocFile = document.getFile();\n        User user = document.getUser();\n\n        int accessMode = ParcelFileDescriptor.parseMode(mode);\n        boolean writeOnly = (accessMode & MODE_WRITE_ONLY) != 0;\n        boolean needsDownload = !ocFile.existsOnDevice() || (!writeOnly && hasServerChange(document));\n        if (needsDownload) {\n            if (ocFile.getLocalModificationTimestamp() > ocFile.getLastSyncDateForData()) {\n                // TODO show a conflict notification with a pending intent that shows a ConflictResolveDialog\n                Log_OC.w(TAG, \"Conflict found!\");\n            } else {\n                // dirty threading workaround for client apps which call openDocument on the main thread, thus causing\n                // a NetworkOnMainThreadException\n                final AtomicBoolean downloadResult = new AtomicBoolean(false);\n                final Thread downloadThread = new Thread(() -> {\n                    DownloadFileOperation downloadFileOperation = new DownloadFileOperation(user, ocFile, context);\n                    RemoteOperationResult result = downloadFileOperation.execute(document.getClient());\n                    if (!result.isSuccess()) {\n                        if (ocFile.isDown()) {\n                            Handler handler = new Handler(Looper.getMainLooper());\n                            handler.post(() -> Toast.makeText(MainApp.getAppContext(),\n                                                              R.string.file_not_synced,\n                                                              Toast.LENGTH_SHORT).show());\n                            downloadResult.set(true);\n                        } else {\n                            Log_OC.e(TAG, result.toString());\n                        }\n                    } else {\n                        saveDownloadedFile(document.getStorageManager(), downloadFileOperation, ocFile);\n                        downloadResult.set(true);\n                    }\n                });\n                downloadThread.start();\n\n                try {\n                    downloadThread.join();\n                    if (!downloadResult.get()) {\n                        throw new FileNotFoundException(\"Error downloading file: \" + ocFile.getFileName());\n                    }\n                } catch (InterruptedException e) {\n                    throw new FileNotFoundException(\"Error downloading file: \" + ocFile.getFileName());\n                }\n            }\n        }\n\n        File file = new File(ocFile.getStoragePath());\n\n        if (accessMode != MODE_READ_ONLY) {\n            // The calling thread is not guaranteed to have a Looper, so we can't block it with the OnCloseListener.\n            // Thus, we are unable to do a synchronous upload and have to start an asynchronous one.\n            Handler handler = new Handler(context.getMainLooper());\n            try {\n                return ParcelFileDescriptor.open(file, accessMode, handler, error -> {\n                    if (error == null) {\n                        // no error\n                        // As we can't upload the file synchronously, let's at least update its metadata here already.\n                        ocFile.setFileLength(file.length());\n                        ocFile.setModificationTimestamp(System.currentTimeMillis());\n                        document.getStorageManager().saveFile(ocFile);\n\n                        // TODO disable upload notifications as DocumentsProvider users already show them\n                        // upload file with FileUploader service (off main thread)\n                        FileUploadHelper.Companion.instance().uploadUpdatedFile(\n                            user,\n                            new OCFile[]{ ocFile },\n                            FileUploadWorker.LOCAL_BEHAVIOUR_DELETE,\n                            NameCollisionPolicy.OVERWRITE);\n                    } else {\n                        // error, no upload needed\n                        Log_OC.e(TAG, \"File was closed with an error: \" + ocFile.getFileName(), error);\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open document for writing \" + ocFile.getFileName());\n            }\n        } else {\n            return ParcelFileDescriptor.open(file, accessMode);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled openDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: openDocument\n\n        Method Code: @SuppressLint(\"LongLogTag\")\n    @Override\n    public ParcelFileDescriptor openDocument(String documentId, String mode, CancellationSignal cancellationSignal)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"openDocument(), id=\" + documentId);\n\n        if (!isFolderPathValid) {\n            Log_OC.d(TAG, \"Folder path is not valid, operation is cancelled\");\n            return null;\n        }\n\n        Document document = toDocument(documentId);\n        Context context = getNonNullContext();\n\n        OCFile ocFile = document.getFile();\n        User user = document.getUser();\n\n        int accessMode = ParcelFileDescriptor.parseMode(mode);\n        boolean writeOnly = (accessMode & MODE_WRITE_ONLY) != 0;\n        boolean needsDownload = !ocFile.existsOnDevice() || (!writeOnly && hasServerChange(document));\n        if (needsDownload) {\n            if (ocFile.getLocalModificationTimestamp() > ocFile.getLastSyncDateForData()) {\n                // TODO show a conflict notification with a pending intent that shows a ConflictResolveDialog\n                Log_OC.w(TAG, \"Conflict found!\");\n            } else {\n                // dirty threading workaround for client apps which call openDocument on the main thread, thus causing\n                // a NetworkOnMainThreadException\n                final AtomicBoolean downloadResult = new AtomicBoolean(false);\n                final Thread downloadThread = new Thread(() -> {\n                    DownloadFileOperation downloadFileOperation = new DownloadFileOperation(user, ocFile, context);\n                    RemoteOperationResult result = downloadFileOperation.execute(document.getClient());\n                    if (!result.isSuccess()) {\n                        if (ocFile.isDown()) {\n                            Handler handler = new Handler(Looper.getMainLooper());\n                            handler.post(() -> Toast.makeText(MainApp.getAppContext(),\n                                                              R.string.file_not_synced,\n                                                              Toast.LENGTH_SHORT).show());\n                            downloadResult.set(true);\n                        } else {\n                            Log_OC.e(TAG, result.toString());\n                        }\n                    } else {\n                        saveDownloadedFile(document.getStorageManager(), downloadFileOperation, ocFile);\n                        downloadResult.set(true);\n                    }\n                });\n                downloadThread.start();\n\n                try {\n                    downloadThread.join();\n                    if (!downloadResult.get()) {\n                        throw new FileNotFoundException(\"Error downloading file: \" + ocFile.getFileName());\n                    }\n                } catch (InterruptedException e) {\n                    throw new FileNotFoundException(\"Error downloading file: \" + ocFile.getFileName());\n                }\n            }\n        }\n\n        File file = new File(ocFile.getStoragePath());\n\n        if (accessMode != MODE_READ_ONLY) {\n            // The calling thread is not guaranteed to have a Looper, so we can't block it with the OnCloseListener.\n            // Thus, we are unable to do a synchronous upload and have to start an asynchronous one.\n            Handler handler = new Handler(context.getMainLooper());\n            try {\n                return ParcelFileDescriptor.open(file, accessMode, handler, error -> {\n                    if (error == null) {\n                        // no error\n                        // As we can't upload the file synchronously, let's at least update its metadata here already.\n                        ocFile.setFileLength(file.length());\n                        ocFile.setModificationTimestamp(System.currentTimeMillis());\n                        document.getStorageManager().saveFile(ocFile);\n\n                        // TODO disable upload notifications as DocumentsProvider users already show them\n                        // upload file with FileUploader service (off main thread)\n                        FileUploadHelper.Companion.instance().uploadUpdatedFile(\n                            user,\n                            new OCFile[]{ ocFile },\n                            FileUploadWorker.LOCAL_BEHAVIOUR_DELETE,\n                            NameCollisionPolicy.OVERWRITE);\n                    } else {\n                        // error, no upload needed\n                        Log_OC.e(TAG, \"File was closed with an error: \" + ocFile.getFileName(), error);\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open document for writing \" + ocFile.getFileName());\n            }\n        } else {\n            return ParcelFileDescriptor.open(file, accessMode);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nimport Foundation\nimport UIKit\n\nfunc openDocument(documentId: String, mode: String, cancellationSignal: Any?) throws -> FileHandle? {\n    print(\"openDocument(), id=\\(documentId)\")\n\n    guard isFolderPathValid else {\n        print(\"Folder path is not valid, operation is cancelled\")\n        return nil\n    }\n\n    let document = toDocument(documentId: documentId)\n    let context = getNonNullContext()\n\n    let ocFile = document.getFile()\n    let user = document.getUser()\n\n    let accessMode = try FileHandle.AccessMode(mode: mode)\n    let writeOnly = accessMode.contains(.writeOnly)\n    let needsDownload = !ocFile.existsOnDevice() || (!writeOnly && hasServerChange(document: document))\n    if needsDownload {\n        if ocFile.getLocalModificationTimestamp() > ocFile.getLastSyncDateForData() {\n            print(\"Conflict found!\")\n        } else {\n            let downloadResult = AtomicBoolean(false)\n            let downloadThread = Thread {\n                let downloadFileOperation = DownloadFileOperation(user: user, ocFile: ocFile, context: context)\n                let result = downloadFileOperation.execute(client: document.getClient())\n                if !result.isSuccess() {\n                    if ocFile.isDown() {\n                        DispatchQueue.main.async {\n                            let alert = UIAlertController(title: nil, message: \"File not synced\", preferredStyle: .alert)\n                            alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))\n                            UIApplication.shared.keyWindow?.rootViewController?.present(alert, animated: true, completion: nil)\n                        }\n                        downloadResult.set(true)\n                    } else {\n                        print(result.description)\n                    }\n                } else {\n                    saveDownloadedFile(storageManager: document.getStorageManager(), downloadFileOperation: downloadFileOperation, ocFile: ocFile)\n                    downloadResult.set(true)\n                }\n            }\n            downloadThread.start()\n\n            downloadThread.join()\n            if !downloadResult.get() {\n                throw NSError(domain: \"FileNotFound\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Error downloading file: \\(ocFile.getFileName())\"])\n            }\n        }\n    }\n\n    let file = FileManager.default.fileExists(atPath: ocFile.getStoragePath()) ? ocFile.getStoragePath() : nil\n\n    if accessMode != .readOnly {\n        let handler = DispatchQueue.main\n        do {\n            return try FileHandle(forUpdatingAtPath: file!)\n        } catch {\n            throw NSError(domain: \"FileNotFound\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to open document for writing \\(ocFile.getFileName())\"])\n        }\n    } else {\n        return try FileHandle(forReadingAtPath: file!)\n    }\n}\n```"
    },
    {
        "method_name": "hasServerChange",
        "method_code": "private boolean hasServerChange(Document document) throws FileNotFoundException {\n        Context context = getNonNullContext();\n        OCFile ocFile = document.getFile();\n        RemoteOperationResult result = new CheckEtagRemoteOperation(ocFile.getRemotePath(), ocFile.getEtag())\n            .execute(document.getUser(), context);\n        switch (result.getCode()) {\n            case ETAG_CHANGED:\n                return true;\n            case ETAG_UNCHANGED:\n                return false;\n            case FILE_NOT_FOUND:\n            default:\n                Log_OC.e(TAG, result.toString());\n                throw new FileNotFoundException(\"Error synchronizing file: \" + ocFile.getFileName());\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled hasServerChange from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: hasServerChange\n\n        Method Code: private boolean hasServerChange(Document document) throws FileNotFoundException {\n        Context context = getNonNullContext();\n        OCFile ocFile = document.getFile();\n        RemoteOperationResult result = new CheckEtagRemoteOperation(ocFile.getRemotePath(), ocFile.getEtag())\n            .execute(document.getUser(), context);\n        switch (result.getCode()) {\n            case ETAG_CHANGED:\n                return true;\n            case ETAG_UNCHANGED:\n                return false;\n            case FILE_NOT_FOUND:\n            default:\n                Log_OC.e(TAG, result.toString());\n                throw new FileNotFoundException(\"Error synchronizing file: \" + ocFile.getFileName());\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func hasServerChange(document: Document) throws -> Bool {\n    let context = getNonNullContext()\n    let ocFile = document.getFile()\n    let result = CheckEtagRemoteOperation(remotePath: ocFile.getRemotePath(), etag: ocFile.getEtag())\n        .execute(user: document.getUser(), context: context)\n    \n    switch result.getCode() {\n    case .etagChanged:\n        return true\n    case .etagUnchanged:\n        return false\n    case .fileNotFound, _:\n        Log_OC.e(TAG, result.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Error synchronizing file: \\(ocFile.getFileName())\"])\n    }\n}\n```"
    },
    {
        "method_name": "saveDownloadedFile",
        "method_code": "private void saveDownloadedFile(FileDataStorageManager storageManager, DownloadFileOperation dfo, OCFile file) {\n        long syncDate = System.currentTimeMillis();\n        file.setLastSyncDateForProperties(syncDate);\n        file.setLastSyncDateForData(syncDate);\n        file.setUpdateThumbnailNeeded(true);\n        file.setModificationTimestamp(dfo.getModificationTimestamp());\n        file.setModificationTimestampAtLastSyncForData(dfo.getModificationTimestamp());\n        file.setEtag(dfo.getEtag());\n        file.setMimeType(dfo.getMimeType());\n        String savePath = dfo.getSavePath();\n        file.setStoragePath(savePath);\n        file.setFileLength(new File(savePath).length());\n        file.setRemoteId(dfo.getFile().getRemoteId());\n        storageManager.saveFile(file);\n        if (MimeTypeUtil.isMedia(dfo.getMimeType())) {\n            FileDataStorageManager.triggerMediaScan(file.getStoragePath(), file);\n        }\n        storageManager.saveConflict(file, null);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled saveDownloadedFile from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: saveDownloadedFile\n\n        Method Code: private void saveDownloadedFile(FileDataStorageManager storageManager, DownloadFileOperation dfo, OCFile file) {\n        long syncDate = System.currentTimeMillis();\n        file.setLastSyncDateForProperties(syncDate);\n        file.setLastSyncDateForData(syncDate);\n        file.setUpdateThumbnailNeeded(true);\n        file.setModificationTimestamp(dfo.getModificationTimestamp());\n        file.setModificationTimestampAtLastSyncForData(dfo.getModificationTimestamp());\n        file.setEtag(dfo.getEtag());\n        file.setMimeType(dfo.getMimeType());\n        String savePath = dfo.getSavePath();\n        file.setStoragePath(savePath);\n        file.setFileLength(new File(savePath).length());\n        file.setRemoteId(dfo.getFile().getRemoteId());\n        storageManager.saveFile(file);\n        if (MimeTypeUtil.isMedia(dfo.getMimeType())) {\n            FileDataStorageManager.triggerMediaScan(file.getStoragePath(), file);\n        }\n        storageManager.saveConflict(file, null);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func saveDownloadedFile(storageManager: FileDataStorageManager, dfo: DownloadFileOperation, file: OCFile) {\n    let syncDate = Date().timeIntervalSince1970\n    file.setLastSyncDateForProperties(syncDate)\n    file.setLastSyncDateForData(syncDate)\n    file.setUpdateThumbnailNeeded(true)\n    file.setModificationTimestamp(dfo.getModificationTimestamp())\n    file.setModificationTimestampAtLastSyncForData(dfo.getModificationTimestamp())\n    file.setEtag(dfo.getEtag())\n    file.setMimeType(dfo.getMimeType())\n    let savePath = dfo.getSavePath()\n    file.setStoragePath(savePath)\n    file.setFileLength(FileManager.default.attributesOfItem(atPath: savePath)[.size] as? Int64 ?? 0)\n    file.setRemoteId(dfo.getFile().getRemoteId())\n    storageManager.saveFile(file)\n    if MimeTypeUtil.isMedia(dfo.getMimeType()) {\n        FileDataStorageManager.triggerMediaScan(file.getStoragePath(), file)\n    }\n    storageManager.saveConflict(file, nil)\n}\n```"
    },
    {
        "method_name": "onCreate",
        "method_code": "@Override\n    public boolean onCreate() {\n        AndroidInjection.inject(this);\n\n        // initiate storage manager collection, because we need to serve document(tree)s\n        // with persist permissions\n        initiateStorageMap();\n\n        return true;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled onCreate from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: onCreate\n\n        Method Code: @Override\n    public boolean onCreate() {\n        AndroidInjection.inject(this);\n\n        // initiate storage manager collection, because we need to serve document(tree)s\n        // with persist permissions\n        initiateStorageMap();\n\n        return true;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onCreate() -> Bool {\n    AndroidInjection.inject(self)\n\n    // initiate storage manager collection, because we need to serve document(tree)s\n    // with persist permissions\n    initiateStorageMap()\n\n    return true\n}\n```"
    },
    {
        "method_name": "openDocumentThumbnail",
        "method_code": "@Override\n    public AssetFileDescriptor openDocumentThumbnail(String documentId,\n                                                     Point sizeHint,\n                                                     CancellationSignal signal)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"openDocumentThumbnail(), id=\" + documentId);\n\n        Document document = toDocument(documentId);\n        OCFile file = document.getFile();\n\n        boolean exists = ThumbnailsCacheManager.containsBitmap(ThumbnailsCacheManager.PREFIX_THUMBNAIL\n                                                                   + file.getRemoteId());\n        if (!exists) {\n            ThumbnailsCacheManager.generateThumbnailFromOCFile(file, document.getUser(), getContext());\n        }\n\n        return new AssetFileDescriptor(DiskLruImageCacheFileProvider.getParcelFileDescriptorForOCFile(file),\n                                       0,\n                                       file.getFileLength());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled openDocumentThumbnail from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: openDocumentThumbnail\n\n        Method Code: @Override\n    public AssetFileDescriptor openDocumentThumbnail(String documentId,\n                                                     Point sizeHint,\n                                                     CancellationSignal signal)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"openDocumentThumbnail(), id=\" + documentId);\n\n        Document document = toDocument(documentId);\n        OCFile file = document.getFile();\n\n        boolean exists = ThumbnailsCacheManager.containsBitmap(ThumbnailsCacheManager.PREFIX_THUMBNAIL\n                                                                   + file.getRemoteId());\n        if (!exists) {\n            ThumbnailsCacheManager.generateThumbnailFromOCFile(file, document.getUser(), getContext());\n        }\n\n        return new AssetFileDescriptor(DiskLruImageCacheFileProvider.getParcelFileDescriptorForOCFile(file),\n                                       0,\n                                       file.getFileLength());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func openDocumentThumbnail(documentId: String, sizeHint: CGPoint, signal: CancellationSignal) throws -> AssetFileDescriptor {\n    Log_OC.d(TAG, \"openDocumentThumbnail(), id=\\(documentId)\")\n\n    let document = toDocument(documentId)\n    let file = document.getFile()\n\n    let exists = ThumbnailsCacheManager.containsBitmap(ThumbnailsCacheManager.PREFIX_THUMBNAIL + file.getRemoteId())\n    if !exists {\n        ThumbnailsCacheManager.generateThumbnailFromOCFile(file, document.getUser(), getContext())\n    }\n\n    return AssetFileDescriptor(DiskLruImageCacheFileProvider.getParcelFileDescriptorForOCFile(file), 0, file.getFileLength())\n}\n```"
    },
    {
        "method_name": "renameDocument",
        "method_code": "@Override\n    public String renameDocument(String documentId, String displayName) throws FileNotFoundException {\n        Log_OC.d(TAG, \"renameDocument(), id=\" + documentId);\n\n        String errorMessage = checkFileName(displayName);\n        if (errorMessage != null) {\n            ContextExtensionsKt.showToast(getNonNullContext(), errorMessage);\n            return null;\n        }\n\n        Document document = toDocument(documentId);\n        RemoteOperationResult result = new RenameFileOperation(document.getRemotePath(),\n                                                               displayName,\n                                                               document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to rename document with documentId \" + documentId + \": \" +\n                                                result.getException());\n        }\n\n        Context context = getNonNullContext();\n        context.getContentResolver().notifyChange(toNotifyUri(document.getParent()), null, false);\n\n        return null;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled renameDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: renameDocument\n\n        Method Code: @Override\n    public String renameDocument(String documentId, String displayName) throws FileNotFoundException {\n        Log_OC.d(TAG, \"renameDocument(), id=\" + documentId);\n\n        String errorMessage = checkFileName(displayName);\n        if (errorMessage != null) {\n            ContextExtensionsKt.showToast(getNonNullContext(), errorMessage);\n            return null;\n        }\n\n        Document document = toDocument(documentId);\n        RemoteOperationResult result = new RenameFileOperation(document.getRemotePath(),\n                                                               displayName,\n                                                               document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to rename document with documentId \" + documentId + \": \" +\n                                                result.getException());\n        }\n\n        Context context = getNonNullContext();\n        context.getContentResolver().notifyChange(toNotifyUri(document.getParent()), null, false);\n\n        return null;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func renameDocument(documentId: String, displayName: String) throws -> String? {\n    Log_OC.d(TAG, \"renameDocument(), id=\\(documentId)\")\n\n    if let errorMessage = checkFileName(displayName) {\n        ContextExtensionsKt.showToast(getNonNullContext(), errorMessage)\n        return nil\n    }\n\n    let document = toDocument(documentId)\n    let result = RenameFileOperation(remotePath: document.getRemotePath(),\n                                     newName: displayName,\n                                     storageManager: document.getStorageManager())\n        .execute(client: document.getClient())\n\n    if !result.isSuccess() {\n        Log_OC.e(TAG, result.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to rename document with documentId \\(documentId): \\(result.getException())\"])\n    }\n\n    let context = getNonNullContext()\n    context.contentResolver.notifyChange(toNotifyUri(document.getParent()), observer: nil, syncToNetwork: false)\n\n    return nil\n}\n```"
    },
    {
        "method_name": "copyDocument",
        "method_code": "@Override\n    public String copyDocument(String sourceDocumentId, String targetParentDocumentId) throws FileNotFoundException {\n        Log_OC.d(TAG, \"copyDocument(), id=\" + sourceDocumentId);\n\n        Document targetFolder = toDocument(targetParentDocumentId);\n\n        String filename = targetFolder.getFile().getFileName();\n        isFolderPathValid = checkFolderPath(filename);\n        if (!isFolderPathValid) {\n            ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters);\n            return null;\n        }\n\n        Document document = toDocument(sourceDocumentId);\n        FileDataStorageManager storageManager = document.getStorageManager();\n        RemoteOperationResult result = new CopyFileOperation(document.getRemotePath(),\n                                                             targetFolder.getRemotePath(),\n                                                             document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to copy document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        Context context = getNonNullContext();\n        User user = document.getUser();\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(),\n                                                                        System.currentTimeMillis(),\n                                                                        false,\n                                                                        false,\n                                                                        true,\n                                                                        storageManager,\n                                                                        user,\n                                                                        context)\n            .execute(targetFolder.getClient());\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to copy document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        String newPath = targetFolder.getRemotePath() + document.getFile().getFileName();\n\n        if (document.getFile().isFolder()) {\n            newPath = newPath + PATH_SEPARATOR;\n        }\n        Document newFile = new Document(storageManager, newPath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFile.getDocumentId();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled copyDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: copyDocument\n\n        Method Code: @Override\n    public String copyDocument(String sourceDocumentId, String targetParentDocumentId) throws FileNotFoundException {\n        Log_OC.d(TAG, \"copyDocument(), id=\" + sourceDocumentId);\n\n        Document targetFolder = toDocument(targetParentDocumentId);\n\n        String filename = targetFolder.getFile().getFileName();\n        isFolderPathValid = checkFolderPath(filename);\n        if (!isFolderPathValid) {\n            ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters);\n            return null;\n        }\n\n        Document document = toDocument(sourceDocumentId);\n        FileDataStorageManager storageManager = document.getStorageManager();\n        RemoteOperationResult result = new CopyFileOperation(document.getRemotePath(),\n                                                             targetFolder.getRemotePath(),\n                                                             document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to copy document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        Context context = getNonNullContext();\n        User user = document.getUser();\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(),\n                                                                        System.currentTimeMillis(),\n                                                                        false,\n                                                                        false,\n                                                                        true,\n                                                                        storageManager,\n                                                                        user,\n                                                                        context)\n            .execute(targetFolder.getClient());\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to copy document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        String newPath = targetFolder.getRemotePath() + document.getFile().getFileName();\n\n        if (document.getFile().isFolder()) {\n            newPath = newPath + PATH_SEPARATOR;\n        }\n        Document newFile = new Document(storageManager, newPath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFile.getDocumentId();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func copyDocument(sourceDocumentId: String, targetParentDocumentId: String) throws -> String? {\n    Log_OC.d(TAG, \"copyDocument(), id=\\(sourceDocumentId)\")\n\n    let targetFolder = toDocument(targetParentDocumentId)\n\n    let filename = targetFolder.getFile().getFileName()\n    isFolderPathValid = checkFolderPath(filename)\n    if !isFolderPathValid {\n        ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters)\n        return nil\n    }\n\n    let document = toDocument(sourceDocumentId)\n    let storageManager = document.getStorageManager()\n    let result = CopyFileOperation(remotePath: document.getRemotePath(),\n                                   targetRemotePath: targetFolder.getRemotePath(),\n                                   storageManager: document.getStorageManager())\n        .execute(client: document.getClient())\n\n    if !result.isSuccess() {\n        Log_OC.e(TAG, result.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to copy document with documentId \\(sourceDocumentId) to \\(targetParentDocumentId)\"])\n    }\n\n    let context = getNonNullContext()\n    let user = document.getUser()\n\n    let updateParent = RefreshFolderOperation(file: targetFolder.getFile(),\n                                              timestamp: Date().timeIntervalSince1970,\n                                              recursive: false,\n                                              force: false,\n                                              sync: true,\n                                              storageManager: storageManager,\n                                              user: user,\n                                              context: context)\n        .execute(client: targetFolder.getClient())\n\n    if !updateParent.isSuccess() {\n        Log_OC.e(TAG, updateParent.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to copy document with documentId \\(sourceDocumentId) to \\(targetParentDocumentId)\"])\n    }\n\n    var newPath = targetFolder.getRemotePath() + document.getFile().getFileName()\n\n    if document.getFile().isFolder() {\n        newPath += PATH_SEPARATOR\n    }\n    let newFile = Document(storageManager: storageManager, remotePath: newPath)\n\n    context.contentResolver.notifyChange(toNotifyUri(targetFolder), observer: nil, syncToNetwork: false)\n\n    return newFile.getDocumentId()\n}\n```"
    },
    {
        "method_name": "moveDocument",
        "method_code": "@Override\n    public String moveDocument(String sourceDocumentId, String sourceParentDocumentId, String targetParentDocumentId)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"moveDocument(), id=\" + sourceDocumentId);\n\n        Document targetFolder = toDocument(targetParentDocumentId);\n\n        String filename = targetFolder.getFile().getFileName();\n        isFolderPathValid = checkFolderPath(filename);\n        if (!isFolderPathValid) {\n            ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters);\n            return null;\n        }\n\n        Document document = toDocument(sourceDocumentId);\n        RemoteOperationResult result = new MoveFileOperation(document.getRemotePath(),\n                                                             targetFolder.getRemotePath(),\n                                                             document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to move document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        Document sourceFolder = toDocument(sourceParentDocumentId);\n\n        Context context = getNonNullContext();\n        context.getContentResolver().notifyChange(toNotifyUri(sourceFolder), null, false);\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return sourceDocumentId;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled moveDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: moveDocument\n\n        Method Code: @Override\n    public String moveDocument(String sourceDocumentId, String sourceParentDocumentId, String targetParentDocumentId)\n        throws FileNotFoundException {\n        Log_OC.d(TAG, \"moveDocument(), id=\" + sourceDocumentId);\n\n        Document targetFolder = toDocument(targetParentDocumentId);\n\n        String filename = targetFolder.getFile().getFileName();\n        isFolderPathValid = checkFolderPath(filename);\n        if (!isFolderPathValid) {\n            ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters);\n            return null;\n        }\n\n        Document document = toDocument(sourceDocumentId);\n        RemoteOperationResult result = new MoveFileOperation(document.getRemotePath(),\n                                                             targetFolder.getRemotePath(),\n                                                             document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to move document with documentId \" + sourceDocumentId\n                                                + \" to \" + targetParentDocumentId);\n        }\n\n        Document sourceFolder = toDocument(sourceParentDocumentId);\n\n        Context context = getNonNullContext();\n        context.getContentResolver().notifyChange(toNotifyUri(sourceFolder), null, false);\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return sourceDocumentId;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func moveDocument(sourceDocumentId: String, sourceParentDocumentId: String, targetParentDocumentId: String) throws -> String? {\n    Log_OC.d(TAG, \"moveDocument(), id=\\(sourceDocumentId)\")\n\n    let targetFolder = toDocument(targetParentDocumentId)\n\n    let filename = targetFolder.getFile().getFileName()\n    isFolderPathValid = checkFolderPath(filename)\n    if !isFolderPathValid {\n        ContextExtensionsKt.showToast(getNonNullContext(), R.string.file_name_validator_error_contains_reserved_names_or_invalid_characters)\n        return nil\n    }\n\n    let document = toDocument(sourceDocumentId)\n    let result = MoveFileOperation(remotePath: document.getRemotePath(),\n                                   targetRemotePath: targetFolder.getRemotePath(),\n                                   storageManager: document.getStorageManager())\n        .execute(client: document.getClient())\n\n    if !result.isSuccess() {\n        Log_OC.e(TAG, result.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to move document with documentId \\(sourceDocumentId) to \\(targetParentDocumentId)\"])\n    }\n\n    let sourceFolder = toDocument(sourceParentDocumentId)\n\n    let context = getNonNullContext()\n    context.contentResolver.notifyChange(toNotifyUri(sourceFolder), observer: nil, syncToNetwork: false)\n    context.contentResolver.notifyChange(toNotifyUri(targetFolder), observer: nil, syncToNetwork: false)\n\n    return sourceDocumentId\n}\n```"
    },
    {
        "method_name": "querySearchDocuments",
        "method_code": "@Override\n    public Cursor querySearchDocuments(String rootId, String query, String[] projection) {\n        Log_OC.d(TAG, \"querySearchDocuments(), rootId=\" + rootId);\n\n        FileCursor result = new FileCursor(projection);\n\n        FileDataStorageManager storageManager = getStorageManager(rootId);\n        if (storageManager == null) {\n            return result;\n        }\n\n        for (Document d : findFiles(new Document(storageManager, ROOT_PATH), query)) {\n            result.addFile(d);\n        }\n\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled querySearchDocuments from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: querySearchDocuments\n\n        Method Code: @Override\n    public Cursor querySearchDocuments(String rootId, String query, String[] projection) {\n        Log_OC.d(TAG, \"querySearchDocuments(), rootId=\" + rootId);\n\n        FileCursor result = new FileCursor(projection);\n\n        FileDataStorageManager storageManager = getStorageManager(rootId);\n        if (storageManager == null) {\n            return result;\n        }\n\n        for (Document d : findFiles(new Document(storageManager, ROOT_PATH), query)) {\n            result.addFile(d);\n        }\n\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func querySearchDocuments(rootId: String, query: String, projection: [String]?) -> Cursor {\n    Log_OC.d(TAG, \"querySearchDocuments(), rootId=\\(rootId)\")\n\n    let result = FileCursor(projection: projection)\n\n    guard let storageManager = getStorageManager(rootId: rootId) else {\n        return result\n    }\n\n    for document in findFiles(Document(storageManager: storageManager, path: ROOT_PATH), query: query) {\n        result.addFile(document)\n    }\n\n    return result\n}\n```"
    },
    {
        "method_name": "getCapabilities",
        "method_code": "private OCCapability getCapabilities() {\n        return CapabilityUtils.getCapability(accountManager.getUser(), getNonNullContext());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getCapabilities from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getCapabilities\n\n        Method Code: private OCCapability getCapabilities() {\n        return CapabilityUtils.getCapability(accountManager.getUser(), getNonNullContext());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getCapabilities() -> OCCapability {\n    return CapabilityUtils.getCapability(accountManager.getUser(), getNonNullContext())\n}\n```"
    },
    {
        "method_name": "checkFolderPath",
        "method_code": "private boolean checkFolderPath(String filename) {\n        return FileNameValidator.INSTANCE.checkFolderPath(filename, getCapabilities(), getNonNullContext());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled checkFolderPath from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: checkFolderPath\n\n        Method Code: private boolean checkFolderPath(String filename) {\n        return FileNameValidator.INSTANCE.checkFolderPath(filename, getCapabilities(), getNonNullContext());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func checkFolderPath(filename: String) -> Bool {\n    return FileNameValidator.INSTANCE.checkFolderPath(filename, getCapabilities(), getNonNullContext())\n}\n```"
    },
    {
        "method_name": "checkFileName",
        "method_code": "private String checkFileName(String filename) {\n        return FileNameValidator.INSTANCE.checkFileName(filename, getCapabilities(), getNonNullContext(),null);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled checkFileName from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: checkFileName\n\n        Method Code: private String checkFileName(String filename) {\n        return FileNameValidator.INSTANCE.checkFileName(filename, getCapabilities(), getNonNullContext(),null);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func checkFileName(_ filename: String) -> String {\n    return FileNameValidator.INSTANCE.checkFileName(filename, getCapabilities(), getNonNullContext(), nil)\n}\n```"
    },
    {
        "method_name": "createDocument",
        "method_code": "@Override\n    public String createDocument(String documentId, String mimeType, String displayName) throws FileNotFoundException {\n        Log_OC.d(TAG, \"createDocument(), id=\" + documentId);\n\n        String errorMessage = checkFileName(displayName);\n        if (errorMessage != null) {\n            ContextExtensionsKt.showToast(getNonNullContext(), errorMessage);\n            return null;\n        }\n\n        Document folderDocument = toDocument(documentId);\n\n        if (DocumentsContract.Document.MIME_TYPE_DIR.equalsIgnoreCase(mimeType)) {\n            return createFolder(folderDocument, displayName);\n        } else {\n            return createFile(folderDocument, displayName, mimeType);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: createDocument\n\n        Method Code: @Override\n    public String createDocument(String documentId, String mimeType, String displayName) throws FileNotFoundException {\n        Log_OC.d(TAG, \"createDocument(), id=\" + documentId);\n\n        String errorMessage = checkFileName(displayName);\n        if (errorMessage != null) {\n            ContextExtensionsKt.showToast(getNonNullContext(), errorMessage);\n            return null;\n        }\n\n        Document folderDocument = toDocument(documentId);\n\n        if (DocumentsContract.Document.MIME_TYPE_DIR.equalsIgnoreCase(mimeType)) {\n            return createFolder(folderDocument, displayName);\n        } else {\n            return createFile(folderDocument, displayName, mimeType);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func createDocument(documentId: String, mimeType: String, displayName: String) throws -> String? {\n    Log_OC.d(TAG, \"createDocument(), id=\\(documentId)\")\n\n    if let errorMessage = checkFileName(displayName) {\n        getNonNullContext().showToast(message: errorMessage)\n        return nil\n    }\n\n    let folderDocument = toDocument(documentId)\n\n    if mimeType.caseInsensitiveCompare(DocumentsContract.Document.MIME_TYPE_DIR) == .orderedSame {\n        return createFolder(folderDocument, displayName: displayName)\n    } else {\n        return createFile(folderDocument, displayName: displayName, mimeType: mimeType)\n    }\n}\n```"
    },
    {
        "method_name": "createFolder",
        "method_code": "private String createFolder(Document targetFolder, String displayName) throws FileNotFoundException {\n\n        Context context = getNonNullContext();\n        String newDirPath = targetFolder.getRemotePath() + displayName + PATH_SEPARATOR;\n        FileDataStorageManager storageManager = targetFolder.getStorageManager();\n\n        RemoteOperationResult result = new CreateFolderOperation(newDirPath,\n                                                                 accountManager.getUser(),\n                                                                 context,\n                                                                 storageManager)\n            .execute(targetFolder.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to create document with name \" +\n                                                displayName + \" and documentId \" + targetFolder.getDocumentId());\n        }\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(), System.currentTimeMillis(),\n                                                                        false, false, true, storageManager,\n                                                                        targetFolder.getUser(), context)\n            .execute(targetFolder.getClient());\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to create document with documentId \" + targetFolder.getDocumentId());\n        }\n\n        Document newFolder = new Document(storageManager, newDirPath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFolder.getDocumentId();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createFolder from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: createFolder\n\n        Method Code: private String createFolder(Document targetFolder, String displayName) throws FileNotFoundException {\n\n        Context context = getNonNullContext();\n        String newDirPath = targetFolder.getRemotePath() + displayName + PATH_SEPARATOR;\n        FileDataStorageManager storageManager = targetFolder.getStorageManager();\n\n        RemoteOperationResult result = new CreateFolderOperation(newDirPath,\n                                                                 accountManager.getUser(),\n                                                                 context,\n                                                                 storageManager)\n            .execute(targetFolder.getClient());\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to create document with name \" +\n                                                displayName + \" and documentId \" + targetFolder.getDocumentId());\n        }\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(), System.currentTimeMillis(),\n                                                                        false, false, true, storageManager,\n                                                                        targetFolder.getUser(), context)\n            .execute(targetFolder.getClient());\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to create document with documentId \" + targetFolder.getDocumentId());\n        }\n\n        Document newFolder = new Document(storageManager, newDirPath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFolder.getDocumentId();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func createFolder(targetFolder: Document, displayName: String) throws -> String {\n    let context = getNonNullContext()\n    let newDirPath = targetFolder.getRemotePath() + displayName + PATH_SEPARATOR\n    let storageManager = targetFolder.getStorageManager()\n\n    let result = CreateFolderOperation(newDirPath: newDirPath,\n                                       user: accountManager.getUser(),\n                                       context: context,\n                                       storageManager: storageManager)\n        .execute(client: targetFolder.getClient())\n\n    if !result.isSuccess() {\n        Log_OC.e(TAG, result.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to create document with name \\(displayName) and documentId \\(targetFolder.getDocumentId())\"])\n    }\n\n    let updateParent = RefreshFolderOperation(file: targetFolder.getFile(), timestamp: Date().timeIntervalSince1970,\n                                              param1: false, param2: false, param3: true, storageManager: storageManager,\n                                              user: targetFolder.getUser(), context: context)\n        .execute(client: targetFolder.getClient())\n\n    if !updateParent.isSuccess() {\n        Log_OC.e(TAG, updateParent.description)\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to create document with documentId \\(targetFolder.getDocumentId())\"])\n    }\n\n    let newFolder = Document(storageManager: storageManager, remotePath: newDirPath)\n\n    context.contentResolver.notifyChange(toNotifyUri(targetFolder), observer: nil, syncToNetwork: false)\n\n    return newFolder.getDocumentId()\n}\n```"
    },
    {
        "method_name": "createFile",
        "method_code": "private String createFile(Document targetFolder, String displayName, String mimeType) throws FileNotFoundException {\n\n        User user = targetFolder.getUser();\n\n        // create dummy file\n        File tempDir = new File(FileStorageUtils.getTemporalPath(user.getAccountName()));\n\n        if (!tempDir.exists() && !tempDir.mkdirs()) {\n            throw new FileNotFoundException(\"Temp folder could not be created: \" + tempDir.getAbsolutePath());\n        }\n\n        File emptyFile = new File(tempDir, displayName);\n\n        if (emptyFile.exists() && !emptyFile.delete()) {\n            throw new FileNotFoundException(\"Previous file could not be deleted\");\n        }\n\n        try {\n            if (!emptyFile.createNewFile()) {\n                throw new FileNotFoundException(\"File could not be created\");\n            }\n        } catch (IOException e) {\n            throw getFileNotFoundExceptionWithCause(\"File could not be created\", e);\n        }\n\n        String newFilePath = targetFolder.getRemotePath() + displayName;\n\n        // FIXME we need to update the mimeType somewhere else as well\n\n        // perform the upload, no need for chunked operation as we have a empty file\n        OwnCloudClient client = targetFolder.getClient();\n        RemoteOperationResult result = new UploadFileRemoteOperation(emptyFile.getAbsolutePath(),\n                                                                     newFilePath,\n                                                                     mimeType,\n                                                                     \"\",\n                                                                     System.currentTimeMillis() / 1000,\n                                                                     FileUtil.getCreationTimestamp(emptyFile),\n                                                                     false)\n            .execute(client);\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to upload document with path \" + newFilePath);\n        }\n\n        Context context = getNonNullContext();\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(),\n                                                                        System.currentTimeMillis(),\n                                                                        false,\n                                                                        false,\n                                                                        true,\n                                                                        targetFolder.getStorageManager(),\n                                                                        user,\n                                                                        context)\n            .execute(client);\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to create document with documentId \" + targetFolder.getDocumentId());\n        }\n\n        Document newFile = new Document(targetFolder.getStorageManager(), newFilePath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFile.getDocumentId();\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled createFile from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: createFile\n\n        Method Code: private String createFile(Document targetFolder, String displayName, String mimeType) throws FileNotFoundException {\n\n        User user = targetFolder.getUser();\n\n        // create dummy file\n        File tempDir = new File(FileStorageUtils.getTemporalPath(user.getAccountName()));\n\n        if (!tempDir.exists() && !tempDir.mkdirs()) {\n            throw new FileNotFoundException(\"Temp folder could not be created: \" + tempDir.getAbsolutePath());\n        }\n\n        File emptyFile = new File(tempDir, displayName);\n\n        if (emptyFile.exists() && !emptyFile.delete()) {\n            throw new FileNotFoundException(\"Previous file could not be deleted\");\n        }\n\n        try {\n            if (!emptyFile.createNewFile()) {\n                throw new FileNotFoundException(\"File could not be created\");\n            }\n        } catch (IOException e) {\n            throw getFileNotFoundExceptionWithCause(\"File could not be created\", e);\n        }\n\n        String newFilePath = targetFolder.getRemotePath() + displayName;\n\n        // FIXME we need to update the mimeType somewhere else as well\n\n        // perform the upload, no need for chunked operation as we have a empty file\n        OwnCloudClient client = targetFolder.getClient();\n        RemoteOperationResult result = new UploadFileRemoteOperation(emptyFile.getAbsolutePath(),\n                                                                     newFilePath,\n                                                                     mimeType,\n                                                                     \"\",\n                                                                     System.currentTimeMillis() / 1000,\n                                                                     FileUtil.getCreationTimestamp(emptyFile),\n                                                                     false)\n            .execute(client);\n\n        if (!result.isSuccess()) {\n            Log_OC.e(TAG, result.toString());\n            throw new FileNotFoundException(\"Failed to upload document with path \" + newFilePath);\n        }\n\n        Context context = getNonNullContext();\n\n        RemoteOperationResult updateParent = new RefreshFolderOperation(targetFolder.getFile(),\n                                                                        System.currentTimeMillis(),\n                                                                        false,\n                                                                        false,\n                                                                        true,\n                                                                        targetFolder.getStorageManager(),\n                                                                        user,\n                                                                        context)\n            .execute(client);\n\n        if (!updateParent.isSuccess()) {\n            Log_OC.e(TAG, updateParent.toString());\n            throw new FileNotFoundException(\"Failed to create document with documentId \" + targetFolder.getDocumentId());\n        }\n\n        Document newFile = new Document(targetFolder.getStorageManager(), newFilePath);\n\n        context.getContentResolver().notifyChange(toNotifyUri(targetFolder), null, false);\n\n        return newFile.getDocumentId();\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func createFile(targetFolder: Document, displayName: String, mimeType: String) throws -> String {\n    let user = targetFolder.getUser()\n\n    // create dummy file\n    let tempDir = File(FileStorageUtils.getTemporalPath(user.getAccountName()))\n\n    if !tempDir.exists() && !tempDir.mkdirs() {\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Temp folder could not be created: \\(tempDir.getAbsolutePath())\"])\n    }\n\n    let emptyFile = File(tempDir, displayName)\n\n    if emptyFile.exists() && !emptyFile.delete() {\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Previous file could not be deleted\"])\n    }\n\n    do {\n        if !emptyFile.createNewFile() {\n            throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"File could not be created\"])\n        }\n    } catch let e as NSError {\n        throw getFileNotFoundExceptionWithCause(\"File could not be created\", e)\n    }\n\n    let newFilePath = targetFolder.getRemotePath() + displayName\n\n    // FIXME we need to update the mimeType somewhere else as well\n\n    // perform the upload, no need for chunked operation as we have a empty file\n    let client = targetFolder.getClient()\n    let result = UploadFileRemoteOperation(emptyFile.getAbsolutePath(),\n                                           newFilePath,\n                                           mimeType,\n                                           \"\",\n                                           Date().timeIntervalSince1970,\n                                           FileUtil.getCreationTimestamp(emptyFile),\n                                           false)\n        .execute(client)\n\n    if !result.isSuccess() {\n        Log_OC.e(TAG, result.toString())\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to upload document with path \\(newFilePath)\"])\n    }\n\n    let context = getNonNullContext()\n\n    let updateParent = RefreshFolderOperation(targetFolder.getFile(),\n                                              Date().timeIntervalSince1970,\n                                              false,\n                                              false,\n                                              true,\n                                              targetFolder.getStorageManager(),\n                                              user,\n                                              context)\n        .execute(client)\n\n    if !updateParent.isSuccess() {\n        Log_OC.e(TAG, updateParent.toString())\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to create document with documentId \\(targetFolder.getDocumentId())\"])\n    }\n\n    let newFile = Document(targetFolder.getStorageManager(), newFilePath)\n\n    context.getContentResolver().notifyChange(toNotifyUri(targetFolder), nil, false)\n\n    return newFile.getDocumentId()\n}\n```"
    },
    {
        "method_name": "removeDocument",
        "method_code": "@Override\n    public void removeDocument(String documentId, String parentDocumentId) throws FileNotFoundException {\n        deleteDocument(documentId);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled removeDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: removeDocument\n\n        Method Code: @Override\n    public void removeDocument(String documentId, String parentDocumentId) throws FileNotFoundException {\n        deleteDocument(documentId);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func removeDocument(documentId: String, parentDocumentId: String) throws {\n    try deleteDocument(documentId: documentId)\n}\n```"
    },
    {
        "method_name": "deleteDocument",
        "method_code": "@Override\n    public void deleteDocument(String documentId) throws FileNotFoundException {\n        Log_OC.d(TAG, \"deleteDocument(), id=\" + documentId);\n\n        Context context = getNonNullContext();\n\n        Document document = toDocument(documentId);\n        // get parent here, because it is not available anymore after the document was deleted\n        Document parentFolder = document.getParent();\n\n        recursiveRevokePermission(document);\n\n        OCFile file = document.getStorageManager().getFileByPath(document.getRemotePath());\n        RemoteOperationResult result = new RemoveFileOperation(file,\n                                                               false,\n                                                               document.getUser(),\n                                                               true,\n                                                               context,\n                                                               document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            throw new FileNotFoundException(\"Failed to delete document with documentId \" + documentId);\n        }\n        context.getContentResolver().notifyChange(toNotifyUri(parentFolder), null, false);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled deleteDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: deleteDocument\n\n        Method Code: @Override\n    public void deleteDocument(String documentId) throws FileNotFoundException {\n        Log_OC.d(TAG, \"deleteDocument(), id=\" + documentId);\n\n        Context context = getNonNullContext();\n\n        Document document = toDocument(documentId);\n        // get parent here, because it is not available anymore after the document was deleted\n        Document parentFolder = document.getParent();\n\n        recursiveRevokePermission(document);\n\n        OCFile file = document.getStorageManager().getFileByPath(document.getRemotePath());\n        RemoteOperationResult result = new RemoveFileOperation(file,\n                                                               false,\n                                                               document.getUser(),\n                                                               true,\n                                                               context,\n                                                               document.getStorageManager())\n            .execute(document.getClient());\n\n        if (!result.isSuccess()) {\n            throw new FileNotFoundException(\"Failed to delete document with documentId \" + documentId);\n        }\n        context.getContentResolver().notifyChange(toNotifyUri(parentFolder), null, false);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc deleteDocument(documentId: String) throws {\n    Log_OC.d(TAG, \"deleteDocument(), id=\\(documentId)\")\n\n    guard let context = getNonNullContext() else {\n        throw NSError(domain: \"ContextError\", code: 0, userInfo: nil)\n    }\n\n    let document = toDocument(documentId)\n    let parentFolder = document.getParent()\n\n    recursiveRevokePermission(document)\n\n    guard let file = document.getStorageManager().getFileByPath(document.getRemotePath()) else {\n        throw NSError(domain: \"FileError\", code: 0, userInfo: nil)\n    }\n\n    let operation = RemoveFileOperation(file: file,\n                                        isFolder: false,\n                                        user: document.getUser(),\n                                        removeLocal: true,\n                                        context: context,\n                                        storageManager: document.getStorageManager())\n\n    let result = operation.execute(document.getClient())\n\n    if !result.isSuccess() {\n        throw NSError(domain: \"FileNotFoundError\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Failed to delete document with documentId \\(documentId)\"])\n    }\n\n    context.contentResolver.notifyChange(toNotifyUri(parentFolder), observer: nil, syncToNetwork: false)\n}\n```"
    },
    {
        "method_name": "recursiveRevokePermission",
        "method_code": "private void recursiveRevokePermission(Document document) {\n        FileDataStorageManager storageManager = document.getStorageManager();\n        OCFile file = document.getFile();\n        if (file.isFolder()) {\n            for (OCFile child : storageManager.getFolderContent(file, false)) {\n                recursiveRevokePermission(new Document(storageManager, child));\n            }\n        }\n\n        revokeDocumentPermission(document.getDocumentId());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled recursiveRevokePermission from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: recursiveRevokePermission\n\n        Method Code: private void recursiveRevokePermission(Document document) {\n        FileDataStorageManager storageManager = document.getStorageManager();\n        OCFile file = document.getFile();\n        if (file.isFolder()) {\n            for (OCFile child : storageManager.getFolderContent(file, false)) {\n                recursiveRevokePermission(new Document(storageManager, child));\n            }\n        }\n\n        revokeDocumentPermission(document.getDocumentId());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func recursiveRevokePermission(document: Document) {\n    let storageManager = document.getStorageManager()\n    let file = document.getFile()\n    if file.isFolder() {\n        for child in storageManager.getFolderContent(file, false) {\n            recursiveRevokePermission(document: Document(storageManager: storageManager, file: child))\n        }\n    }\n    \n    revokeDocumentPermission(documentId: document.getDocumentId())\n}\n```"
    },
    {
        "method_name": "isChildDocument",
        "method_code": "@Override\n    public boolean isChildDocument(String parentDocumentId, String documentId) {\n        Log_OC.d(TAG, \"isChildDocument(), parent=\" + parentDocumentId + \", id=\" + documentId);\n\n        try {\n            // get file for parent document\n            Document parentDocument = toDocument(parentDocumentId);\n            OCFile parentFile = parentDocument.getFile();\n            if (parentFile == null) {\n                throw new FileNotFoundException(\"No parent file with ID \" + parentDocumentId);\n            }\n            // get file for child candidate document\n            Document currentDocument = toDocument(documentId);\n            OCFile childFile = currentDocument.getFile();\n            if (childFile == null) {\n                throw new FileNotFoundException(\"No child file with ID \" + documentId);\n            }\n\n            String parentPath = parentFile.getDecryptedRemotePath();\n            String childPath = childFile.getDecryptedRemotePath();\n\n            // The alternative is to go up the folder hierarchy from currentDocument with getParent()\n            // until we arrive at parentDocument or the storage root.\n            // However, especially for long paths this is expensive and can take substantial time.\n            // The solution below uses paths and is faster by a factor of 2-10 depending on the nesting level of child.\n            // So far, the same document with its unique ID can never be in two places at once.\n            // If this assumption ever changes, this code would need to be adapted.\n            User parentDocumentOwner = parentDocument.getUser();\n            User currentDocumentOwner = currentDocument.getUser();\n            return parentDocumentOwner.nameEquals(currentDocumentOwner) && childPath.startsWith(parentPath);\n\n        } catch (FileNotFoundException e) {\n            Log_OC.e(TAG, \"failed to check for child document\", e);\n        }\n\n        return false;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled isChildDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: isChildDocument\n\n        Method Code: @Override\n    public boolean isChildDocument(String parentDocumentId, String documentId) {\n        Log_OC.d(TAG, \"isChildDocument(), parent=\" + parentDocumentId + \", id=\" + documentId);\n\n        try {\n            // get file for parent document\n            Document parentDocument = toDocument(parentDocumentId);\n            OCFile parentFile = parentDocument.getFile();\n            if (parentFile == null) {\n                throw new FileNotFoundException(\"No parent file with ID \" + parentDocumentId);\n            }\n            // get file for child candidate document\n            Document currentDocument = toDocument(documentId);\n            OCFile childFile = currentDocument.getFile();\n            if (childFile == null) {\n                throw new FileNotFoundException(\"No child file with ID \" + documentId);\n            }\n\n            String parentPath = parentFile.getDecryptedRemotePath();\n            String childPath = childFile.getDecryptedRemotePath();\n\n            // The alternative is to go up the folder hierarchy from currentDocument with getParent()\n            // until we arrive at parentDocument or the storage root.\n            // However, especially for long paths this is expensive and can take substantial time.\n            // The solution below uses paths and is faster by a factor of 2-10 depending on the nesting level of child.\n            // So far, the same document with its unique ID can never be in two places at once.\n            // If this assumption ever changes, this code would need to be adapted.\n            User parentDocumentOwner = parentDocument.getUser();\n            User currentDocumentOwner = currentDocument.getUser();\n            return parentDocumentOwner.nameEquals(currentDocumentOwner) && childPath.startsWith(parentPath);\n\n        } catch (FileNotFoundException e) {\n            Log_OC.e(TAG, \"failed to check for child document\", e);\n        }\n\n        return false;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isChildDocument(parentDocumentId: String, documentId: String) -> Bool {\n    Log_OC.d(TAG, \"isChildDocument(), parent=\\(parentDocumentId), id=\\(documentId)\")\n\n    do {\n        // get file for parent document\n        let parentDocument = try toDocument(documentId: parentDocumentId)\n        guard let parentFile = parentDocument.getFile() else {\n            throw NSError(domain: \"FileNotFound\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"No parent file with ID \\(parentDocumentId)\"])\n        }\n        // get file for child candidate document\n        let currentDocument = try toDocument(documentId: documentId)\n        guard let childFile = currentDocument.getFile() else {\n            throw NSError(domain: \"FileNotFound\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"No child file with ID \\(documentId)\"])\n        }\n\n        let parentPath = parentFile.getDecryptedRemotePath()\n        let childPath = childFile.getDecryptedRemotePath()\n\n        // The alternative is to go up the folder hierarchy from currentDocument with getParent()\n        // until we arrive at parentDocument or the storage root.\n        // However, especially for long paths this is expensive and can take substantial time.\n        // The solution below uses paths and is faster by a factor of 2-10 depending on the nesting level of child.\n        // So far, the same document with its unique ID can never be in two places at once.\n        // If this assumption ever changes, this code would need to be adapted.\n        let parentDocumentOwner = parentDocument.getUser()\n        let currentDocumentOwner = currentDocument.getUser()\n        return parentDocumentOwner.nameEquals(currentDocumentOwner) && childPath.hasPrefix(parentPath)\n\n    } catch {\n        Log_OC.e(TAG, \"failed to check for child document\", error)\n    }\n\n    return false\n}\n```"
    },
    {
        "method_name": "getFileNotFoundExceptionWithCause",
        "method_code": "private FileNotFoundException getFileNotFoundExceptionWithCause(String msg, Exception cause) {\n        FileNotFoundException e = new FileNotFoundException(msg);\n        e.initCause(cause);\n        return e;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getFileNotFoundExceptionWithCause from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getFileNotFoundExceptionWithCause\n\n        Method Code: private FileNotFoundException getFileNotFoundExceptionWithCause(String msg, Exception cause) {\n        FileNotFoundException e = new FileNotFoundException(msg);\n        e.initCause(cause);\n        return e;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getFileNotFoundExceptionWithCause(msg: String, cause: Error) -> NSError {\n    let userInfo: [String: Any] = [NSUnderlyingErrorKey: cause]\n    return NSError(domain: \"FileNotFoundException\", code: 0, userInfo: userInfo)\n}\n```"
    },
    {
        "method_name": "getStorageManager",
        "method_code": "private FileDataStorageManager getStorageManager(String rootId) {\n        return rootIdToStorageManager.get(rootId);\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getStorageManager from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getStorageManager\n\n        Method Code: private FileDataStorageManager getStorageManager(String rootId) {\n        return rootIdToStorageManager.get(rootId);\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getStorageManager(rootId: String) -> FileDataStorageManager? {\n    return rootIdToStorageManager[rootId]\n}\n```"
    },
    {
        "method_name": "rootIdForUser",
        "method_code": "@VisibleForTesting\n    public static String rootIdForUser(User user) {\n        return HashUtil.md5Hash(user.getAccountName());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled rootIdForUser from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: rootIdForUser\n\n        Method Code: @VisibleForTesting\n    public static String rootIdForUser(User user) {\n        return HashUtil.md5Hash(user.getAccountName());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\n@available(*, deprecated)\nstatic func rootIdForUser(user: User) -> String {\n    return HashUtil.md5Hash(user.getAccountName())\n}\n```"
    },
    {
        "method_name": "initiateStorageMap",
        "method_code": "private void initiateStorageMap() {\n\n        rootIdToStorageManager.clear();\n\n        ContentResolver contentResolver = getContext().getContentResolver();\n\n        for (User user : accountManager.getAllUsers()) {\n            final FileDataStorageManager storageManager = new FileDataStorageManager(user, contentResolver);\n            rootIdToStorageManager.put(rootIdForUser(user), storageManager);\n        }\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled initiateStorageMap from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: initiateStorageMap\n\n        Method Code: private void initiateStorageMap() {\n\n        rootIdToStorageManager.clear();\n\n        ContentResolver contentResolver = getContext().getContentResolver();\n\n        for (User user : accountManager.getAllUsers()) {\n            final FileDataStorageManager storageManager = new FileDataStorageManager(user, contentResolver);\n            rootIdToStorageManager.put(rootIdForUser(user), storageManager);\n        }\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func initiateStorageMap() {\n    rootIdToStorageManager.removeAll()\n\n    guard let contentResolver = context?.contentResolver else { return }\n\n    for user in accountManager.getAllUsers() {\n        let storageManager = FileDataStorageManager(user: user, contentResolver: contentResolver)\n        rootIdToStorageManager[rootIdForUser(user)] = storageManager\n    }\n}\n```"
    },
    {
        "method_name": "findFiles",
        "method_code": "private List<Document> findFiles(Document root, String query) {\n        FileDataStorageManager storageManager = root.getStorageManager();\n        List<Document> result = new ArrayList<>();\n        for (OCFile f : storageManager.getFolderContent(root.getFile(), false)) {\n            if (f.isFolder()) {\n                result.addAll(findFiles(new Document(storageManager, f), query));\n            } else if (f.getFileName().contains(query)) {\n                result.add(new Document(storageManager, f));\n            }\n        }\n        return result;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled findFiles from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: findFiles\n\n        Method Code: private List<Document> findFiles(Document root, String query) {\n        FileDataStorageManager storageManager = root.getStorageManager();\n        List<Document> result = new ArrayList<>();\n        for (OCFile f : storageManager.getFolderContent(root.getFile(), false)) {\n            if (f.isFolder()) {\n                result.addAll(findFiles(new Document(storageManager, f), query));\n            } else if (f.getFileName().contains(query)) {\n                result.add(new Document(storageManager, f));\n            }\n        }\n        return result;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func findFiles(root: Document, query: String) -> [Document] {\n    let storageManager = root.getStorageManager()\n    var result: [Document] = []\n    for f in storageManager.getFolderContent(root.getFile(), false) {\n        if f.isFolder() {\n            result.append(contentsOf: findFiles(root: Document(storageManager: storageManager, file: f), query: query))\n        } else if f.getFileName().contains(query) {\n            result.append(Document(storageManager: storageManager, file: f))\n        }\n    }\n    return result\n}\n```"
    },
    {
        "method_name": "toNotifyUri",
        "method_code": "private Uri toNotifyUri(Document document) {\n        return DocumentsContract.buildDocumentUri(\n            getContext().getString(R.string.document_provider_authority),\n            document.getDocumentId());\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled toNotifyUri from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: toNotifyUri\n\n        Method Code: private Uri toNotifyUri(Document document) {\n        return DocumentsContract.buildDocumentUri(\n            getContext().getString(R.string.document_provider_authority),\n            document.getDocumentId());\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func toNotifyUri(document: Document) -> URL? {\n    let authority = Bundle.main.object(forInfoDictionaryKey: \"document_provider_authority\") as? String ?? \"\"\n    return URL(string: \"content://\\(authority)/\\(document.documentId)\")\n}\n```"
    },
    {
        "method_name": "toDocument",
        "method_code": "private Document toDocument(String documentId) throws FileNotFoundException {\n        String[] separated = documentId.split(DOCUMENTID_SEPARATOR, DOCUMENTID_PARTS);\n        if (separated.length != DOCUMENTID_PARTS) {\n            throw new FileNotFoundException(\"Invalid documentID \" + documentId + \"!\");\n        }\n\n        FileDataStorageManager storageManager = rootIdToStorageManager.get(separated[0]);\n        if (storageManager == null) {\n            throw new FileNotFoundException(\"No storage manager associated for \" + documentId + \"!\");\n        }\n\n        return new Document(storageManager, Long.parseLong(separated[1]));\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled toDocument from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: toDocument\n\n        Method Code: private Document toDocument(String documentId) throws FileNotFoundException {\n        String[] separated = documentId.split(DOCUMENTID_SEPARATOR, DOCUMENTID_PARTS);\n        if (separated.length != DOCUMENTID_PARTS) {\n            throw new FileNotFoundException(\"Invalid documentID \" + documentId + \"!\");\n        }\n\n        FileDataStorageManager storageManager = rootIdToStorageManager.get(separated[0]);\n        if (storageManager == null) {\n            throw new FileNotFoundException(\"No storage manager associated for \" + documentId + \"!\");\n        }\n\n        return new Document(storageManager, Long.parseLong(separated[1]));\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func toDocument(documentId: String) throws -> Document {\n    let separated = documentId.split(separator: DOCUMENTID_SEPARATOR, maxSplits: DOCUMENTID_PARTS, omittingEmptySubsequences: false)\n    if separated.count != DOCUMENTID_PARTS {\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Invalid documentID \\(documentId)!\"])\n    }\n\n    guard let storageManager = rootIdToStorageManager[String(separated[0])] else {\n        throw NSError(domain: \"FileNotFoundException\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"No storage manager associated for \\(documentId)!\"])\n    }\n\n    return Document(storageManager: storageManager, id: Int64(separated[1])!)\n}\n```"
    },
    {
        "method_name": "getNonNullContext",
        "method_code": "@NonNull\n    private Context getNonNullContext() {\n        Context context = getContext();\n        if (context == null) {\n            throw new IllegalStateException();\n        }\n        return context;\n    }",
        "prompt": "\n        Please translate the following Java (Android) method titled getNonNullContext from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getNonNullContext\n\n        Method Code: @NonNull\n    private Context getNonNullContext() {\n        Context context = getContext();\n        if (context == null) {\n            throw new IllegalStateException();\n        }\n        return context;\n    }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nprivate func getNonNullContext() -> Context {\n    guard let context = getContext() else {\n        fatalError(\"IllegalStateException\")\n    }\n    return context\n}\n```"
    },
    {
        "method_name": "onTaskFinished",
        "method_code": "void onTaskFinished(RemoteOperationResult result);",
        "prompt": "\n        Please translate the following Java (Android) method titled onTaskFinished from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: onTaskFinished\n\n        Method Code: void onTaskFinished(RemoteOperationResult result);\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc onTaskFinished(result: RemoteOperationResult) {\n    // Implementation goes here\n}\n```"
    },
    {
        "method_name": "doInBackground",
        "method_code": "@Override\n        public final RemoteOperationResult doInBackground(Void... params) {\n            Log_OC.d(TAG, \"run ReloadFolderDocumentTask(), id=\" + folder.getDocumentId());\n            return new RefreshFolderOperation(folder.getFile(),\n                                              System.currentTimeMillis(),\n                                              false,\n                                              true,\n                                              true,\n                                              folder.getStorageManager(),\n                                              folder.getUser(),\n                                              MainApp.getAppContext())\n                .execute(folder.getClient());\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled doInBackground from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: doInBackground\n\n        Method Code: @Override\n        public final RemoteOperationResult doInBackground(Void... params) {\n            Log_OC.d(TAG, \"run ReloadFolderDocumentTask(), id=\" + folder.getDocumentId());\n            return new RefreshFolderOperation(folder.getFile(),\n                                              System.currentTimeMillis(),\n                                              false,\n                                              true,\n                                              true,\n                                              folder.getStorageManager(),\n                                              folder.getUser(),\n                                              MainApp.getAppContext())\n                .execute(folder.getClient());\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func doInBackground(_ params: Void...) -> RemoteOperationResult {\n    Log_OC.d(TAG, \"run ReloadFolderDocumentTask(), id=\\(folder.getDocumentId())\")\n    return RefreshFolderOperation(file: folder.getFile(),\n                                  timestamp: Date().timeIntervalSince1970,\n                                  param1: false,\n                                  param2: true,\n                                  param3: true,\n                                  storageManager: folder.getStorageManager(),\n                                  user: folder.getUser(),\n                                  context: MainApp.getAppContext())\n        .execute(client: folder.getClient())\n}\n```"
    },
    {
        "method_name": "onPostExecute",
        "method_code": "@Override\n        public final void onPostExecute(RemoteOperationResult result) {\n            if (callback != null) {\n                callback.onTaskFinished(result);\n            }\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled onPostExecute from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: onPostExecute\n\n        Method Code: @Override\n        public final void onPostExecute(RemoteOperationResult result) {\n            if (callback != null) {\n                callback.onTaskFinished(result);\n            }\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\noverride func onPostExecute(result: RemoteOperationResult) {\n    callback?.onTaskFinished(result)\n}\n```"
    },
    {
        "method_name": "getDocumentId",
        "method_code": "public String getDocumentId() {\n            for(String key: rootIdToStorageManager.keySet()) {\n                if (Objects.equals(storageManager, rootIdToStorageManager.get(key))) {\n                    return key + DOCUMENTID_SEPARATOR + fileId;\n                }\n            }\n            return null;\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getDocumentId from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getDocumentId\n\n        Method Code: public String getDocumentId() {\n            for(String key: rootIdToStorageManager.keySet()) {\n                if (Objects.equals(storageManager, rootIdToStorageManager.get(key))) {\n                    return key + DOCUMENTID_SEPARATOR + fileId;\n                }\n            }\n            return null;\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getDocumentId() -> String? {\n    for (key, value) in rootIdToStorageManager {\n        if storageManager == value {\n            return key + DOCUMENTID_SEPARATOR + fileId\n        }\n    }\n    return nil\n}\n```"
    },
    {
        "method_name": "getStorageManager",
        "method_code": "FileDataStorageManager getStorageManager() {\n            return storageManager;\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getStorageManager from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getStorageManager\n\n        Method Code: FileDataStorageManager getStorageManager() {\n            return storageManager;\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getStorageManager() -> FileDataStorageManager {\n    return storageManager\n}\n```"
    },
    {
        "method_name": "getUser",
        "method_code": "public User getUser() {\n            return getStorageManager().getUser();\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getUser from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getUser\n\n        Method Code: public User getUser() {\n            return getStorageManager().getUser();\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getUser() -> User {\n    return getStorageManager().getUser()\n}\n```"
    },
    {
        "method_name": "getFile",
        "method_code": "public OCFile getFile() {\n            return getStorageManager().getFileById(fileId);\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getFile from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getFile\n\n        Method Code: public OCFile getFile() {\n            return getStorageManager().getFileById(fileId);\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getFile() -> OCFile? {\n    return getStorageManager().getFileById(fileId)\n}\n```"
    },
    {
        "method_name": "getRemotePath",
        "method_code": "public String getRemotePath() {\n            return getFile().getRemotePath();\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getRemotePath from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getRemotePath\n\n        Method Code: public String getRemotePath() {\n            return getFile().getRemotePath();\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getRemotePath() -> String {\n    return getFile().getRemotePath()\n}\n```"
    },
    {
        "method_name": "getClient",
        "method_code": "OwnCloudClient getClient() {\n            try {\n\n                OwnCloudAccount ocAccount = getUser().toOwnCloudAccount();\n                return OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount, getContext());\n            } catch (OperationCanceledException | IOException | AuthenticatorException e) {\n                Log_OC.e(TAG, \"Failed to set client\", e);\n            }\n            return null;\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getClient from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getClient\n\n        Method Code: OwnCloudClient getClient() {\n            try {\n\n                OwnCloudAccount ocAccount = getUser().toOwnCloudAccount();\n                return OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount, getContext());\n            } catch (OperationCanceledException | IOException | AuthenticatorException e) {\n                Log_OC.e(TAG, \"Failed to set client\", e);\n            }\n            return null;\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getClient() -> OwnCloudClient? {\n    do {\n        let ocAccount = try getUser().toOwnCloudAccount()\n        return OwnCloudClientManagerFactory.getDefaultSingleton().getClientFor(ocAccount, context: getContext())\n    } catch {\n        Log_OC.e(TAG, \"Failed to set client\", error)\n    }\n    return nil\n}\n```"
    },
    {
        "method_name": "isExpired",
        "method_code": "boolean isExpired() {\n            return getFile().getLastSyncDateForData() + CACHE_EXPIRATION < System.currentTimeMillis();\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled isExpired from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: isExpired\n\n        Method Code: boolean isExpired() {\n            return getFile().getLastSyncDateForData() + CACHE_EXPIRATION < System.currentTimeMillis();\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc isExpired() -> Bool {\n    return getFile().getLastSyncDateForData() + CACHE_EXPIRATION < Date().timeIntervalSince1970 * 1000\n}\n```"
    },
    {
        "method_name": "getParent",
        "method_code": "Document getParent() {\n            long parentId = getFile().getParentId();\n            if (parentId <= 0) {\n                return null;\n            }\n\n            return new Document(getStorageManager(), parentId);\n        }",
        "prompt": "\n        Please translate the following Java (Android) method titled getParent from DocumentsStorageProvider.java into Swift.\n\n        Input:\n\n        Method Name: getParent\n\n        Method Code: Document getParent() {\n            long parentId = getFile().getParentId();\n            if (parentId <= 0) {\n                return null;\n            }\n\n            return new Document(getStorageManager(), parentId);\n        }\n\n        Abstract Syntax Tree: AST not available\n\n        Output Requirement: Return only the translated Swift code. No additional details, explanation, or formatting is required.\n        ",
        "translateMethod": "```swift\nfunc getParent() -> Document? {\n    let parentId = getFile().getParentId()\n    if parentId <= 0 {\n        return nil\n    }\n    \n    return Document(getStorageManager(), parentId)\n}\n```"
    }
]